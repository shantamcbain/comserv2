.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "YAML::XS 3"
.TH YAML::XS 3 2025-05-08 "perl v5.40.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
YAML::XS \- Perl YAML Serialization using XS and libyaml
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use YAML::XS;
\&
\&    # Classic functional interface
\&    my $yaml = Dump [ 1..4 ];
\&    my $array = Load $yaml;
\&
\&    # EXPERIMENTAL: Object Oriented interface for YAML 1.2
\&    # Incompatible to functional interface!
\&    my $xs = YAML::XS\->new;
\&    my $yaml = $xs\->dump([ 1..4 ]);
\&    my $array = $xs\->load($yaml);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Kirill Simonov's \f(CW\*(C`libyaml\*(C'\fR is arguably the best YAML implementation. The C library is written precisely to the YAML 1.1 specification. It was originally bound to Python and was later bound to Ruby.
.PP
This module is a Perl XS binding to libyaml which offers Perl the best YAML support to date.
.PP
This module exports the functions \f(CW\*(C`Dump\*(C'\fR, \f(CW\*(C`Load\*(C'\fR, \f(CW\*(C`DumpFile\*(C'\fR and \f(CW\*(C`LoadFile\*(C'\fR. These functions are intended to work exactly like \f(CW\*(C`YAML.pm\*(C'\fR's corresponding functions. Only \f(CW\*(C`Load\*(C'\fR and \f(CW\*(C`Dump\*(C'\fR are exported by default.
.SH CONFIGURATION
.IX Header "CONFIGURATION"
The object oriented interface is described below: "OBJECT ORIENTED INTERFACE"
.IP \(bu 4
\&\f(CW$YAML::XS::LoadBlessed\fR (since v0.69)
.Sp
Default: false.
.Sp
The default was changed in version 0.81.
.Sp
When set to false, it will not bless data into objects, which can be a security problem, when loading YAML from an untrusted source. It will silently ignore the tag and just load the data unblessed.
.Sp
In PyYAML, this is called SafeLoad.
.Sp
If set to true, it will load the following YAML as objects:
.Sp
.Vb 4
\&    \-\-\-
\&    local: !Foo::Bar [a]
\&    perl: !!perl/hash:Foo::Bar { a: 1 }
\&    regex: !!perl/regexp:Foo::Bar pattern
.Ve
.Sp
You can create any kind of object with YAML. The creation itself is not the critical part. If the class has a \f(CW\*(C`DESTROY\*(C'\fR method, it will be called once the object is deleted. An example with File::Temp removing files can be found at <https://bugs.debian.org/cgi\-bin/bugreport.cgi?bug=862373>.
.IP \(bu 4
\&\f(CW$YAML::XS::ForbidDuplicateKeys\fR (since 0.84)
.Sp
Default: false
.Sp
When set to true, \f(CW\*(C`Load\*(C'\fR will die when encountering a duplicate key in a hash, e.g.
.Sp
.Vb 2
\&    key: value
\&    key: another value
.Ve
.Sp
This can be useful for bigger YAML documents where it is not that obvious, and it is recommended to set it to true. That's also what a YAML loader should do by default according to the YAML specification.
.IP \(bu 4
\&\f(CW$YAML::XS::UseCode\fR
.IP \(bu 4
\&\f(CW$YAML::XS::DumpCode\fR
.IP \(bu 4
\&\f(CW$YAML::XS::LoadCode\fR
.Sp
If enabled supports deparsing and evaling of code blocks.
.Sp
Note that support for loading code was added in version 0.75, although \f(CW$LoadCode\fR was documented already in earlier versions.
.IP \(bu 4
\&\f(CW$YAML::XS::QuoteNumericStrings\fR
.Sp
When true (the default) strings that look like numbers but have not been numified will be quoted when dumping.
.Sp
This ensures leading that things like leading zeros and other formatting are preserved.
.IP \(bu 4
\&\f(CW$YAML::XS::Boolean\fR (since v0.67)
.Sp
Default: undef
.Sp
Since YAML::XS 0.89: When used with perl 5.36 or later, builtin booleans will work out of the box. They will be created by \f(CW\*(C`Load\*(C'\fR and recognized by \f(CW\*(C`Dump\*(C'\fR automatically (since YAML::XS 0.89).
.Sp
.Vb 2
\&    say Dump({ truth => builtin::true });
\&    # truth: true
.Ve
.Sp
Since YAML::XS v0.902: loaded booleans are not set to readonly anymore.
.Sp
For older perl versions you can use the following configuration to serialize data as YAML booleans:
.Sp
When set to \f(CW"JSON::PP"\fR or \f(CW"boolean"\fR, the plain (unquoted) strings \f(CW\*(C`true\*(C'\fR and \f(CW\*(C`false\*(C'\fR will be loaded as \f(CW\*(C`JSON::PP::Boolean\*(C'\fR or \f(CW\*(C`boolean.pm\*(C'\fR objects. Those objects will be dumped again as plain "true" or "false".
.Sp
It will try to load [JSON::PP] or [boolean] and die if it can't be loaded.
.Sp
With that it's possible to add new "real" booleans to a data structure:
.Sp
.Vb 6
\&    local $YAML::XS::Boolean = "JSON::PP"; # or "boolean"
\&    my $data = Load("booltrue: true");
\&    $data\->{boolfalse} = JSON::PP::false;
\&    my $yaml = Dump($data);
\&    # boolfalse: false
\&    # booltrue: true
.Ve
.Sp
It also lets booleans survive when loading YAML via YAML::XS and encode it in JSON via one of the various JSON encoders, which mostly support JSON::PP booleans.
.Sp
Please note that JSON::PP::Boolean and boolean.pm behave a bit differently. Ideally you should only use them in boolean context.
.Sp
If not set, booleans are loaded as special perl variables \f(CW\*(C`PL_sv_yes\*(C'\fR and \f(CW\*(C`PL_sv_no\*(C'\fR, which have the disadvantage that they are readonly, and you can't add those to an existing data structure with pure perl.
.Sp
If you simply need to load "perl booleans" that are true or false in boolean context, you will be fine with the default setting.
.IP \(bu 4
\&\f(CW$YAML::XS::Indent\fR (since v0.76)
.Sp
Default is 2.
.Sp
Sets the number of spaces for indentation for \f(CW\*(C`Dump\*(C'\fR.
.SH "USING YAML::XS WITH UNICODE"
.IX Header "USING YAML::XS WITH UNICODE"
Handling unicode properly in Perl can be a pain. YAML::XS only deals with streams of utf8 octets. Just remember this:
.PP
.Vb 2
\&    $perl = Load($utf8_octets);
\&    $utf8_octets = Dump($perl);
.Ve
.PP
There are many, many places where things can go wrong with unicode. If you are having problems, use Devel::Peek on all the possible data points.
.SH "OBJECT ORIENTED INTERFACE"
.IX Header "OBJECT ORIENTED INTERFACE"
Since version v0.904.0, EXPERIMENTAL
.PP
+++NOTE: This is incompatible with the functional interface and will treat
YAML values in a different way.+++
.PP
This has two MAJOR differences to the old functional interface:
.IP "Object with options" 4
.IX Item "Object with options"
This provides an interface where you create a YAML::XS object with
options (instead of the old interface with global variables).
.IP "YAML 1.2 Core Schema" 4
.IX Item "YAML 1.2 Core Schema"
It implements the YAML 1.2 Core Schema.
.Sp
(Note that the functional interface does not implement YAML 1.1, when it comes
to loading numbers, booleans, null etc. It implements its own set of rules.)
.Sp
Here is an (incomplete!) example of values that are treated differently than
with the functional interface. YAML values that match a certain pattern,
are not loaded as strings, but as other types:
.Sp
.Vb 6
\&    # Functional interface: special values (not compatible to other YAML modules)
\&    \- [true, false]                             # booleans
\&    \- [null, ~]                                 # undef
\&    \- [inf, INF, iNf, iNF, InF, INf, \-inf, ...] # Inf
\&    \- [100_000]                                 # 100000
\&    \- # anything that looks_like_number()       # number
\&
\&    # OOP YAML 1.2 special values
\&    \- [true, True, TRUE, false, False, FALSE]   # booleans
\&    \- [null, Null, NULL, ~]                     # undef
\&    \- [.inf, .Inf, .INF, \-.inf, \-.Inf, \-.INF]   # Inf
\&    \- [.nan, .NAN, .NaN]                        # nan
\&    \- [42, 0x10, 0o10]                          # dec 42, hex 16, oct 8
.Ve
.Sp
For more subtle differences regarding numbers checkout the comprehensive data
here:
.RS 4
.IP "YAML 1.1 / 1.2 definitions: <https://perlpunk.github.io/yaml\-test\-schema/schemas.html>" 4
.IX Item "YAML 1.1 / 1.2 definitions: <https://perlpunk.github.io/yaml-test-schema/schemas.html>"
.PD 0
.IP "Test data: <https://perlpunk.github.io/yaml\-test\-schema/data.html>" 4
.IX Item "Test data: <https://perlpunk.github.io/yaml-test-schema/data.html>"
.RE
.RS 4
.PD
.Sp
This way the OOP interface is compatible to YAML::PP and YAML processors in
other languages supporting YAML 1.2.
.RE
.ie n .IP """load"" will return the first document in scalar context" 4
.el .IP "\f(CWload\fR will return the first document in scalar context" 4
.IX Item "load will return the first document in scalar context"
The functional interface returns the last.
.IP "Numbers don't have string flags" 4
.IX Item "Numbers don't have string flags"
.PD 0
.IP "Booleans currently are only preserved for the new builtin booleans" 4
.IX Item "Booleans currently are only preserved for the new builtin booleans"
.PD
Adding a JSON::PP boolean option for older perls is planned
.IP "References, objects, globs, regexes and coderefs cannot be loaded or dumped" 4
.IX Item "References, objects, globs, regexes and coderefs cannot be loaded or dumped"
This is planned.
.SS Usage
.IX Subsection "Usage"
.Vb 3
\&    use YAML::XS ();
\&    my $xs = YAML::XS\->new;
\&    my $yaml = "foo: bar";
\&
\&    # Load single (first) document:
\&    my $data = $xs\->load($yaml);
\&    $yaml = $xs\->dump($data);
\&
\&    # Or to load all documents:
\&    my @data = $xs\->load($yaml);
\&    $yaml = $xs\->dump(@data);
.Ve
.SS METHODS
.IX Subsection "METHODS"
\fInew\fR
.IX Subsection "new"
.PP
.Vb 4
\&    use YAML::XS;
\&    my $xs = YAML::XS\->new(
\&        # load options
\&        # require_footer => 0,
\&
\&        # dump options
\&        # indent => 2,
\&        # header => 1,
\&        # footer => 0,
\&        # width => 80,
\&        # anchor_prefix => \*(Aq\*(Aq,
\&
\&        # load and dump options
\&        # utf8 => 0,
\&    );
.Ve
.PP
Options:
.IP indent 4
.IX Item "indent"
Default: 2
.Sp
Sets the number of spaces for indentation for dumping.
.IP utf8 4
.IX Item "utf8"
Default: false
.Sp
When false, the loader will accept unencoded character strings, and the dumper
returns unencoded character strings.
.Sp
When true, the loader accepts a UTF\-8 encoded string of bytes, and the dumper
returns a UTF\-8 encoded string of bytes.
This typically makes sense when you read from / write to a file directly.
.IP header 4
.IX Item "header"
Default: 1
.Sp
Writes a \f(CW\*(C`\-\-\-\*(C'\fR before every document
.IP footer 4
.IX Item "footer"
Default: 0
.Sp
Writes a \f(CW\*(C`...\*(C'\fR at the end of every document.
.IP width 4
.IX Item "width"
Set the maximum number of colums for dumping. If a value has too many
characters, it will be split into multiple lines.
.IP require_footer 4
.IX Item "require_footer"
Default: 0
.Sp
Can be useful in a use case where you want to make sure you received the
complete document from the sender.
.IP anchor_prefix 4
.IX Item "anchor_prefix"
Default: \f(CW\*(Aq\*(Aq\fR
.Sp
If set to a string like \f(CW\*(C`ANCHOR\*(C'\fR, anchors and aliases will be prefixed
with this instead of just being numbers:
.Sp
.Vb 6
\&    # my $xs = YAML::XS\->new( anchor_prefix => \*(AqANCHOR\*(Aq );
\&    # my $hash = { some => "mapping" };
\&    # say $xs\->dump([$hash, $hash]);
\&    \- &ANCHOR1
\&      some: mapping
\&    \- *ANCHOR1
.Ve
.PP
\fIload\fR
.IX Subsection "load"
.PP
.Vb 10
\&    my $yaml = <<\*(AqEOM\*(Aq;
\&    \-\-\-
\&    \- 23
\&    \-\-\-
\&    some: mapping
\&    EOM
\&    my $array = $xs\->load($yaml);
\&    # [23]
\&    my @documents = $xs\->load($yaml);
\&    # (
\&    #   [23],
\&    #   { some => "mapping" }
\&    # )
.Ve
.PP
In scalar context, if the YAML string contains more than one document, it will
return the first document.
.PP
\fIdump\fR
.IX Subsection "dump"
.PP
.Vb 3
\&    $yaml = $xs\->dump($data);
\&    $yaml = $xs\->dump($data1, $data2, $data3);
\&    $yaml = $xs\->dump(@data);
.Ve
.SH LIBYAML
.IX Header "LIBYAML"
You can find out (since v.079) which libyaml version this module was built with:
.PP
.Vb 1
\&    my $libyaml_version = YAML::XS::LibYAML::libyaml_version();
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP \(bu 4
YAML.pm
.IP \(bu 4
YAML::Syck
.IP \(bu 4
YAML::Tiny
.IP \(bu 4
YAML::PP
.IP \(bu 4
YAML::PP::LibYAML
.SH AUTHORS
.IX Header "AUTHORS"
.IP "Ingy döt Net ingy@ingy.net <mailto:ingy@ingy.net>" 4
.IX Item "Ingy döt Net ingy@ingy.net <mailto:ingy@ingy.net>"
.PD 0
.IP "Tina Müller <tinita@cpan.org>" 4
.IX Item "Tina Müller <tinita@cpan.org>"
.PD
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007\-2025 \- Ingy döt Net
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
