.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Moose::Manual::Concepts 3"
.TH Moose::Manual::Concepts 3 2025-07-04 "perl v5.40.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Moose::Manual::Concepts \- Moose OO concepts
.SH VERSION
.IX Header "VERSION"
version 2.4000
.SH "MOOSE CONCEPTS (VS ""OLD SCHOOL"" Perl)"
.IX Header "MOOSE CONCEPTS (VS ""OLD SCHOOL"" Perl)"
In the past, you may not have thought too much about the difference
between packages and classes, attributes and methods, constructors and
methods, etc. With Moose, these are all conceptually separate,
though under the hood they're implemented with plain old Perl.
.PP
Our meta-object protocol (aka MOP) provides well-defined introspection
features for each of those concepts, and Moose in turn provides
distinct sugar for each of them. Moose also introduces additional
concepts such as roles, method modifiers, and declarative delegation.
.PP
Knowing what these concepts mean in Moose-speak, and how they used to
be done in old school Perl 5 OO is a good way to start learning to use
Moose.
.SS Class
.IX Subsection "Class"
When you say "use Moose" in a package, you are making your package a
class. At its simplest, a class will consist simply of attributes
and/or methods. It can also include roles, method modifiers, and more.
.PP
A class \fIhas\fR zero or more \fBattributes\fR.
.PP
A class \fIhas\fR zero or more \fBmethods\fR.
.PP
A class \fIhas\fR zero or more superclasses (aka parent classes). A
class inherits from its superclass(es).
.PP
A class \fIhas\fR zero or more \fBmethod modifiers\fR. These modifiers can
apply to its own methods or methods that are inherited from its
ancestors.
.PP
A class \fIdoes\fR (and \fIconsumes\fR) zero or more \fBroles\fR.
.PP
A class \fIhas\fR a \fBconstructor\fR and a \fBdestructor\fR. These are
provided for you "for free" by Moose.
.PP
The \fBconstructor\fR accepts named parameters corresponding to the
class's attributes and uses them to initialize an \fBobject instance\fR.
.PP
A class \fIhas\fR a \fBmetaclass\fR, which in turn has \fBmeta-attributes\fR,
\&\fBmeta-methods\fR, and \fBmeta-roles\fR. This metaclass \fIdescribes\fR the
class.
.PP
A class is usually analogous to a category of nouns, like "People" or
"Users".
.PP
.Vb 1
\&  package Person;
\&
\&  use Moose;
\&  # now it\*(Aqs a Moose class!
.Ve
.SS Attribute
.IX Subsection "Attribute"
An attribute is a property of the class that defines it. It \fIalways\fR
has a name, and it \fImay have\fR a number of other properties.
.PP
These properties can include a read/write flag, a \fBtype\fR, accessor
method names, \fBdelegations\fR, a default value, and more.
.PP
Attributes \fIare not\fR methods, but defining them causes various
accessor methods to be created. At a minimum, a normal attribute will
have a reader accessor method. Many attributes have other
methods, such as a writer method, a clearer method, or a predicate method
("has it been set?").
.PP
An attribute may also define \fBdelegations\fR, which will create
additional methods based on the delegation mapping.
.PP
By default, Moose stores attributes in the object instance, which is a
hashref, \fIbut this is invisible to the author of a Moose-based
class\fR!  It is best to think of Moose attributes as "properties" of
the \fIopaque\fR \fBobject instance\fR. These properties are accessed
through well-defined accessor methods.
.PP
An attribute is something that the class's members have. For example,
People have first and last names. Users have passwords and last login
datetimes.
.PP
.Vb 4
\&  has \*(Aqfirst_name\*(Aq => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqStr\*(Aq,
\&  );
.Ve
.SS Method
.IX Subsection "Method"
A \fBmethod\fR is very straightforward. Any subroutine you define in your
class is a method.
.PP
\&\fBMethods\fR correspond to verbs, and are what your objects can do. For
example, a User can login.
.PP
.Vb 1
\&  sub login { ... }
.Ve
.SS Role
.IX Subsection "Role"
A role is something that a class \fIdoes\fR. We also say that classes
\&\fIconsume\fR roles. For example, a Machine class might do the Breakable
role, and so could a Bone class. A role is used to define some concept
that cuts across multiple unrelated classes, like "breakability", or
"has a color".
.PP
A role \fIhas\fR zero or more \fBattributes\fR.
.PP
A role \fIhas\fR zero or more \fBmethods\fR.
.PP
A role \fIhas\fR zero or more \fBmethod modifiers\fR.
.PP
A role \fIhas\fR zero or more \fBrequired methods\fR.
.PP
A required method is not implemented by the role. Required methods are a way
for the role to declare "to use this role you must implement this method".
.PP
A role \fIhas\fR zero or more \fBexcluded roles\fR.
.PP
An excluded role is a role that the role doing the excluding says it
cannot be combined with.
.PP
Roles are \fIcomposed\fR into classes (or other roles). When a role is
composed into a class, its attributes and methods are "flattened" into
the class. Roles \fIdo not\fR show up in the inheritance hierarchy. When
a role is composed, its attributes and methods appear as if they were
defined \fIin the consuming class\fR.
.PP
Role are somewhat like mixins or interfaces in other OO languages.
.PP
.Vb 1
\&  package Breakable;
\&
\&  use Moose::Role;
\&
\&  requires \*(Aqbreak\*(Aq;
\&
\&  has \*(Aqis_broken\*(Aq => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqBool\*(Aq,
\&  );
\&
\&  after \*(Aqbreak\*(Aq => sub {
\&      my $self = shift;
\&
\&      $self\->is_broken(1);
\&  };
.Ve
.SS "Method modifiers"
.IX Subsection "Method modifiers"
A \fBmethod modifier\fR is a hook that is called when a named method is
called. For example, you could say "before calling \f(CWlogin()\fR, call
this modifier first". Modifiers come in different flavors like
"before", "after", "around", and "augment", and you can apply more
than one modifier to a single method.
.PP
Method modifiers are often used as an alternative to overriding a
method in a parent class. They are also used in roles as a way of
modifying methods in the consuming class.
.PP
Under the hood, a method modifier is just a plain old Perl subroutine
that gets called before or after (or around, etc.) some named method.
.PP
.Vb 3
\&  before \*(Aqlogin\*(Aq => sub {
\&      my $self = shift;
\&      my $pw   = shift;
\&
\&      warn "Called login() with $pw\en";
\&  };
.Ve
.SS Type
.IX Subsection "Type"
Moose also comes with a (miniature) type system. This allows you to define
types for attributes. Moose has a set of built-in types based on the types
Perl provides in its core, such as \f(CW\*(C`Str\*(C'\fR, \f(CW\*(C`Num\*(C'\fR, \f(CW\*(C`Bool\*(C'\fR, \f(CW\*(C`HashRef\*(C'\fR, etc.
.PP
In addition, every class name in your application can also be used as
a type name.
.PP
Finally, you can define your own types with their own constraints. For
example, you could define a \f(CW\*(C`PosInt\*(C'\fR type, a subtype of \f(CW\*(C`Int\*(C'\fR which only
allows positive numbers.
.SS Delegation
.IX Subsection "Delegation"
Moose attributes provide declarative syntax for defining delegations. A
delegation is a method which in turn calls some method on an attribute to do
its real work.
.SS Constructor
.IX Subsection "Constructor"
A constructor creates an \fBobject instance\fR for the class. In old
school Perl, this was usually done by defining a method called
\&\f(CWnew()\fR which in turn called \f(CW\*(C`bless\*(C'\fR on a reference.
.PP
With Moose, this \f(CWnew()\fR method is created for you, and it simply
does the right thing. You should never need to define your own
constructor!
.PP
Sometimes you want to do something whenever an object is created. In
those cases, you can provide a \f(CWBUILD()\fR method in your class. Moose
will call this for you after creating a new object.
.SS Destructor
.IX Subsection "Destructor"
This is a special method called when an object instance goes out of
scope. You can specialize what your class does in this method if you
need to, but you usually don't.
.PP
With old school Perl 5, this is the \f(CWDESTROY()\fR method, but with
Moose it is the \f(CWDEMOLISH()\fR method.
.SS "Object instance"
.IX Subsection "Object instance"
An object instance is a specific noun in the class's "category". For
example, one specific Person or User. An instance is created by the
class's \fBconstructor\fR.
.PP
An instance has values for its attributes. For example, a specific
person has a first and last name.
.PP
In old school Perl 5, this is often a blessed hash reference. With
Moose, you should never need to know what your object instance
actually is. (Okay, it's usually a blessed hashref with Moose, too.)
.SS "Moose vs old school summary"
.IX Subsection "Moose vs old school summary"
.IP \(bu 4
Class
.Sp
A package with no introspection other than mucking about in the symbol
table.
.Sp
With Moose, you get well-defined declaration and introspection.
.IP \(bu 4
Attributes
.Sp
Hand-written accessor methods, symbol table hackery, or a helper
module like \f(CW\*(C`Class::Accessor\*(C'\fR.
.Sp
With Moose, these are declaratively defined, and distinct from
methods.
.IP \(bu 4
Method
.Sp
These are pretty much the same in Moose as in old school Perl.
.IP \(bu 4
Roles
.Sp
\&\f(CW\*(C`Class::Trait\*(C'\fR or \f(CW\*(C`Class::Role\*(C'\fR, or maybe \f(CW\*(C`mixin.pm\*(C'\fR.
.Sp
With Moose, they're part of the core feature set, and are
introspectable like everything else.
.IP \(bu 4
Method Modifiers
.Sp
Could only be done through serious symbol table wizardry, and you
probably never saw this before (at least in Perl 5).
.IP \(bu 4
Type
.Sp
Hand-written parameter checking in your \f(CWnew()\fR method and accessors.
.Sp
With Moose, you define types declaratively, and then use them by name
with your attributes.
.IP \(bu 4
Delegation
.Sp
\&\f(CW\*(C`Class::Delegation\*(C'\fR or \f(CW\*(C`Class::Delegator\*(C'\fR, but probably even more
hand-written code.
.Sp
With Moose, this is also declarative.
.IP \(bu 4
Constructor
.Sp
A \f(CWnew()\fR method which calls \f(CW\*(C`bless\*(C'\fR on a reference.
.Sp
Comes for free when you define a class with Moose.
.IP \(bu 4
Destructor
.Sp
A \f(CWDESTROY()\fR method.
.Sp
With Moose, this is called \f(CWDEMOLISH()\fR.
.IP \(bu 4
Object Instance
.Sp
A blessed reference, usually a hash reference.
.Sp
With Moose, this is an opaque thing which has a bunch of attributes
and methods, as defined by its class.
.IP \(bu 4
Immutabilization
.Sp
Moose comes with a feature called "immutabilization". When you make
your class immutable, it means you're done adding methods, attributes,
roles, etc. This lets Moose optimize your class with a bunch of
extremely dirty in-place code generation tricks that speed up things
like object construction and so on.
.SH "META WHAT?"
.IX Header "META WHAT?"
A metaclass is a class that describes classes. With Moose, every class you
define gets a \f(CWmeta()\fR method. The \f(CWmeta()\fR method returns a
Moose::Meta::Class object, which has an introspection API that can tell you
about the class it represents.
.PP
.Vb 1
\&  my $meta = User\->meta();
\&
\&  for my $attribute ( $meta\->get_all_attributes ) {
\&      print $attribute\->name(), "\en";
\&
\&      if ( $attribute\->has_type_constraint ) {
\&          print "  type: ", $attribute\->type_constraint\->name, "\en";
\&      }
\&  }
\&
\&  for my $method ( $meta\->get_all_methods ) {
\&      print $method\->name, "\en";
\&  }
.Ve
.PP
Almost every concept we defined earlier has a meta class, so we have
Moose::Meta::Class, Moose::Meta::Attribute,
Moose::Meta::Method, Moose::Meta::Role,
Moose::Meta::TypeConstraint, Moose::Meta::Instance, and so on.
.SH "BUT I NEED TO DO IT MY WAY!"
.IX Header "BUT I NEED TO DO IT MY WAY!"
One of the great things about Moose is that if you dig down and find
that it does something the "wrong way", you can change it by extending
a metaclass. For example, you can have arrayref based objects, you can
make your constructors strict (no unknown parameters allowed!), you can
define a naming scheme for attribute accessors, you can make a class a
Singleton, and much, much more.
.PP
Many of these extensions require surprisingly small amounts of code,
and once you've done it once, you'll never have to hand-code "your way
of doing things" again. Instead you'll just load your favorite
extensions.
.PP
.Vb 1
\&  package MyWay::User;
\&
\&  use Moose;
\&  use MooseX::StrictConstructor;
\&  use MooseX::MyWay;
\&
\&  has ...;
.Ve
.SH "WHAT NEXT?"
.IX Header "WHAT NEXT?"
So you're sold on Moose. Time to learn how to really use it.
.PP
If you want to see how Moose would translate directly into old school
Perl 5 OO code, check out Moose::Manual::Unsweetened. This might be
helpful for quickly wrapping your brain around some aspects of "the
Moose way".
.PP
Or you can skip that and jump straight to Moose::Manual::Classes
and the rest of the Moose::Manual.
.PP
After that we recommend that you start with the Moose::Cookbook. If
you work your way through all the recipes under the basics section,
you should have a pretty good sense of how Moose works, and all of its
basic OO features.
.PP
After that, check out the Role recipes. If you're really curious, go
on and read the Meta and Extending recipes, but those are mostly there
for people who want to be Moose wizards and extend Moose itself.
.SH AUTHORS
.IX Header "AUTHORS"
.IP \(bu 4
Stevan Little <stevan@cpan.org>
.IP \(bu 4
Dave Rolsky <autarch@urth.org>
.IP \(bu 4
Jesse Luehrs <doy@cpan.org>
.IP \(bu 4
Shawn M Moore <sartak@cpan.org>
.IP \(bu 4
יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
.IP \(bu 4
Karen Etheridge <ether@cpan.org>
.IP \(bu 4
Florian Ragwitz <rafl@debian.org>
.IP \(bu 4
Hans Dieter Pearcey <hdp@cpan.org>
.IP \(bu 4
Chris Prather <chris@prather.org>
.IP \(bu 4
Matt S Trout <mstrout@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2006 by Infinity Interactive, Inc.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
