.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PDF::API2::Basic::PDF::File 3"
.TH PDF::API2::Basic::PDF::File 3 2024-05-18 "perl v5.40.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
PDF::API2::Basic::PDF::File \- Low\-level PDF file access
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 6
\& $p = PDF::API2::Basic::PDF::File\->open("filename.pdf", 1);
\& $p\->new_obj($obj_ref);
\& $p\->free_obj($obj_ref);
\& $p\->append_file;
\& $p\->close_file;
\& $p\->release;       # IMPORTANT!
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This class keeps track of the directory aspects of a PDF file. There are two
parts to the directory: the main directory object which is the parent to all
other objects and a chain of cross-reference tables and corresponding trailer
dictionaries starting with the main directory object.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
Within this class hierarchy, rather than making everything visible via methods,
which would be a lot of work, there are various instance variables which are
accessible via associative array referencing. To distinguish instance variables
from content variables (which may come from the PDF content itself), each such
variable will start with a space.
.PP
Variables which do not start with a space directly reflect elements in a PDF
dictionary. In the case of a PDF::API2::Basic::PDF::File, the elements reflect those in the
trailer dictionary.
.PP
Since some variables are not designed for class users to access, variables are
marked in the documentation with (R) to indicate that such an entry should only
be used as read-only information. (P) indicates that the information is private
and not designed for user use at all, but is included in the documentation for
completeness and to ensure that nobody else tries to use it.
.IP newroot 4
.IX Item "newroot"
This variable allows the user to create a new root entry to occur in the trailer
dictionary which is output when the file is written or appended. If you wish to
over-ride the root element in the dictionary you have, use this entry to indicate
that without losing the current Root entry. Notice that newroot should point to
a PDF level object and not just to a dictionary which does not have object status.
.IP "INFILE (R)" 4
.IX Item "INFILE (R)"
Contains the filehandle used to read this information into this PDF directory. Is
an IO object.
.IP "fname (R)" 4
.IX Item "fname (R)"
This is the filename which is reflected by INFILE, or the original IO object passed
in.
.IP "update (R)" 4
.IX Item "update (R)"
This indicates that the read file has been opened for update and that at some
point, \f(CW$p\fR\->\fBappendfile()\fR can be called to update the file with the changes that
have been made to the memory representation.
.IP "maxobj (R)" 4
.IX Item "maxobj (R)"
Contains the first usable object number above any that have already appeared
in the file so far.
.IP "outlist (P)" 4
.IX Item "outlist (P)"
This is a list of Objind which are to be output when the next appendfile or outfile
occurs.
.IP "firstfree (P)" 4
.IX Item "firstfree (P)"
Contains the first free object in the free object list. Free objects are removed
from the front of the list and added to the end.
.IP "lastfree (P)" 4
.IX Item "lastfree (P)"
Contains the last free object in the free list. It may be the same as the firstfree
if there is only one free object.
.IP "objcache (P)" 4
.IX Item "objcache (P)"
All objects are held in the cache to ensure that a system only has one occurrence of
each object. In effect, the objind class acts as a container type class to hold the
PDF object structure and it would be unfortunate if there were two identical
place-holders floating around a system.
.IP "epos (P)" 4
.IX Item "epos (P)"
The end location of the read-file.
.PP
Each trailer dictionary contains a number of private instance variables which
hold the chain together.
.IP "loc (P)" 4
.IX Item "loc (P)"
Contains the location of the start of the cross-reference table preceding the
trailer.
.IP "xref (P)" 4
.IX Item "xref (P)"
Contains an anonymous array of each cross-reference table entry.
.IP "prev (P)" 4
.IX Item "prev (P)"
A reference to the previous table. Note this differs from the Prev entry which
is in PDF which contains the location of the previous cross-reference table.
.SH METHODS
.IX Header "METHODS"
.SS PDF::API2::Basic::PDF::File\->new
.IX Subsection "PDF::API2::Basic::PDF::File->new"
Creates a new, empty file object which can act as the host to other PDF objects.
Since there is no file associated with this object, it is assumed that the
object is created in readiness for creating a new PDF file.
.ie n .SS "$p = PDF::API2::Basic::PDF::File\->open($filename, $update)"
.el .SS "\f(CW$p\fP = PDF::API2::Basic::PDF::File\->open($filename, \f(CW$update\fP)"
.IX Subsection "$p = PDF::API2::Basic::PDF::File->open($filename, $update)"
Opens the file and reads all the trailers and cross reference tables to build
a complete directory of objects.
.PP
\&\f(CW$update\fR specifies whether this file is being opened for updating and editing,
or simply to be read.
.PP
\&\f(CW$filename\fR may be an IO object
.ie n .SS $p\->version($version)
.el .SS \f(CW$p\fP\->version($version)
.IX Subsection "$p->version($version)"
Gets/sets the PDF version (e.g. 1.4)
.ie n .SS "$version = $p\->header_version($version)"
.el .SS "\f(CW$version\fP = \f(CW$p\fP\->header_version($version)"
.IX Subsection "$version = $p->header_version($version)"
Gets/sets the PDF version stored in the file header.
.ie n .SS "$version = $p\->trailer_version($version)"
.el .SS "\f(CW$version\fP = \f(CW$p\fP\->trailer_version($version)"
.IX Subsection "$version = $p->trailer_version($version)"
Gets/sets the PDF version stored in the document catalog.
.ie n .SS "$prev_version = $p\->require_version($version)"
.el .SS "\f(CW$prev_version\fP = \f(CW$p\fP\->require_version($version)"
.IX Subsection "$prev_version = $p->require_version($version)"
Ensures that the PDF version is at least \f(CW$version\fR.
.ie n .SS $p\->\fBrelease()\fP
.el .SS \f(CW$p\fP\->\fBrelease()\fP
.IX Subsection "$p->release()"
Releases ALL of the memory used by the PDF document and all of its
component objects.  After calling this method, do \fBNOT\fR expect to
have anything left in the \f(CW\*(C`PDF::API2::Basic::PDF::File\*(C'\fR object (so if
you need to save, be sure to do it before calling this method).
.PP
\&\fBNOTE\fR, that it is important that you call this method on any
\&\f(CW\*(C`PDF::API2::Basic::PDF::File\*(C'\fR object when you wish to destruct it and
free up its memory.  Internally, PDF files have an enormous number of
cross-references and this causes circular references within the
internal data structures.  Calling '\f(CWrelease()\fR' forces a brute-force
cleanup of the data structures, freeing up all of the memory.  Once
you've called this method, though, don't expect to be able to do
anything else with the \f(CW\*(C`PDF::API2::Basic::PDF::File\*(C'\fR object; it'll
have \fBno\fR internal state whatsoever.
.ie n .SS $p\->\fBappend_file()\fP
.el .SS \f(CW$p\fP\->\fBappend_file()\fP
.IX Subsection "$p->append_file()"
Appends the objects for output to the read file and then appends the appropriate table.
.ie n .SS $p\->out_file($fname)
.el .SS \f(CW$p\fP\->out_file($fname)
.IX Subsection "$p->out_file($fname)"
Writes a PDF file to a file of the given filename based on the current list of
objects to be output. It creates the trailer dictionary based on information
in \f(CW$self\fR.
.PP
\&\f(CW$fname\fR may be an IO object;
.ie n .SS $p\->create_file($fname)
.el .SS \f(CW$p\fP\->create_file($fname)
.IX Subsection "$p->create_file($fname)"
Creates a new output file (no check is made of an existing open file) of
the given filename or IO object. Note, make sure that \f(CW$p\fR\->{' version'} is set
correctly before calling this function.
.ie n .SS $p\->clone_file($fname)
.el .SS \f(CW$p\fP\->clone_file($fname)
.IX Subsection "$p->clone_file($fname)"
Creates a copy of the input file at the specified filename and sets it as the
output file for future writes.  A file handle may be passed instead of a
filename.
.ie n .SS $p\->close_file
.el .SS \f(CW$p\fP\->close_file
.IX Subsection "$p->close_file"
Closes up the open file for output by outputting the trailer etc.
.ie n .SS "($value, $str) = $p\->readval($str, %opts)"
.el .SS "($value, \f(CW$str\fP) = \f(CW$p\fP\->readval($str, \f(CW%opts\fP)"
.IX Subsection "($value, $str) = $p->readval($str, %opts)"
Reads a PDF value from the current position in the file. If \f(CW$str\fR is too short
then read some more from the current location in the file until the whole object
is read. This is a recursive call which may slurp in a whole big stream (unprocessed).
.PP
Returns the recursive data structure read and also the current \f(CW$str\fR that has been
read from the file.
.ie n .SS "$ref = $p\->read_obj($objind, %opts)"
.el .SS "\f(CW$ref\fP = \f(CW$p\fP\->read_obj($objind, \f(CW%opts\fP)"
.IX Subsection "$ref = $p->read_obj($objind, %opts)"
Given an indirect object reference, locate it and read the object returning
the read in object.
.ie n .SS "$ref = $p\->read_objnum($num, $gen, %opts)"
.el .SS "\f(CW$ref\fP = \f(CW$p\fP\->read_objnum($num, \f(CW$gen\fP, \f(CW%opts\fP)"
.IX Subsection "$ref = $p->read_objnum($num, $gen, %opts)"
Returns a fully read object of given number and generation in this file
.ie n .SS "$objind = $p\->new_obj($obj)"
.el .SS "\f(CW$objind\fP = \f(CW$p\fP\->new_obj($obj)"
.IX Subsection "$objind = $p->new_obj($obj)"
Creates a new, free object reference based on free space in the cross reference chain.
If nothing free then thinks up a new number. If \f(CW$obj\fR then turns that object into this
new object rather than returning a new object.
.ie n .SS $p\->out_obj($objind)
.el .SS \f(CW$p\fP\->out_obj($objind)
.IX Subsection "$p->out_obj($objind)"
Indicates that the given object reference should appear in the output xref
table whether with data or freed.
.ie n .SS $p\->free_obj($objind)
.el .SS \f(CW$p\fP\->free_obj($objind)
.IX Subsection "$p->free_obj($objind)"
Marks an object reference for output as being freed.
.ie n .SS $p\->remove_obj($objind)
.el .SS \f(CW$p\fP\->remove_obj($objind)
.IX Subsection "$p->remove_obj($objind)"
Removes the object from all places where we might remember it
.ie n .SS $p\->ship_out(@objects)
.el .SS \f(CW$p\fP\->ship_out(@objects)
.IX Subsection "$p->ship_out(@objects)"
Ships the given objects (or all objects for output if \f(CW@objects\fR is empty) to
the currently open output file (assuming there is one). Freed objects are not
shipped, and once an object is shipped it is switched such that this file
becomes its source and it will not be shipped again unless out_obj is called
again. Notice that a shipped out object can be re-output or even freed, but
that it will not cause the data already output to be changed.
.ie n .SS "$p\->copy($outpdf, \e&filter)"
.el .SS "\f(CW$p\fP\->copy($outpdf, \e&filter)"
.IX Subsection "$p->copy($outpdf, &filter)"
Iterates over every object in the file reading the object, calling filter with the object
and outputting the result. if filter is not defined, then just copies input to output.
.SH "PRIVATE METHODS & FUNCTIONS"
.IX Header "PRIVATE METHODS & FUNCTIONS"
The following methods and functions are considered private to this class. This
does not mean you cannot use them if you have a need, just that they aren't really
designed for users of this class.
.ie n .SS "$offset = $p\->locate_obj($num, $gen)"
.el .SS "\f(CW$offset\fP = \f(CW$p\fP\->locate_obj($num, \f(CW$gen\fP)"
.IX Subsection "$offset = $p->locate_obj($num, $gen)"
Returns a file offset to the object asked for by following the chain of cross
reference tables until it finds the one you want.
.ie n .SS "update($fh, $str, $instream)"
.el .SS "update($fh, \f(CW$str\fP, \f(CW$instream\fP)"
.IX Subsection "update($fh, $str, $instream)"
Keeps reading \f(CW$fh\fR for more data to ensure that \f(CW$str\fR has at least a line full
for \f(CW\*(C`readval\*(C'\fR to work on. At this point we also take the opportunity to ignore
comments.
.ie n .SS "$objind = $p\->test_obj($num, $gen)"
.el .SS "\f(CW$objind\fP = \f(CW$p\fP\->test_obj($num, \f(CW$gen\fP)"
.IX Subsection "$objind = $p->test_obj($num, $gen)"
Tests the cache to see whether an object reference (which may or may not have
been \fBgetobj()\fRed) has been cached. Returns it if it has.
.ie n .SS $p\->add_obj($objind)
.el .SS \f(CW$p\fP\->add_obj($objind)
.IX Subsection "$p->add_obj($objind)"
Adds the given object to the internal object cache.
.ie n .SS "$tdict = $p\->readxrtr($xpos)"
.el .SS "\f(CW$tdict\fP = \f(CW$p\fP\->readxrtr($xpos)"
.IX Subsection "$tdict = $p->readxrtr($xpos)"
Recursive function which reads each of the cross-reference and trailer tables
in turn until there are no more.
.PP
Returns a dictionary corresponding to the trailer chain. Each trailer also
includes the corresponding cross-reference table.
.PP
The structure of the xref private element in a trailer dictionary is of an
anonymous hash of cross reference elements by object number. Each element
consists of an array of 3 elements corresponding to the three elements read
in [location, generation number, free or used]. See the PDF specification
for details.
.ie n .SS $p\->out_trailer($tdict)
.el .SS \f(CW$p\fP\->out_trailer($tdict)
.IX Subsection "$p->out_trailer($tdict)"
Outputs the body and trailer for a PDF file by outputting all the objects in
the ' outlist' and then outputting a xref table for those objects and any
freed ones. It then outputs the trailing dictionary and the trailer code.
.SS PDF::API2::Basic::PDF::File\->_new
.IX Subsection "PDF::API2::Basic::PDF::File->_new"
Creates a very empty PDF file object (used by new and open)
.SH AUTHOR
.IX Header "AUTHOR"
Martin Hosken Martin_Hosken@sil.org
.PP
Copyright Martin Hosken 1999 and onwards
.PP
No warranty or expression of effectiveness, least of all regarding anyone's
safety, is implied in this software or documentation.
