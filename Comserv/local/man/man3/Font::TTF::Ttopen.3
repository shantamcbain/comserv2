.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Font::TTF::Ttopen 3"
.TH Font::TTF::Ttopen 3 2016-08-03 "perl v5.40.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Font::TTF::Ttopen \- Opentype superclass for standard Opentype lookup based tables
(GSUB and GPOS)
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Handles all the script, lang, feature, lookup stuff for a
Font::TTF::Gsub/Font::TTF::Gpos table leaving the class specifics to the
subclass
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
The instance variables of an opentype table form a complex sub-module hierarchy.
.IP Version 4
.IX Item "Version"
This contains the version of the table as a floating point number
.IP SCRIPTS 4
.IX Item "SCRIPTS"
The scripts list is a hash of script tags. Each script tag (of the form
\&\f(CW$t\fR\->{'SCRIPTS'}{$tag}) has information below it.
.RS 4
.IP OFFSET 8
.IX Item "OFFSET"
This variable is preceded by a space and gives the offset from the start of the
table (not the table section) to the script table for this script
.IP REFTAG 8
.IX Item "REFTAG"
This variable is preceded by a space and gives a corresponding script tag to this
one such that the offsets in the file are the same. When writing, it is up to the
caller to ensure that the REFTAGs are set correctly, since these will be used to
assume that the scripts are identical. Note that REFTAG must refer to a script which
has no REFTAG of its own.
.IP DEFAULT 8
.IX Item "DEFAULT"
This corresponds to the default language for this script, if there is one, and
contains the same information as an itemised language
.IP LANG_TAGS 8
.IX Item "LANG_TAGS"
This contains an array of language tag strings (each 4 bytes) corresponding to
the languages listed by this script
.ie n .IP $lang 8
.el .IP \f(CW$lang\fR 8
.IX Item "$lang"
Each language is a hash containing its information:
.RS 8
.IP OFFSET 12
.IX Item "OFFSET"
This variable is preceded by a a space and gives the offset from the start of
the whole table to the language table for this language
.IP REFTAG 12
.IX Item "REFTAG"
This variable is preceded by a space and has the same function as for the script
REFTAG, only for the languages within a script.
.IP RE-ORDER 12
.IX Item "RE-ORDER"
This indicates re-ordering information, and has not been set. The value should
always be 0.
.IP DEFAULT 12
.IX Item "DEFAULT"
This holds the index of the default feature, if there is one, or \-1 otherwise.
.IP FEATURES 12
.IX Item "FEATURES"
This is an array of feature tags for all the features enabled for this language
.RE
.RS 8
.RE
.RE
.RS 4
.RE
.IP FEATURES 4
.IX Item "FEATURES"
The features section of instance variables corresponds to the feature table in
the opentype table.
.RS 4
.IP FEAT_TAGS 8
.IX Item "FEAT_TAGS"
This array gives the ordered list of feature tags for this table. It is used during
reading and writing for converting between feature index and feature tag.
.RE
.RS 4
.Sp
The rest of the FEATURES variable is itself a hash based on the feature tag for
each feature. Each feature has the following structure:
.IP OFFSET 8
.IX Item "OFFSET"
This attribute is preceded by a space and gives the offset relative to the start of the whole
table of this particular feature.
.IP PARMS 8
.IX Item "PARMS"
If FeatureParams are defined for this feature, this contains a reference to the corresponding FeatureParams object.  Otherwise set to null.
.IP LOOKUPS 8
.IX Item "LOOKUPS"
This is an array containing indices to lookups in the LOOKUP instance variable of the table
.IP INDEX 8
.IX Item "INDEX"
This gives the feature index for this feature and is used during reading and writing for
converting between feature tag and feature index.
.RE
.RS 4
.RE
.IP LOOKUP 4
.IX Item "LOOKUP"
This variable is an array of lookups in order and is indexed via the features of a language of a
script. Each lookup contains subtables and other information:
.RS 4
.IP OFFSET 8
.IX Item "OFFSET"
This name is preceded by a space and contains the offset from the start of the table to this
particular lookup
.IP TYPE 8
.IX Item "TYPE"
This is a subclass specific type for a lookup. It stipulates the type of lookup and hence subtables
within the lookup
.IP FLAG 8
.IX Item "FLAG"
Holds the lookup flag bits
.IP FILTER 8
.IX Item "FILTER"
Holds the MarkFilteringSet (that is, the index into GDEF\->MARKSETS) for the lookup.
.IP SUB 8
.IX Item "SUB"
This holds an array of subtables which are subclass specific. Each subtable must have
an OFFSET. The other variables described here are an abstraction used in both the
GSUB and GPOS tables which are the target subclasses of this class.
.RS 8
.IP OFFSET 12
.IX Item "OFFSET"
This is preceded by a space and gives the offset relative to the start of the table for this
subtable
.IP FORMAT 12
.IX Item "FORMAT"
Gives the sub-table sub format for this GSUB subtable. It is assumed that this
value is correct when it comes time to write the subtable.
.IP COVERAGE 12
.IX Item "COVERAGE"
Most lookups consist of a coverage table corresponding to the first
glyph to match. The offset of this coverage table is stored here and the coverage
table looked up against the GSUB table proper. There are two lookups
without this initial coverage table which is used to index into the RULES array.
These lookups have one element in the RULES array which is used for the whole
match.
.IP RULES 12
.IX Item "RULES"
The rules are a complex array. In most cases, each element of the array 
corresponds to an element in the coverage table (governed by the coverage index). 
In a few caess, such as when there is
no coverage table, then there is considered to be only one element in the rules
array. Each element of the array is itself an array corresponding to the
possibly multiple string matches which may follow the initial glyph. Each
element of this array is a hash with fixed keys corresponding to information
needed to match a glyph string or act upon it. Thus the RULES element is an
array of arrays of hashes which contain the following keys:
.RS 12
.IP MATCH 16
.IX Item "MATCH"
This contains a sequence of elements held as an array. The elements may be
glyph ids (gid), class ids (cids), or offsets to coverage tables. Each element
corresponds to one glyph in the glyph string. See MATCH_TYPE for details of
how the different element types are marked.
.IP PRE 16
.IX Item "PRE"
This array holds the sequence of elements preceding the first match element
and has the same form as the MATCH array.
.IP POST 16
.IX Item "POST"
This array holds the sequence of elements to be tested for following the match
string and is of the same form as the MATCH array.
.IP ACTION 16
.IX Item "ACTION"
This array holds information regarding what should be done if a match is found.
The array may either hold glyph ids (which are used to replace or insert or
whatever glyphs in the glyph string) or 2 element arrays consisting of:
.RS 16
.IP OFFSET 20
.IX Item "OFFSET"
Offset from the start of the matched string that the lookup should start at
when processing the substring.
.IP LOOKUP_INDEX 20
.IX Item "LOOKUP_INDEX"
The index to a lookup to be acted upon on the match string.
.RE
.RS 16
.RE
.RE
.RS 12
.RE
.IP CLASS 12
.IX Item "CLASS"
For those lookups which use class categories rather than glyph ids for matching
this is the offset to the class definition used to categories glyphs in the
match string.
.IP PRE_CLASS 12
.IX Item "PRE_CLASS"
This is the offset to the class definition for the before match glyphs
.IP POST_CLASS 12
.IX Item "POST_CLASS"
This is the offset to the class definition for the after match glyphs.
.IP ACTION_TYPE 12
.IX Item "ACTION_TYPE"
This string holds the type of information held in the ACTION variable of a RULE.
It is subclass specific.
.IP MATCH_TYPE 12
.IX Item "MATCH_TYPE"
This holds the type of information in the MATCH array of a RULE. This is subclass
specific.
.IP ADJUST 12
.IX Item "ADJUST"
This corresponds to a single action for all items in a coverage table. The meaning
is subclass specific.
.IP CACHE 12
.IX Item "CACHE"
This key starts with a space
.Sp
A hash of other tables (such as coverage tables, classes, anchors, device tables)
based on the offset given in the subtable to that other information.
Note that the documentation is particularly
unhelpful here in that such tables are given as offsets relative to the
beginning of the subtable not the whole GSUB table. This includes those items which
are stored relative to another base within the subtable.
.RE
.RS 8
.RE
.RE
.RS 4
.RE
.SH METHODS
.IX Header "METHODS"
.ie n .SS $t\->read
.el .SS \f(CW$t\fP\->read
.IX Subsection "$t->read"
Reads the table passing control to the subclass to handle the subtable specifics
.ie n .SS "$t\->read_sub($fh, $lookup, $index)"
.el .SS "\f(CW$t\fP\->read_sub($fh, \f(CW$lookup\fP, \f(CW$index\fP)"
.IX Subsection "$t->read_sub($fh, $lookup, $index)"
This stub is to allow subclasses to read subtables of lookups in a table specific manner. A
reference to the lookup is passed in along with the subtable index. The file is located at the
start of the subtable to be read
.ie n .SS $t\->\fBextension()\fP
.el .SS \f(CW$t\fP\->\fBextension()\fP
.IX Subsection "$t->extension()"
Returns the lookup number for the extension table that allows access to 32\-bit offsets.
.ie n .SS $t\->out($fh)
.el .SS \f(CW$t\fP\->out($fh)
.IX Subsection "$t->out($fh)"
Writes this Opentype table to the output calling \f(CW$t\fR\->out_sub for each sub table
at the appropriate point in the output. The assumption is that on entry the
number of scripts, languages, features, lookups, etc. are all resolved and
the relationships fixed. This includes a LANG_TAGS list for a script, and that all
scripts and languages in their respective dictionaries either have a REFTAG or contain
real data.
.ie n .SS $t\->num_sub($lookup)
.el .SS \f(CW$t\fP\->num_sub($lookup)
.IX Subsection "$t->num_sub($lookup)"
Asks the subclass to count the number of subtables for a particular lookup and to
return that value. Used in \fBout()\fR.
.ie n .SS "$t\->out_sub($fh, $lookup, $index)"
.el .SS "\f(CW$t\fP\->out_sub($fh, \f(CW$lookup\fP, \f(CW$index\fP)"
.IX Subsection "$t->out_sub($fh, $lookup, $index)"
This stub is to allow subclasses to output subtables of lookups in a table specific manner. A
reference to the lookup is passed in along with the subtable index. The file is located at the
start of the subtable to be output
.ie n .SS $t\->dirty
.el .SS \f(CW$t\fP\->dirty
.IX Subsection "$t->dirty"
Setting GPOS or GSUB dirty means that OS/2 may need updating, so set it dirty.
.ie n .SS $t\->maxContext
.el .SS \f(CW$t\fP\->maxContext
.IX Subsection "$t->maxContext"
Returns the length of the longest opentype rule in this table.
.ie n .SS $t\->update
.el .SS \f(CW$t\fP\->update
.IX Subsection "$t->update"
Perform various housekeeping items:
.PP
For all lookups, set/clear 0x0010 bit of flag words based on 'FILTER' value.
.PP
Sort COVERAGE table and RULES for all lookups.
.PP
Unless \f(CW$t\fR\->{' PARENT'}{' noharmony'} is true, update will make sure that GPOS and GSUB include 
the same scripts and languages. Any added scripts and languages will have empty feature sets.
.SH "Internal Functions & Methods"
.IX Header "Internal Functions & Methods"
Most of these methods are used by subclasses for handling such things as coverage
tables.
.SS copy($ref)
.IX Subsection "copy($ref)"
Internal function to copy the top level of a dictionary to create a new dictionary.
Only the top level is copied.
.ie n .SS "$t\->read_cover($cover_offset, $lookup_loc, $lookup, $fh, $is_cover)"
.el .SS "\f(CW$t\fP\->read_cover($cover_offset, \f(CW$lookup_loc\fP, \f(CW$lookup\fP, \f(CW$fh\fP, \f(CW$is_cover\fP)"
.IX Subsection "$t->read_cover($cover_offset, $lookup_loc, $lookup, $fh, $is_cover)"
Reads a coverage table and stores the results in \f(CW$lookup\fR\->{' CACHE'}, that is, if
it has not been read already.
.ie n .SS "ref_cache($obj, $cache, $offset [, $template])"
.el .SS "ref_cache($obj, \f(CW$cache\fP, \f(CW$offset\fP [, \f(CW$template\fP])"
.IX Subsection "ref_cache($obj, $cache, $offset [, $template])"
Internal function to keep track of the local positioning of subobjects such as
coverage and class definition tables, and their offsets.
What happens is that the cache is a hash of
sub objects indexed by the reference (using a string mashing of the
reference name which is valid for the duration of the reference) and holds a
list of locations in the output string which should be filled in with the
offset to the sub object when the final string is output in out_final.
.PP
Uses tricks for Tie::Refhash
.ie n .SS "out_final($fh, $out, $cache_list, $state)"
.el .SS "out_final($fh, \f(CW$out\fP, \f(CW$cache_list\fP, \f(CW$state\fP)"
.IX Subsection "out_final($fh, $out, $cache_list, $state)"
Internal function to actually output everything to the file handle given that
now we know the offset to the first sub object to be output and which sub objects
are to be output and what locations need to be updated, we can now
generate everything. \f(CW$cache_list\fR is an array of two element arrays. The first element
is a cache object, the second is an offset to be subtracted from each reference
to that object made in the cache.
.PP
If \f(CW$state\fR is 1, then the output is not sent to the filehandle and the return value
is the string to be output. If \f(CW$state\fR is absent or 0 then output is not limited
by storing in a string first and the return value is "";
.ie n .SS "$self\->read_context($lookup, $fh, $type, $fmt, $cover, $count, $loc)"
.el .SS "\f(CW$self\fP\->read_context($lookup, \f(CW$fh\fP, \f(CW$type\fP, \f(CW$fmt\fP, \f(CW$cover\fP, \f(CW$count\fP, \f(CW$loc\fP)"
.IX Subsection "$self->read_context($lookup, $fh, $type, $fmt, $cover, $count, $loc)"
Internal method to read context (simple and chaining context) lookup subtables for
the GSUB and GPOS table types. The assumed values for \f(CW$type\fR correspond to those
for GSUB, so GPOS should adjust the values upon calling.
.ie n .SS "$self\->out_context($lookup, $fh, $type, $fmt, $ctables, $out, $num)"
.el .SS "\f(CW$self\fP\->out_context($lookup, \f(CW$fh\fP, \f(CW$type\fP, \f(CW$fmt\fP, \f(CW$ctables\fP, \f(CW$out\fP, \f(CW$num\fP)"
.IX Subsection "$self->out_context($lookup, $fh, $type, $fmt, $ctables, $out, $num)"
Provides shared behaviour between GSUB and GPOS tables during output for context
(chained and simple) rules. In addition, support is provided here for type 4 GSUB
tables, which are not used in GPOS. The value for \f(CW$type\fR corresponds to the type
in a GSUB table so calling from GPOS should adjust the value accordingly.
.SH BUGS
.IX Header "BUGS"
.IP \(bu 4
No way to share cachable items (coverage tables, classes, anchors, device tables)
across different lookups. The items are always output after the lookup and
repeated if necessary. Within lookup sharing is possible.
.SH AUTHOR
.IX Header "AUTHOR"
Martin Hosken <http://scripts.sil.org/FontUtils>.
.SH LICENSING
.IX Header "LICENSING"
Copyright (c) 1998\-2016, SIL International (http://www.sil.org)
.PP
This module is released under the terms of the Artistic License 2.0. 
For details, see the full text of the license in the file LICENSE.
