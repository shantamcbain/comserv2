.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::CIDR 3"
.TH Net::CIDR 3 2025-08-12 "perl v5.40.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Net::CIDR \- Manipulate IPv4/IPv6 netblocks in CIDR notation
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::CIDR;
\&
\&    use Net::CIDR \*(Aq:all\*(Aq;
\&
\&    my $var;
\&
\&    if ($var = Net::CIDR::cidrvalidate($var))
\&    {
\&         // ... do something
\&    }
\&
\&    print join("\en",
\&          Net::CIDR::range2cidr("192.168.0.0\-192.168.255.255",
\&                                "10.0.0.0\-10.3.255.255"))
\&               . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # 192.168.0.0/16
\&    # 10.0.0.0/14
\&
\&    print join("\en",
\&          Net::CIDR::range2cidr(
\&                "dead:beef::\-dead:beef:ffff:ffff:ffff:ffff:ffff:ffff"))
\&               . "\en";
\&
\&    #
\&    # Output from above:
\&    #
\&    # dead:beef::/32
\&
\&    print join("\en",
\&             Net::CIDR::range2cidr("192.168.1.0\-192.168.2.255"))
\&                  . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # 192.168.1.0/24
\&    # 192.168.2.0/24
\&
\&    print join("\en", Net::CIDR::cidr2range("192.168.0.0/16")) . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # 192.168.0.0\-192.168.255.255
\&
\&    print join("\en", Net::CIDR::cidr2range("dead::beef::/46")) . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # dead:beef::\-dead:beef:3:ffff:ffff:ffff:ffff:ffff
\&
\&    @list=("192.168.0.0/24");
\&    @list=Net::CIDR::cidradd("192.168.1.0\-192.168.1.255", @list);
\&
\&    print join("\en", @list) . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # 192.168.0.0/23
\&
\&    print join("\en", Net::CIDR::cidr2octets("192.168.0.0/22")) . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # 192.168.0
\&    # 192.168.1
\&    # 192.168.2
\&    # 192.168.3
\&
\&    print join("\en", Net::CIDR::cidr2octets("dead::beef::/46")) . "\en";
\&    #
\&    # Output from above:
\&    #
\&    # dead:beef:0000
\&    # dead:beef:0001
\&    # dead:beef:0002
\&    # dead:beef:0003
\&
\&    @list=("192.168.0.0/24");
\&    print Net::CIDR::cidrlookup("192.168.0.12", @list);
\&    #
\&    # Output from above:
\&    #
\&    # 1
\&
\&    @list = Net::CIDR::addr2cidr("192.168.0.31");
\&    print join("\en", @list);
\&    #
\&    # Output from above:
\&    #
\&    # 192.168.0.31/32
\&    # 192.168.0.30/31
\&    # 192.168.0.28/30
\&    # 192.168.0.24/29
\&    # 192.168.0.16/28
\&    # 192.168.0.0/27
\&    # 192.168.0.0/26
\&    # 192.168.0.0/25
\&    # 192.168.0.0/24
\&    # 192.168.0.0/23
\&    # [and so on]
\&
\&    print Net::CIDR::addrandmask2cidr("195.149.50.61", "255.255.255.248")."\en";
\&    #
\&    # Output from above:
\&    #
\&    # 195.149.50.56/29
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
The Net::CIDR package contains functions that manipulate lists of IP
netblocks expressed in CIDR notation.
The Net::CIDR functions handle both IPv4 and IPv6 addresses.
.PP
The \fBcidrvalidate()\fR function, described below, checks that its argument
is a single, valid IP address or a CIDR. The remaining functions
expect that
their parameters consist of validated IPs or CIDRs. See \fBcidrvalidate()\fR
and BUGS, below, for more information.
.ie n .SS @cidr_list=Net::CIDR::range2cidr(@range_list);
.el .SS \f(CW@cidr_list\fP=Net::CIDR::range2cidr(@range_list);
.IX Subsection "@cidr_list=Net::CIDR::range2cidr(@range_list);"
Each element in the \f(CW@range_list\fR is a string "start-finish", where
"start" is the first IP address and "finish" is the last IP address.
\&\fBrange2cidr()\fR converts each range into an equivalent CIDR netblock.
It returns a list of netblocks except in the case where it is given
only one parameter and is called in scalar context.
.PP
For example:
.PP
.Vb 1
\&    @a=Net::CIDR::range2cidr("192.168.0.0\-192.168.255.255");
.Ve
.PP
The result is a one-element array, with \f(CW$a\fR[0] being "192.168.0.0/16".
\&\fBrange2cidr()\fR processes each "start-finish" element in \f(CW@range_list\fR separately.
But if invoked like so:
.PP
.Vb 1
\&    $a=Net::CIDR::range2cidr("192.168.0.0\-192.168.255.255");
.Ve
.PP
The result is a scalar "192.168.0.0/16".
.PP
Where each element cannot be expressed as a single CIDR netblock
\&\fBrange2cidr()\fR will generate as many CIDR netblocks as are necessary to cover
the full range of IP addresses.  Example:
.PP
.Vb 1
\&    @a=Net::CIDR::range2cidr("192.168.1.0\-192.168.2.255");
.Ve
.PP
The result is a two element array: ("192.168.1.0/24","192.168.2.0/24");
.PP
.Vb 2
\&    @a=Net::CIDR::range2cidr(
\&                   "d08c:43::\-d08c:43:ffff:ffff:ffff:ffff:ffff:ffff");
.Ve
.PP
The result is an one element array: ("d08c:43::/32") that reflects this
IPv6 netblock in CIDR notation.
.PP
\&\fBrange2cidr()\fR does not merge adjacent or overlapping netblocks in
\&\f(CW@range_list\fR.
.ie n .SS @range_list=Net::CIDR::cidr2range(@cidr_list);
.el .SS \f(CW@range_list\fP=Net::CIDR::cidr2range(@cidr_list);
.IX Subsection "@range_list=Net::CIDR::cidr2range(@cidr_list);"
The \fBcidr2range()\fR functions converts a netblock list in CIDR notation
to a list of "start-finish" IP address ranges:
.PP
.Vb 1
\&    @a=Net::CIDR::cidr2range("10.0.0.0/14", "192.168.0.0/24");
.Ve
.PP
The result is a two-element array:
("10.0.0.0\-10.3.255.255", "192.168.0.0\-192.168.0.255").
.PP
.Vb 1
\&    @a=Net::CIDR::cidr2range("d08c:43::/32");
.Ve
.PP
The result is a one-element array:
("d08c:43::\-d08c:43:ffff:ffff:ffff:ffff:ffff:ffff").
.PP
\&\fBcidr2range()\fR does not merge adjacent or overlapping netblocks in
\&\f(CW@cidr_list\fR.
.ie n .SS "@netblock_list = Net::CIDR::addr2cidr($address);"
.el .SS "\f(CW@netblock_list\fP = Net::CIDR::addr2cidr($address);"
.IX Subsection "@netblock_list = Net::CIDR::addr2cidr($address);"
The addr2cidr function takes an IP address and returns a list of all
the CIDR netblocks it might belong to:
.PP
.Vb 1
\&    @a=Net::CIDR::addr2cidr(\*(Aq192.168.0.31\*(Aq);
.Ve
.PP
The result is a thirtythree-element array:
('192.168.0.31/32', '192.168.0.30/31', '192.168.0.28/30', '192.168.0.24/29',
 [and so on])
consisting of all the possible subnets containing this address from
0.0.0.0/0 to address/32.
.PP
Any addresses supplied to addr2cidr after the first will be ignored.
It works similarly for IPv6 addresses, returning a list of one hundred
and twenty nine elements.
.ie n .SS "$cidr=Net::CIDR::addrandmask2cidr($address, $netmask);"
.el .SS "\f(CW$cidr\fP=Net::CIDR::addrandmask2cidr($address, \f(CW$netmask\fP);"
.IX Subsection "$cidr=Net::CIDR::addrandmask2cidr($address, $netmask);"
The addrandmask2cidr function takes an IP address and a netmask, and
returns the CIDR range whose size fits the netmask and which contains
the address.  It is an error to supply one parameter in IPv4\-ish
format and the other in IPv6\-ish format, and it is an error to supply
a netmask which does not consist solely of 1 bits followed by 0 bits.
For example, '255.255.248.192' is an invalid netmask, as is
\&'255.255.255.32' because both contain 0 bits in between 1 bits.
.PP
Technically speaking both of those *are* valid netmasks, but a) you'd
have to be insane to use them, and b) there's no corresponding CIDR
range.
.ie n .SS @octet_list=Net::CIDR::cidr2octets(@cidr_list);
.el .SS \f(CW@octet_list\fP=Net::CIDR::cidr2octets(@cidr_list);
.IX Subsection "@octet_list=Net::CIDR::cidr2octets(@cidr_list);"
\&\fBcidr2octets()\fR takes \f(CW@cidr_list\fR and returns a list of leading octets
representing those netblocks.  Example:
.PP
.Vb 1
\&    @octet_list=Net::CIDR::cidr2octets("10.0.0.0/14", "192.168.0.0/24");
.Ve
.PP
The result is the following five-element array:
("10.0", "10.1", "10.2", "10.3", "192.168.0").
.PP
For IPv6 addresses, the hexadecimal words in the resulting list are
zero-padded:
.PP
.Vb 1
\&    @octet_list=Net::CIDR::cidr2octets("::dead:beef:0:0/110");
.Ve
.PP
The result is a four-element array:
("0000:0000:0000:0000:dead:beef:0000",
"0000:0000:0000:0000:dead:beef:0001",
"0000:0000:0000:0000:dead:beef:0002",
"0000:0000:0000:0000:dead:beef:0003").
Prefixes of IPv6 CIDR blocks should be even multiples of 16 bits, otherwise
they can potentially expand out to a 32,768\-element array, each!
.ie n .SS "@cidr_list=Net::CIDR::cidradd($block, @cidr_list);"
.el .SS "\f(CW@cidr_list\fP=Net::CIDR::cidradd($block, \f(CW@cidr_list\fP);"
.IX Subsection "@cidr_list=Net::CIDR::cidradd($block, @cidr_list);"
The \fBcidradd()\fR functions allows a CIDR list to be built one CIDR netblock
at a time, merging adjacent and overlapping ranges.
\&\f(CW$block\fR is a single netblock, expressed as either "start-finish", or
"address/prefix".
Example:
.PP
.Vb 3
\&    @cidr_list=Net::CIDR::range2cidr("192.168.0.0\-192.168.0.255");
\&    @cidr_list=Net::CIDR::cidradd("10.0.0.0/8", @cidr_list);
\&    @cidr_list=Net::CIDR::cidradd("192.168.1.0\-192.168.1.255", @cidr_list);
.Ve
.PP
The result is a two-element array: ("10.0.0.0/8", "192.168.0.0/23").
IPv6 addresses are handled in an analogous fashion.
.ie n .SS "$found=Net::CIDR::cidrlookup($ip, @cidr_list);"
.el .SS "\f(CW$found\fP=Net::CIDR::cidrlookup($ip, \f(CW@cidr_list\fP);"
.IX Subsection "$found=Net::CIDR::cidrlookup($ip, @cidr_list);"
Search for \f(CW$ip\fR in \f(CW@cidr_list\fR.  \f(CW$ip\fR can be a single IP address, or a
netblock in CIDR or start-finish notation.
\&\fBlookup()\fR returns 1 if \f(CW$ip\fR overlaps any netblock in \f(CW@cidr_list\fR, 0 if not.
.ie n .SS $ip=Net::CIDR::cidrvalidate($ip);
.el .SS \f(CW$ip\fP=Net::CIDR::cidrvalidate($ip);
.IX Subsection "$ip=Net::CIDR::cidrvalidate($ip);"
Validate whether \f(CW$ip\fR is a valid IPv4 or IPv6 address, or a CIDR.
Returns its validated argument or undef.
Spaces are removed, and IPv6 hexadecimal address are converted to lowercase.
.PP
\&\f(CW$ip\fR with less than four octets gets filled out with additional octets, and
the modified value gets returned. This turns "192.168/16" into a proper
"192.168.0.0/16".
.PP
If \f(CW$ip\fR contains a "/", it must be a valid CIDR, otherwise it must be a valid
IPv4 or an IPv6 address.
.PP
A technically invalid CIDR, such as "192.168.0.1/24" fails validation, returning
undef.
.SH BUGS
.IX Header "BUGS"
Garbage in, garbage out.
Always use \fBcidrvalidate()\fR before doing anything with untrusted input.
Otherwise,
"slightly" invalid input will work (extraneous whitespace
is generally OK),
but the functions will croak if you're totally off the wall.
.SH AUTHOR
.IX Header "AUTHOR"
Sam Varshavchik <sam@email\-scan.com>
.PP
With some contributions from David Cantrell <david@cantrell.org.uk>
and brian d foy <briandfoy@pobox.com>.
