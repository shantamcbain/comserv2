[% PageVersion = 'Comserv/root/Documentation/developer/hybrid_database_architecture.tt,v 0.01 2025/01/28 shanta Exp shanta ' %]
[% IF c.session.debug_mode == 1 %]
    [% PageVersion %]
[% END %]

[% META title = 'Hybrid Database Architecture - Multi-Device Offline Sync System' %]

<!-- Documentation page for hybrid_database_architecture -->
<div class="documentation-content">

<!-- Documentation CSS is now included in the theme system -->

<div class="markdown-content">

# HYBRID DATABASE ARCHITECTURE
## Multi-Device Offline Synchronization System

### 🎯 STRATEGIC OVERVIEW

The Comserv hybrid database system provides intelligent database backend selection with multi-device offline synchronization capabilities. The system is designed to support various device types with different storage capacities and connectivity requirements.

### 🏗️ ARCHITECTURE COMPONENTS

#### 1. DBEncy Model Enhancement (Central Router)
**File**: `Comserv/lib/Comserv/Model/DBEncy.pm`

**Primary Functions**:
- **Backend Selection Logic**: Chooses appropriate database backend based on user preference and device capabilities
- **Connection Management**: Maintains MySQL primary connection while providing SQLite secondary connections
- **Graceful Fallback**: Automatically falls back to MySQL if SQLite unavailable
- **Session Integration**: Respects user backend preferences stored in session

**Key Methods**:
```perl
# Get user's backend preference from HybridDB
my $backend_preference = $schema->get_hybrid_backend_preference($c);

# Create SQLite schema connection when needed
my $sqlite_schema = $schema->get_sqlite_schema($c);
```

#### 2. HybridDB Model (Backend Manager)
**File**: `Comserv/lib/Comserv/Model/HybridDB.pm`

**Primary Functions**:
- **Backend Detection**: Auto-detects available database backends (MySQL server availability)
- **Session Persistence**: Stores user backend selection in session across requests
- **Connection Testing**: Validates individual backend connections
- **Configuration Management**: Manages multiple database configurations

**Key Methods**:
```perl
# Switch backend and store in session
$hybrid_db->switch_backend($c, $backend_type);

# Get current backend with session awareness
my $backend = $hybrid_db->get_backend_type($c);

# Get SQLite connection information
my $sqlite_conn = $hybrid_db->get_sqlite_connection_info($c);
```

#### 3. Controller Integration Pattern
**Example**: `Comserv/lib/Comserv/Controller/Todo.pm`

**Integration Pattern**:
```perl
# Get DBEncy model
my $schema = $c->model('DBEncy');

# Check user's backend preference
my $backend_preference = $schema->get_hybrid_backend_preference($c);
my $actual_backend = 'mysql';  # Default

if ($backend_preference eq 'sqlite') {
    my $sqlite_schema = $schema->get_sqlite_schema($c);
    if ($sqlite_schema) {
        $schema = $sqlite_schema;
        $actual_backend = 'sqlite';
        # Log SQLite usage
    } else {
        # Log fallback to MySQL
    }
}

# Store backend info for template display
$c->stash(
    current_backend => $actual_backend,
    backend_preference => $backend_preference,
);

# Use schema normally - transparent to existing code
my $rs = $schema->resultset('Todo');
```

### 🔧 CONFIGURATION STRATEGY

#### Current Configuration (db_config.json)
```json
{
  "shanta_ency": {
    "host": "production.server.com",
    "port": "3306",
    "database": "comserv_db",
    "username": "comserv_user",
    "password": "secure_password"
  }
}
```

#### Planned Multi-Backend Configuration
```json
{
  "backends": {
    "production_mysql": {
      "type": "mysql",
      "host": "production.server.com",
      "port": "3306",
      "database": "comserv_db",
      "username": "comserv_user",
      "password": "secure_password",
      "priority": 1
    },
    "local_mysql": {
      "type": "mysql",
      "host": "localhost",
      "port": "3306",
      "database": "comserv_db",
      "username": "comserv_user",
      "password": "secure_password",
      "priority": 2
    },
    "backup_mysql": {
      "type": "mysql",
      "host": "backup.server.com",
      "port": "3306",
      "database": "comserv_db",
      "username": "comserv_user",
      "password": "secure_password",
      "priority": 3
    },
    "sqlite_local": {
      "type": "sqlite",
      "path": "/path/to/comserv.db",
      "priority": 4
    }
  }
}
```

### 📱 MULTI-DEVICE STRATEGY

#### Device Categories & Strategies

**1. Workstation (Current Development)**
- **Primary**: MySQL connection (production credentials)
- **Secondary**: SQLite for offline testing
- **Storage**: Unlimited - full data synchronization
- **Use Case**: Development and full-featured operation

**2. Laptop (Travel/Remote Work)**
- **Primary**: Local MySQL server
- **Secondary**: SQLite with selective sync
- **Storage**: Large - most data synchronized
- **Use Case**: Remote work with periodic connectivity

**3. Mobile Phone**
- **Primary**: SQLite only
- **Storage**: Limited - critical data only
- **Sync Strategy**: User-specific data + recently accessed resources
- **Use Case**: Field work, quick access, emergency operations

**4. Tablet (iPad Simulation)**
- **Primary**: SQLite only
- **Storage**: Very Limited - minimal critical data
- **Sync Strategy**: Essential user data + current project data
- **Use Case**: Presentations, basic data entry, offline reference

### 🔄 SYNCHRONIZATION STRATEGY

#### User-Centric Data Sync
When user 'shanta' logs in, sync their specific data subset:

**Critical Data (Always Synced)**:
- User authentication data
- Site configuration
- User preferences and settings
- Active project assignments

**Access-Based Sync**:
- Recently accessed herbs/resources
- Current project data
- Recent todo items
- Frequently used documentation

**Storage-Aware Sync**:
- **High Storage Devices**: Full data synchronization
- **Medium Storage Devices**: Recent + frequently accessed data
- **Low Storage Devices**: Critical data + current session data

#### Sync Triggers
1. **Login-Based**: Initial sync when user logs in
2. **Access-Based**: Sync resources when user accesses them
3. **Time-Based**: Periodic sync for active data
4. **Manual**: User-initiated sync for specific data sets

### 🛡️ SECURITY & MAINTENANCE

#### Security Considerations
- **Credential Reuse**: Same MySQL credentials for production/local (secure)
- **Access Control**: Backend switching restricted to admin/developer roles
- **Data Encryption**: SQLite databases encrypted on mobile devices
- **Audit Trail**: All backend operations and sync activities logged

#### Maintenance Features
- **Connection Health Monitoring**: Continuous backend availability checking
- **Automatic Failover**: Graceful fallback between backends
- **Data Integrity Checks**: Validation of synchronized data
- **Rollback Capability**: All sync operations reversible

### 🧪 TESTING STRATEGY

#### Current Testing (Workstation)
1. **Backend Switching**: Use `/admin/database_mode` to switch between MySQL and SQLite
2. **Data Isolation**: Verify SQLite and MySQL data don't interfere
3. **Session Persistence**: Confirm backend choice survives page refreshes
4. **Controller Integration**: Check Todo controller logs for backend usage
5. **Fallback Testing**: Ensure graceful fallback when SQLite unavailable

#### Future Testing (Multi-Device)
1. **Cross-Device Sync**: Verify data synchronization between devices
2. **Conflict Resolution**: Test handling of simultaneous data modifications
3. **Storage Limits**: Test behavior when device storage is full
4. **Network Interruption**: Test sync behavior during connectivity issues
5. **Performance Testing**: Measure sync performance with large datasets

### 📊 IMPLEMENTATION STATUS

#### Phase 1: Foundation ✅ COMPLETED
- ✅ HybridDB model with backend detection
- ✅ DatabaseMode controller and interface
- ✅ Session-based backend persistence
- ✅ DBEncy hybrid integration
- ✅ Todo controller demonstration

#### Phase 2: Multi-Backend Config 🔄 NEXT
- 🔄 Extend db_config.json for multiple MySQL instances
- 🔄 URL override logic for localhost testing
- 🔄 Enhanced backend selection interface
- 🔄 Connection validation for all backends

#### Phase 3: Intelligent Sync Engine 📋 PLANNED
- 📋 User-specific data identification
- 📋 Sync triggers and scheduling
- 📋 Storage-aware sync strategies
- 📋 Conflict resolution mechanisms

#### Phase 4: Device Optimization 📋 PLANNED
- 📋 Mobile/tablet SQLite-only strategy
- 📋 Storage monitoring and management
- 📋 Performance optimization for limited devices
- 📋 Offline-first user experience

### 🎯 SUCCESS METRICS

#### Technical Metrics
- **Backend Switch Time**: < 2 seconds for database backend switching
- **Sync Performance**: < 30 seconds for critical data sync
- **Storage Efficiency**: < 50MB SQLite database for mobile devices
- **Availability**: 99.9% uptime with automatic failover

#### User Experience Metrics
- **Seamless Operation**: Users unaware of backend switching
- **Offline Capability**: Full functionality for critical operations
- **Data Consistency**: Zero data loss during synchronization
- **Performance**: No noticeable performance degradation

### 🔮 FUTURE ENHANCEMENTS

#### Advanced Features
- **Predictive Sync**: AI-based prediction of data access patterns
- **Compression**: Advanced data compression for mobile devices
- **Incremental Sync**: Delta synchronization for large datasets
- **Real-time Sync**: WebSocket-based real-time data synchronization

#### Integration Opportunities
- **Cloud Storage**: Integration with cloud storage providers
- **Mobile Apps**: Native mobile app with embedded SQLite
- **PWA Enhancement**: Progressive Web App with offline capabilities
- **API Gateway**: RESTful API for third-party integrations

---

**Document Version**: 0.01  
**Last Updated**: 2025-01-28  
**Author**: Shanta  
**Status**: Active Development

</div>
</div>