Index: Comserv/lib/Comserv/Controller/Root.pm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Comserv::Controller::Root;\nuse Moose;\nuse namespace::autoclean;\nuse Template;\nuse Data::Dumper;\nuse DateTime;\nuse JSON;\nuse Comserv::Util::Logging;\n\n# Configure static file serving\n__PACKAGE__->config(\n    'Plugin::Static::Simple' => {\n        dirs => ['static'],\n        include_path => [qw( root )],\n    });\n\nhas 'logging' => (\n    is => 'ro',\n    default => sub { Comserv::Util::Logging->instance }\n);\n\n# Add user_exists method\nsub user_exists {\n    my ($self, $c) = @_;\n    return ($c->session->{username} && $c->session->{user_id}) ? 1 : 0;\n}\n\n# Flag to track if application start has been recorded\nhas '_application_start_tracked' => (\n    is => 'rw',\n    isa => 'Bool',\n    default => 0\n);\n\n# Flag to track if theme CSS files have been generated\nhas '_theme_css_generated' => (\n    is => 'rw',\n    isa => 'Bool',\n    default => 0\n);\n\nBEGIN { extends 'Catalyst::Controller' }\n\n__PACKAGE__->config(namespace => '');\n\nsub index :Path('/') :Args(0) {\n    my ($self, $c) = @_;\n\n    # Log entry into index action\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Starting index action\");\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Starting index action. User exists: \" . ($self->user_exists($c) ? 'Yes' : 'No'));\n    $c->stash->{forwarder} = '/'; # Set a default forward path\n\n    # Only process this action if we're actually in the Root controller\n    # This prevents the Root index action from capturing requests meant for other controllers\n    if (ref($c->controller) ne 'Comserv::Controller::Root') {\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index',\n            \"Not in Root controller, skipping index action. Controller: \" . ref($c->controller));\n        return;\n    }\n\n    # Get SiteName from session\n    my $SiteName = $c->session->{SiteName};\n\n    # Get ControllerName from session\n    my $ControllerName = $c->session->{ControllerName} || undef; # Default to undef if not set\n\n    # Log the values\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Site setup called\");\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Fetched SiteName from session: \" . ($SiteName // 'undefined'));\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Fetched ControllerName from session: \" . ($ControllerName // 'undefined'));\n\n    if ($ControllerName && $ControllerName ne 'Root') {\n        # Check if the controller exists before attempting to detach\n        my $controller_exists = 0;\n        eval {\n            # Try to get the controller object\n            my $controller = $c->controller($ControllerName);\n            $controller_exists = 1 if $controller;\n        };\n\n        if ($controller_exists) {\n            # Forward to the controller's index action\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Forwarding to $ControllerName controller's index action\");\n            $c->detach($ControllerName, 'index');\n        } else {\n            # Log the error and fall back to Root's index template\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'index',\n                \"Controller '$ControllerName' not found or not loaded. Falling back to Root's index template.\");\n\n            # Set a flash message for debugging\n            $c->flash->{error_msg} = \"Controller '$ControllerName' not found. Please try again or contact the administrator.\";\n\n            # Default to Root's index template\n            $c->stash(template => 'index.tt');\n            $c->forward($c->view('TT'));\n        }\n    } else {\n        # Default to Root's index template\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Defaulting to Root's index template\");\n        $c->stash(template => 'index.tt');\n        $c->forward($c->view('TT'));\n    }\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Completed index action\");\n    return 1; # Allow the request to proceed\n}\n\n\nsub set_theme {\n    my ($self, $c) = @_;\n\n    # Get the site name\n    my $site_name = $c->stash->{SiteName} || $c->session->{SiteName} || 'default';\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'set_theme', \"Setting theme for site: $site_name\");\n\n    # Get all available themes\n    my $all_themes = $c->model('ThemeConfig')->get_all_themes($c);\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'set_theme',\n        \"Available themes: \" . join(\", \", sort keys %$all_themes));\n\n    # Get the theme for this site from our theme config\n    my $theme_name = $c->model('ThemeConfig')->get_site_theme($c, $site_name);\n\n    # Make sure the theme exists\n    if (!exists $all_themes->{$theme_name}) {\n        $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'set_theme',\n            \"Theme '$theme_name' not found in available themes, defaulting to 'default'\");\n        $theme_name = 'default';\n    }\n\n    # Add the theme name to the stash\n    $c->stash->{theme_name} = $theme_name;\n\n    # Add all available themes to the stash\n    $c->stash->{available_themes} = [sort keys %$all_themes];\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'set_theme',\n        \"Set theme for site $site_name to $theme_name\");\n}\n\nsub fetch_and_set {\n    my ($self, $c, $param) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Starting fetch_and_set action\");\n    my $value = $c->req->query_parameters->{$param};\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Checking query parameter '$param'\");\n\n    if (defined $value) {\n        $c->stash->{SiteName} = $value;\n        $c->session->{SiteName} = $value;\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Query parameter '$param' found: $value\");\n    } elsif (defined $c->session->{SiteName}) {\n        $c->stash->{SiteName} = $c->session->{SiteName};\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"SiteName found in session: \" . $c->session->{SiteName});\n    } else {\n        my $domain = $c->req->uri->host;\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Extracted domain: $domain\");\n\n        my $site_domain = $c->model('Site')->get_site_domain($c, $domain);\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Site domain retrieved: \" . Dumper($site_domain));\n\n        if ($site_domain) {\n            my $site_id = $site_domain->site_id;\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Site ID: $site_id\");\n\n            my $site = $c->model('Site')->get_site_details($c, $site_id);\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"Site details retrieved: \" . Dumper($site));\n\n            if ($site) {\n                $value = $site->name;\n                $c->stash->{SiteName} = $value;\n                $c->session->{SiteName} = $value;\n                $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"SiteName set to: $value\");\n\n                # Set ControllerName based on the site's home_view\n                my $home_view = $site->home_view || 'Root';  # Ensure this is domain-specific\n\n                # Verify the controller exists before setting it\n                my $controller_exists = 0;\n                eval {\n                    my $controller = $c->controller($home_view);\n                    $controller_exists = 1 if $controller;\n                };\n\n                if ($controller_exists) {\n                    $c->stash->{ControllerName} = $home_view;\n                    $c->session->{ControllerName} = $home_view;\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"ControllerName set to: $home_view\");\n                } else {\n                    # If controller doesn't exist, fall back to Root\n                    $self->logging->log_with_details($c, 'warning', __FILE__, __LINE__, 'fetch_and_set',\n                        \"Controller '$home_view' not found or not loaded. Falling back to 'Root'.\");\n                    $c->stash->{ControllerName} = 'Root';\n                    $c->session->{ControllerName} = 'Root';\n                }\n            }\n        } else {\n            # Handle case when site_domain is null\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'fetch_and_set',\n                \"Could not retrieve site domain for $domain. Using default site.\");\n\n            # Set a default site name\n            $value = 'default';\n            $c->session->{SiteName} = $value;\n            $c->stash->{SiteName} = $value;\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set',\n                \"SiteName set to default: $value\");\n            $c->session->{ControllerName} = 'Root';\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'fetch_and_set', \"No site domain found, defaulting SiteName and ControllerName to 'none' and 'Root'\");\n        }\n    }\n\n    return $value;\n}\n\nsub track_application_start {\n    my ($self, $c) = @_;\n\n    # Only track once per application start\n    return if $self->_application_start_tracked;\n    $self->_application_start_tracked(1);\n\n    # Get the current date\n    my $current_date = DateTime->now->ymd; # Format: YYYY-MM-DD\n\n    # Path to the JSON file\n    my $json_file = $c->path_to('root', 'Documentation', 'completed_items.json');\n\n    # Check if the file exists\n    if (-e $json_file) {\n        # Read the JSON file\n        open my $fh, '<:encoding(UTF-8)', $json_file or do {\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"Cannot open $json_file for reading: $!\");\n            return;\n        };\n        my $json_content = do { local $/; <$fh> };\n        close $fh;\n\n        # Parse the JSON content\n        my $data;\n        eval {\n            $data = decode_json($json_content);\n        };\n        if ($@) {\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"Error parsing JSON: $@\");\n            return;\n        }\n\n        # Check if we already have any application start entry\n        my $entry_exists = 0;\n        my $latest_start_date = '';\n\n        foreach my $item (@{$data->{completed_items}}) {\n            if ($item->{item} =~ /^Application started/) {\n                # Keep track of the latest application start date\n                if ($item->{date_created} gt $latest_start_date) {\n                    $latest_start_date = $item->{date_created};\n                }\n\n                # If we already have an entry for today, mark it as existing\n                if ($item->{date_created} eq $current_date) {\n                    $entry_exists = 1;\n                }\n            }\n        }\n\n        # If we have a previous application start entry but not for today,\n        # update that entry instead of creating a new one\n        if (!$entry_exists && $latest_start_date ne '') {\n            for my $i (0 .. $#{$data->{completed_items}}) {\n                my $item = $data->{completed_items}[$i];\n                if ($item->{item} =~ /^Application started/ && $item->{date_created} eq $latest_start_date) {\n                    # Update the existing entry with today's date\n                    $data->{completed_items}[$i]->{item} = \"Application started on $current_date\";\n                    $data->{completed_items}[$i]->{date_created} = $current_date;\n                    $data->{completed_items}[$i]->{date_completed} = $current_date;\n                    $entry_exists = 1; # Mark as existing so we don't create a new one\n\n                    # Write the updated data back to the file\n                    open my $fh, '>:encoding(UTF-8)', $json_file or do {\n                        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"Cannot open $json_file for writing: $!\");\n                        return;\n                    };\n\n                    eval {\n                        print $fh encode_json($data);\n                    };\n                    if ($@) {\n                        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"Error encoding JSON: $@\");\n                        close $fh;\n                        return;\n                    }\n\n                    close $fh;\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'track_application_start', \"Updated application start entry to $current_date\");\n                    last;\n                }\n            }\n        }\n\n        # If no entry exists for today, add one\n        if (!$entry_exists) {\n            # Create a new entry\n            my $new_entry = {\n                item => \"Application started on $current_date\",\n                status => \"completed\",\n                date_created => $current_date,\n                date_completed => $current_date,\n                commit => \"system\" # Indicate this is a system-generated entry\n            };\n\n            # Add the new entry to the data\n            push @{$data->{completed_items}}, $new_entry;\n\n            # Write the updated data back to the file\n            open my $fh, '>:encoding(UTF-8)', $json_file or do {\n                $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"Cannot open $json_file for writing: $!\");\n                return;\n            };\n\n            eval {\n                print $fh encode_json($data);\n            };\n            if ($@) {\n                $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"Error encoding JSON: $@\");\n                close $fh;\n                return;\n            }\n\n            close $fh;\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'track_application_start', \"Added application start entry for $current_date\");\n        } else {\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'track_application_start', \"Application start entry for $current_date already exists\");\n        }\n    } else {\n        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'track_application_start', \"JSON file $json_file does not exist\");\n    }\n}\n\nsub auto :Private {\n    my ($self, $c) = @_;\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Starting auto action\");\n\n    # Log the controller and action for debugging\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto',\n        \"Controller: \" . ref($c->controller) . \", Action: \" . $c->action->name);\n\n    # Skip auto processing for User controller\n    if (ref($c->controller) eq 'Comserv::Controller::User') {\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto',\n            \"Skipping auto processing for User controller\");\n        return 1;\n    }\n\n    # Check if setup is needed\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Checking if setup is needed\");\n\n    # Check if setup is needed\n    if ($c->req->param('setup')) {\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Setup mode detected\");\n        $c->response->redirect($c->uri_for('/setup'));\n        return 0;\n    }\n\n\n\n    # Track application start\n    $c->stash->{forwarder} = $c->req->path; # Store current path as potential redirect target\n    $self->track_application_start($c);\n\n    # Log the request path\n    my $path = $c->req->path;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Request path: '$path'\");\n\n    # Generate theme CSS files if they don't exist\n    # We only need to do this once per application start\n    if (!$self->_theme_css_generated) {\n        $c->model('ThemeConfig')->generate_all_theme_css($c);\n        $self->_theme_css_generated(1);\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Generated all theme CSS files\");\n    }\n\n    # Perform general setup tasks\n    $self->setup_debug_mode($c);\n    $self->setup_site($c);\n    $self->set_theme($c);\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Completed general setup tasks\");\n\n    # Call the index action only for the root path\n    if ($path eq '/' || $path eq '') {\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Calling index action for root path\");\n\n        # Check if we have a ControllerName in the session that might cause issues\n        my $ControllerName = $c->session->{ControllerName} || '';\n        if ($ControllerName && $ControllerName ne 'Root') {\n            # Verify the controller exists before proceeding\n            my $controller_exists = 0;\n            eval {\n                my $controller = $c->controller($ControllerName);\n                $controller_exists = 1 if $controller;\n            };\n\n            if (!$controller_exists) {\n                $self->logging->log_with_details($c, 'warning', __FILE__, __LINE__, 'auto',\n                    \"Controller '$ControllerName' not found or not loaded. Setting ControllerName to 'Root'.\");\n                $c->session->{ControllerName} = 'Root';\n                $c->stash->{ControllerName} = 'Root';\n            }\n        }\n\n        $self->index($c);\n    }\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"Completed auto action\");\n    return 1; # Allow the request to proceed\n}\n\nsub setup_debug_mode {\n    my ($self, $c) = @_;\n\n    if (defined $c->req->params->{debug}) {\n        $c->session->{debug_mode} = $c->session->{debug_mode} ? 0 : 1;\n    }\n    $c->stash->{debug_mode} = $c->session->{debug_mode};\n}\n\nsub send_email {\n    my ($self, $c, $params) = @_;\n\n    # Log the email attempt\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'send_email',\n        \"Attempting to send email to: \" . $params->{to} . \" with subject: \" . $params->{subject});\n\n    # Use Email::Simple and Email::Sender::Simple for basic email functionality\n    eval {\n        require Email::Simple;\n        require Email::Sender::Simple;\n        Email::Sender::Simple->import(qw(sendmail));\n\n        my $email = Email::Simple->create(\n            header => [\n                To      => $params->{to},\n                From    => $params->{from} || 'noreply@computersystemconsulting.ca',\n                Subject => $params->{subject},\n            ],\n            body => $params->{body},\n        );\n\n        sendmail($email);\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'send_email',\n            \"Email sent successfully to: \" . $params->{to});\n        return 1;\n    };\n\n    if ($@) {\n        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'send_email',\n            \"Failed to send email: $@\");\n        return 0;\n    }\n}\n\nsub setup_site {\n    my ($self, $c) = @_;\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', \"Starting setup_site action\");\n\n    # Initialize debug_errors array if it doesn't exist\n    $c->stash->{debug_errors} //= [];\n\n    my $SiteName = $c->session->{SiteName};\n\n    # Get the current domain\n    my $domain = $c->req->uri->host;\n    $domain =~ s/:.*//;  # Remove port if present\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', \"Extracted domain: $domain\");\n\n        # Extract domain from request base\n        $domain = $c->req->base->host;\n        $domain =~ s/:.*//;\n\n        # Store the domain in the session\n        $c->session->{Domain} = $domain;\n        $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', \"Session Domain: $domain\");\n\n        # Try to get site domain with error handling\n    # Store domain in session for debugging\n    $c->session->{Domain} = $domain;\n\n    if (!defined $SiteName || $SiteName eq 'none' || $SiteName eq 'root') {\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', \"SiteName is either undefined, 'none', or 'root'. Proceeding with domain extraction and site domain retrieval\");\n\n        # Get the domain from the sitedomain table\n        my $site_domain = $c->model('Site')->get_site_domain($c, $domain);\n\n        # Log the result\n        $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto',\n            \"Site Domain: \" . ($site_domain ? $site_domain->site_id : 'undefined'));\n\n        if ($site_domain) {\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', \"Found site domain for $domain\");\n\n            my $site_id = $site_domain->site_id;\n            my $site = $c->model('Site')->get_site_details($site_id, $c);\n            $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', \"Site ID: $site_id\");\n\n            if ($site) {\n                $SiteName = $site->name;\n                $c->stash->{SiteName} = $SiteName;\n                $c->session->{SiteName} = $SiteName;\n\n                # Set ControllerName based on the site's home_view\n                my $home_view = $site->home_view || $site->name || 'Root';  # Use home_view if available\n\n                # Verify the controller exists before setting it\n                my $controller_exists = 0;\n                eval {\n                    my $controller = $c->controller($home_view);\n                    $controller_exists = 1 if $controller;\n                };\n\n                if ($controller_exists) {\n                    $c->stash->{ControllerName} = $home_view;\n                    $c->session->{ControllerName} = $home_view;\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', \"ControllerName set to: $home_view\");\n                } else {\n                    # If controller doesn't exist, fall back to Root\n                    $self->logging->log_with_details($c, 'warning', __FILE__, __LINE__, 'setup_site',\n                        \"Controller '$home_view' not found or not loaded. Falling back to 'Root'.\");\n                    $c->stash->{ControllerName} = 'Root';\n                    $c->session->{ControllerName} = 'Root';\n                }\n            }\n        } elsif ($c->stash->{domain_error}) {\n            # We have a specific domain error from the get_site_domain method\n            my $domain_error = $c->stash->{domain_error};\n            my $error_type = $domain_error->{type};\n            my $error_msg = $domain_error->{message};\n            my $technical_details = $domain_error->{technical_details};\n            my $action_required = $domain_error->{action_required} || \"Please contact the system administrator.\";\n\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'setup_site',\n                \"DOMAIN ERROR ($error_type): $error_msg - $technical_details\");\n\n            # Set default site for error handling\n            $SiteName = 'CSC'; # Default to CSC\n            $c->stash->{SiteName} = $SiteName;\n            $c->session->{SiteName} = $SiteName;\n\n            # Force Root controller to show error page\n            $c->stash->{ControllerName} = 'Root';\n            $c->session->{ControllerName} = 'Root';\n\n            # Set up site basics to get admin email\n            $self->site_setup($c, $SiteName);\n\n            # Set flash error message to ensure it's displayed\n            $c->flash->{error_msg} = \"Domain Error: $error_msg\";\n\n            # Send email notification to admin\n            if (my $mail_to_admin = $c->stash->{mail_to_admin}) {\n                my $email_params = {\n                    to      => $mail_to_admin,\n                    from    => $mail_to_admin,\n                    subject => \"URGENT: Comserv Domain Configuration Required\",\n                    body    => \"Domain Error: $error_msg\\n\\n\" .\n                               \"Domain: $domain\\n\" .\n                               \"Error Type: $error_type\\n\\n\" .\n                               \"ACTION REQUIRED: $action_required\\n\\n\" .\n                               \"Technical Details: $technical_details\\n\\n\" .\n                               \"Time: \" . scalar(localtime) . \"\\n\" .\n                               \"IP Address: \" . ($c->req->address || 'unknown') . \"\\n\" .\n                               \"User Agent: \" . ($c->req->user_agent || 'unknown') . \"\\n\\n\" .\n                               \"This is a configuration error that needs to be fixed for proper site operation.\"\n                };\n\n                if ($self->send_email($c, $email_params)) {\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site',\n                        \"Sent admin notification email about domain error: $error_type for $domain\");\n                } else {\n                    $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'setup_site',\n                        \"Failed to send admin email notification about domain error: $error_type for $domain\");\n                }\n            }\n\n            # Display error page with clear message about the domain configuration issue\n            $c->stash->{template} = 'error.tt';\n            $c->stash->{error_title} = \"Domain Configuration Error\";\n            $c->stash->{error_msg} = $error_msg;\n            $c->stash->{admin_msg} = \"The administrator has been notified of this issue.\";\n            $c->stash->{technical_details} = $technical_details;\n            $c->stash->{action_required} = $action_required;\n\n            # Add debug message that will be displayed to admins\n            $c->stash->{debug_msg} = \"Domain Error ($error_type): $technical_details\";\n\n            # Forward to the error template and stop processing\n            $c->forward($c->view('TT'));\n            $c->detach(); # Ensure we stop processing here and show the error page\n        } else {\n            # No site domain found, check if it's a database connection error\n            if ($c->stash->{db_connection_error}) {\n                $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'auto',\n                    \"Database connection error: \" . ($c->stash->{error_message} || \"Unknown error\"));\n\n                # Set a default site name\n                $SiteName = 'default';\n                $c->stash->{SiteName} = $SiteName;\n                $c->session->{SiteName} = $SiteName;\n\n                # Don't redirect to database setup for user-related actions or static content\n                if ($c->action->name ne 'database_setup' &&\n                    $c->action->name ne 'remotedb' &&\n                    ref($c->controller) ne 'Comserv::Controller::User' &&\n                    ref($c->controller) ne 'Catalyst::Controller::Static::Simple') {\n\n                    # Log the controller and action for debugging\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto',\n                        \"Controller: \" . ref($c->controller) . \", Action: \" . $c->action->name);\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto',\n                        \"Redirecting to database setup page due to connection error\");\n\n                    # Add error message to flash\n                    $c->flash->{error_message} = \"Could not connect to the database. Please check your database configuration.\";\n\n                    # Redirect to database setup\n                    $c->response->redirect($c->uri_for('/admin/database_setup'));\n                    return 0;\n                }\n            } elsif ($c->stash->{domain_not_found}) {\n                # Domain not found in database\n                $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'auto',\n                    \"Domain not found: \" . ($c->stash->{domain_name} || \"Unknown domain\"));\n\n                # Set a default site name\n                $SiteName = 'default';\n                $c->stash->{SiteName} = $SiteName;\n                $c->session->{SiteName} = $SiteName;\n            } else {\n                # Other error\n                $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'auto',\n                    \"Could not retrieve site domain for $domain. Using default site.\");\n\n                # Set a default site name\n                $SiteName = 'default';\n                $c->stash->{SiteName} = $SiteName;\n                $c->session->{SiteName} = $SiteName;\n\n                # Try to fetch and set the site name\n                $SiteName = $self->fetch_and_set($c, 'site');\n                $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', \"SiteName in setup_site = $SiteName\");\n            # Generic error case (should not happen with our improved error handling)\n            my $error_msg = \"DOMAIN ERROR: '$domain' not found in sitedomain table\";\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'setup_site', $error_msg);\n\n            # Add to debug_errors if not already there\n            unless (grep { $_ eq $error_msg } @{$c->stash->{debug_errors}}) {\n                push @{$c->stash->{debug_errors}}, $error_msg;\n            }\n\n            # Set default site for error handling\n            $SiteName = 'CSC'; # Default to CSC\n            $c->stash->{SiteName} = $SiteName;\n            $c->session->{SiteName} = $SiteName;\n\n            # Force Root controller to show error page\n            $c->stash->{ControllerName} = 'Root';\n            $c->session->{ControllerName} = 'Root';\n\n            # Set up site basics to get admin email\n            $self->site_setup($c, $SiteName);\n\n            # Send email notification to admin\n            if (my $mail_to_admin = $c->stash->{mail_to_admin}) {\n                my $email_params = {\n                    to      => $mail_to_admin,\n                    from    => $mail_to_admin,\n                    subject => \"URGENT: Comserv Domain Configuration Required\",\n                    body    => \"Domain Error: Domain not found in sitedomain table\\n\\n\" .\n                               \"Domain: $domain\\n\" .\n                               \"Error Type: domain_missing\\n\\n\" .\n                               \"ACTION REQUIRED: Please add this domain to the sitedomain table and associate it with the appropriate site.\\n\\n\" .\n                               \"Technical Details: The domain '$domain' needs to be added to the sitedomain table.\\n\\n\" .\n                               \"Time: \" . scalar(localtime) . \"\\n\" .\n                               \"IP Address: \" . ($c->req->address || 'unknown') . \"\\n\" .\n                               \"User Agent: \" . ($c->req->user_agent || 'unknown') . \"\\n\\n\" .\n                               \"This is a configuration error that needs to be fixed for proper site operation.\"\n                };\n\n                if ($self->send_email($c, $email_params)) {\n                    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site',\n                        \"Sent admin notification email about domain error for $domain\");\n                } else {\n                    $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'setup_site',\n                        \"Failed to send admin email notification about domain error for $domain\");\n                }\n            }\n\n            # Display error page with clear message about the domain configuration issue\n            $c->stash->{template} = 'error.tt';\n            $c->stash->{error_title} = \"Domain Configuration Error\";\n            $c->stash->{error_msg} = \"This domain ($domain) is not properly configured in the system.\";\n            $c->stash->{admin_msg} = \"The administrator has been notified of this issue.\";\n            $c->stash->{technical_details} = \"The domain '$domain' needs to be added to the sitedomain table.\";\n            $c->stash->{action_required} = \"Please add this domain to the sitedomain table and associate it with the appropriate site.\";\n\n                if (!defined $SiteName) {\n                    $c->stash(template => 'index.tt');\n                    $c->forward($c->view('TT'));\n                    return 0;\n                }\n            }\n            # Add debug message that will be displayed to admins\n            $c->stash->{debug_msg} = \"Domain '$domain' not found in sitedomain table. Please add it using the Site Administration interface.\";\n\n            # Set flash error message to ensure it's displayed\n            $c->flash->{error_msg} = \"Domain Error: This domain ($domain) is not properly configured in the system.\";\n\n            # Forward to the error template and stop processing\n            $c->forward($c->view('TT'));\n            $c->detach(); # Ensure we stop processing here and show the error page\n        }\n    } else {\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', \"SiteName in auto = $SiteName\");\n    }\n\n    $self->site_setup($c, $c->session->{SiteName});\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', 'Completed site setup');\n    $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', 'Entered auto action in Root.pm');\n\n    my $schema = $c->model('DBEncy');\n    #print \"Schema: $schema\\n\";\n    $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', \"Fetched SiteName: $SiteName\");\n\n    unless ($c->session->{group}) {\n        $c->session->{group} = 'normal';\n    }\n\n    my $debug_param = $c->req->param('debug');\n    if (defined $debug_param) {\n        # Check if debug_mode is defined before comparing\n        if (!defined $c->session->{debug_mode} || $c->session->{debug_mode} ne $debug_param) {\n            $c->session->{debug_mode} = $debug_param;\n            $c->stash->{debug_mode} = $debug_param;\n        }\n    } elsif (defined $c->session->{debug_mode}) {\n        $c->stash->{debug_mode} = $c->session->{debug_mode};\n    }\n    # Check if roles is defined and is an array reference before using it\n    if (defined $c->session->{roles} && ref($c->session->{roles}) eq 'ARRAY') {\n        my $roles_str = join(', ', @{$c->session->{roles}});\n        $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto',\n            \"Session Roles: \" . $roles_str);\n    } else {\n        $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto',\n            \"No roles defined in session\");\n        # Initialize roles as an empty array if not defined\n        $c->session->{roles} = [];\n    }\n\n    # Check for debug parameter in the URL and toggle debug mode accordingly\n    if (defined $c->req->params->{debug}) {\n        if ($c->req->params->{debug} == 1) {\n            $c->session->{debug_mode} = 1;\n            $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', \"Debug mode enabled\");\n        } elsif ($c->req->params->{debug} == 0) {\n            $c->session->{debug_mode} = 0;\n            $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', \"Debug mode disabled\");\n        }\n    } elsif (defined $c->session->{page}) {\n        $c->stash->{page} = $c->session->{page};\n    }\n\n    if (ref($c) eq 'Catalyst::Context') {\n        # Try to get links with error handling\n        eval {\n            my @main_links = $c->model('DB')->get_links($c, 'Main') || ();\n            my @login_links = $c->model('DB')->get_links($c, 'Login') || ();\n            my @global_links = $c->model('DB')->get_links($c, 'Global') || ();\n            my @hosted_links = $c->model('DB')->get_links($c, 'Hosted') || ();\n            my @member_links = $c->model('DB')->get_links($c, 'Member') || ();\n\n            $c->session(\n                main_links => \\@main_links,\n                login_links => \\@login_links,\n                global_links => \\@global_links,\n                hosted_links => \\@hosted_links,\n                member_links => \\@member_links,\n            );\n        };\n\n        # Log any errors\n        if ($@) {\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'auto',\n                \"Error getting links: $@\");\n\n            # Initialize empty arrays for links if they don't exist\n            $c->session->{main_links} ||= [];\n            $c->session->{login_links} ||= [];\n            $c->session->{global_links} ||= [];\n            $c->session->{hosted_links} ||= [];\n            $c->session->{member_links} ||= [];\n        }\n    }\n    # Set the mail server name based on the SiteName\n    my $mail_server;\n\n    return 1;\n}\n\nsub site_setup {\n    my ($self, $c, $SiteName) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', \"SiteName: $SiteName\");\n    my ($self, $c) = @_;\n    my $SiteName = $c->session->{SiteName};\n\n    # Log the start of site_setup\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',\n        \"Starting site_setup with SiteName: \" . (defined $SiteName ? $SiteName : 'undefined'));\n\n    # Get the current domain for HostName\n    my $domain = $c->req->uri->host;\n    $domain =~ s/:.*//;  # Remove port if present\n\n    # Set a default HostName based on the current domain\n    my $protocol = $c->req->secure ? 'https' : 'http';\n    my $default_hostname = \"$protocol://$domain\";\n    $c->stash->{HostName} = $default_hostname;\n    $c->session->{Domain} = $domain;\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', \"Set default HostName: $default_hostname\");\n\n    my $site = $c->model('Site')->get_site_details_by_name($c, $SiteName);\n    unless (defined $site) {\n        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'site_setup', \"No site found for SiteName: $SiteName\");\n\n        # Set default values for critical variables\n        $c->stash->{ScriptDisplayName} = 'Site';\n        $c->stash->{css_view_name} = '/static/css/default.css';\n        $c->stash->{mail_to_admin} = 'admin@computersystemconsulting.ca';\n        $c->stash->{mail_replyto} = 'helpdesk.computersystemconsulting.ca';\n\n        # Add debug information\n        push @{$c->stash->{debug_errors}}, \"ERROR: No site found for SiteName: $SiteName\";\n        $c->stash->{debug_msg} = \"Using default site settings because no site was found for '$SiteName'\";\n\n        return;\n    }\n\n        my $css_view_name = $site->css_view_name || '/static/css/default.css';\n        my $site_display_name = $site->site_display_name || 'none';\n        my $mail_to_admin = $site->mail_to_admin || 'none';\n        my $mail_replyto = $site->mail_replyto || 'helpdesk.computersystemconsulting.ca';\n        my $site_name = $site->name || 'none';\n    # Log success\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',\n        \"Successfully retrieved site details for: \" . $site->name);\n    my $css_view_name = $site->css_view_name || '/static/css/default.css';\n    my $site_display_name = $site->site_display_name || $SiteName;\n    my $mail_to_admin = $site->mail_to_admin || 'admin@computersystemconsulting.ca';\n    my $mail_replyto = $site->mail_replyto || 'helpdesk.computersystemconsulting.ca';\n    my $site_name = $site->name || $SiteName;\n\n    # If site has a document_root_url, use it for HostName\n    if ($site->document_root_url && $site->document_root_url ne '') {\n        $c->stash->{HostName} = $site->document_root_url;\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',\n            \"Set HostName from document_root_url: \" . $site->document_root_url);\n    }\n\n    # Get theme from ThemeConfig\n    my $theme_name = $c->model('ThemeConfig')->get_site_theme($c, $SiteName);\n\n    # Set theme in stash for Header.tt to use\n    $c->stash->{theme_name} = $theme_name;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',\n        \"Set theme_name in stash: $theme_name\");\n\n    # Set stash values from site\n    my $css_view_name = $site->css_view_name || '/static/css/default.css';\n    my $site_display_name = $site->site_display_name || 'Default Site';\n    my $mail_to_admin = $site->mail_to_admin || 'admin@example.com';\n    my $mail_replyto = $site->mail_replyto || 'helpdesk.computersystemconsulting.ca';\n\n    # Set the stash values\n    $c->stash->{ScriptDisplayName} = $site_display_name;\n    $c->stash->{css_view_name} = $css_view_name;\n    $c->stash->{mail_to_admin} = $mail_to_admin;\n    $c->stash->{mail_replyto} = $mail_replyto;\n\n    # Log completion\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', \"Completed site_setup action\");\n\n    $c->stash(\n        default_css => $c->uri_for($css_view_name),\n        menu_css => $c->uri_for('/static/css/menu.css'),\n        log_css => $c->uri_for('/static/css/log.css'),\n        todo_css => $c->uri_for('/static/css/todo.css'),\n    );\n}\n    $c->stash->{ScriptDisplayName} = $site_display_name;\n    $c->stash->{css_view_name} = $css_view_name;\n    $c->stash->{mail_to_admin} = $mail_to_admin;\n    $c->stash->{mail_replyto} = $mail_replyto;\n    $c->stash->{SiteName} = $site_name;\n    $c->session->{SiteName} = $site_name;\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',\n        \"Completed site_setup action with HostName: \" . $c->stash->{HostName});\n}\n\nsub debug :Path('/debug') {\n    my ($self, $c) = @_;\n    my $site_name = $c->stash->{SiteName};\n    $c->stash(template => 'debug.tt');\n    $c->forward($c->view('TT'));\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'debug', \"Completed debug action\");\n}\nsub debug :Path('/debug') {\n    my ($self, $c) = @_;\n    my $site_name = $c->stash->{SiteName};\n    $c->stash(template => 'debug.tt');\n    $c->forward($c->view('TT'));\n   $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', \"Completed site_setup action\");\n}\n\nsub accounts :Path('/accounts') :Args(0) {\n    my ($self, $c) = @_;\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'accounts', \"Accessing accounts page\");\n\n    $c->stash(template => 'accounts.tt');\n    $c->forward($c->view('TT'));\n}\n\nsub default :Path {\n    my ( $self, $c ) = @_;\n    $c->response->body( 'Page not found' );\n    $c->response->status(404);\n}\n# Special route for hosting\n\n\nsub default :Path {\n    my ( $self, $c ) = @_;\n\n    # Log the 404 error with detailed information\n    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',\n        \"404 Not Found: \" . $c->req->uri->path);\n    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',\n        \"Request method: \" . $c->req->method);\n    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',\n        \"Controller: \" . __PACKAGE__);\n\n    # Log the available controllers and their namespaces\n    my @controllers = sort keys %{$c->dispatcher->_controller_by_path};\n    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',\n        \"Available controllers: \" . join(\", \", @controllers));\n\n    # Log the available actions for this path\n    my $path = $c->req->uri->path;\n    my $actions = $c->dispatcher->get_actions_for_path($path);\n    if ($actions && @$actions) {\n        $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',\n            \"Actions for path $path: \" . join(\", \", map { $_->reverse } @$actions));\n    } else {\n        $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',\n            \"No actions found for path $path\");\n    }\n\n    # Set up the 404 page\n    $c->stash(\n        template => 'error.tt',\n        error_title => '404 - Page Not Found',\n        error_msg => 'The page you requested could not be found.',\n        requested_path => $c->req->uri->path,\n        status_code => 404\n    );\n\n    # Set the HTTP status code\n    $c->response->status(404);\n\n    # Render the error template\n    $c->forward($c->view('TT'));\n}\n\nsub documentation :Path('documentation') :Args(0) {\n    my ( $self, $c ) = @_;\n    $c->stash(template => 'Documentation/Documentation.tt');\n}\nsub documentation :Path('documentation') :Args(0) {\n    my ( $self, $c ) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'documentation', \"Redirecting to Documentation controller\");\n    $c->response->redirect($c->uri_for('/Documentation'));\n}\n\nsub Documentation :Path('Documentation') :Args {\n    my ( $self, $c, @args ) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'Documentation', \"Forwarding to Documentation controller with args: \" . join(', ', @args));\n\n    if (@args) {\n        $c->detach('/documentation/view', [@args]);\n    } else {\n        $c->detach('/documentation/index');\n    }\n}\n\nsub reset_session :Global {\n    my ( $self, $c ) = @_;\n\n    # Log the session reset request\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'reset_session',\n        \"Session reset requested. Session ID: \" . $c->sessionid);\n\n    # Store the current SiteName for debugging\n    my $old_site_name = $c->session->{SiteName} || 'none';\n\n    # Clear the entire session\n    $c->delete_session(\"User requested session reset\");\n\n    # Create a new session\n    $c->session->{reset_time} = time();\n    $c->session->{debug_mode} = 1; # Enable debug mode by default after reset\n\n    # Log the new session\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'reset_session',\n        \"New session created. Session ID: \" . $c->sessionid . \", Old SiteName: \" . $old_site_name);\n\n    # Redirect to home page\n    $c->response->redirect($c->uri_for('/'));\n}\n\n\n# Remote database management\nsub remotedb :Path('remotedb') :Args(0) {\n    my ($self, $c) = @_;\n\n    # Log the access to the remote database management page\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'remotedb', \"Accessing remote database management\");\n\n    # Forward to the RemoteDB controller's index action\n    $c->forward('/remotedb/index');\n}\n\nsub end : ActionClass('RenderView') {}\nsub end : ActionClass('RenderView') {}\n\n__PACKAGE__->meta->make_immutable;\n\n1;\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/lib/Comserv/Controller/Root.pm b/Comserv/lib/Comserv/Controller/Root.pm
--- a/Comserv/lib/Comserv/Controller/Root.pm	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/lib/Comserv/Controller/Root.pm	(date 1742226357274)
@@ -503,7 +503,7 @@
             $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'setup_site', "Found site domain for $domain");
 
             my $site_id = $site_domain->site_id;
-            my $site = $c->model('Site')->get_site_details($site_id, $c);
+            my $site = $c->model('Site')->get_site_details($c, $site_id);
             $self->logging->log_with_details($c, 'debug', __FILE__, __LINE__, 'auto', "Site ID: $site_id");
 
             if ($site) {
@@ -811,14 +811,11 @@
 }
 
 sub site_setup {
-    my ($self, $c, $SiteName) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', "SiteName: $SiteName");
     my ($self, $c) = @_;
-    my $SiteName = $c->session->{SiteName};
 
     # Log the start of site_setup
     $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',
-        "Starting site_setup with SiteName: " . (defined $SiteName ? $SiteName : 'undefined'));
+        "Starting site_setup with SiteName: " . ($c->session->{SiteName} // 'undefined'));
 
     # Get the current domain for HostName
     my $domain = $c->req->uri->host;
@@ -830,11 +827,14 @@
     $c->stash->{HostName} = $default_hostname;
     $c->session->{Domain} = $domain;
 
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', "Set default HostName: $default_hostname");
+    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',
+        "Set default HostName: $default_hostname");
 
-    my $site = $c->model('Site')->get_site_details_by_name($c, $SiteName);
+    # Get site details
+    my $site = $c->model('Site')->get_site_details_by_name($c, $c->session->{SiteName});
     unless (defined $site) {
-        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'site_setup', "No site found for SiteName: $SiteName");
+        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'site_setup',
+            "No site found for SiteName: " . ($c->session->{SiteName} // 'undefined'));
 
         # Set default values for critical variables
         $c->stash->{ScriptDisplayName} = 'Site';
@@ -843,26 +843,12 @@
         $c->stash->{mail_replyto} = 'helpdesk.computersystemconsulting.ca';
 
         # Add debug information
-        push @{$c->stash->{debug_errors}}, "ERROR: No site found for SiteName: $SiteName";
-        $c->stash->{debug_msg} = "Using default site settings because no site was found for '$SiteName'";
+        push @{$c->stash->{debug_errors}}, "ERROR: No site found for SiteName: " . ($c->session->{SiteName} // 'undefined');
+        $c->stash->{debug_msg} = "Using default site settings because no site was found";
 
         return;
     }
 
-        my $css_view_name = $site->css_view_name || '/static/css/default.css';
-        my $site_display_name = $site->site_display_name || 'none';
-        my $mail_to_admin = $site->mail_to_admin || 'none';
-        my $mail_replyto = $site->mail_replyto || 'helpdesk.computersystemconsulting.ca';
-        my $site_name = $site->name || 'none';
-    # Log success
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',
-        "Successfully retrieved site details for: " . $site->name);
-    my $css_view_name = $site->css_view_name || '/static/css/default.css';
-    my $site_display_name = $site->site_display_name || $SiteName;
-    my $mail_to_admin = $site->mail_to_admin || 'admin@computersystemconsulting.ca';
-    my $mail_replyto = $site->mail_replyto || 'helpdesk.computersystemconsulting.ca';
-    my $site_name = $site->name || $SiteName;
-
     # If site has a document_root_url, use it for HostName
     if ($site->document_root_url && $site->document_root_url ne '') {
         $c->stash->{HostName} = $site->document_root_url;
@@ -871,53 +857,30 @@
     }
 
     # Get theme from ThemeConfig
-    my $theme_name = $c->model('ThemeConfig')->get_site_theme($c, $SiteName);
-
-    # Set theme in stash for Header.tt to use
+    my $theme_name = $c->model('ThemeConfig')->get_site_theme($c, $c->session->{SiteName});
     $c->stash->{theme_name} = $theme_name;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',
-        "Set theme_name in stash: $theme_name");
 
     # Set stash values from site
-    my $css_view_name = $site->css_view_name || '/static/css/default.css';
-    my $site_display_name = $site->site_display_name || 'Default Site';
-    my $mail_to_admin = $site->mail_to_admin || 'admin@example.com';
-    my $mail_replyto = $site->mail_replyto || 'helpdesk.computersystemconsulting.ca';
-
-    # Set the stash values
-    $c->stash->{ScriptDisplayName} = $site_display_name;
-    $c->stash->{css_view_name} = $css_view_name;
-    $c->stash->{mail_to_admin} = $mail_to_admin;
-    $c->stash->{mail_replyto} = $mail_replyto;
+    $c->stash->{ScriptDisplayName} = $site->site_display_name // 'Default Site';
+    $c->stash->{css_view_name} = $site->css_view_name // '/static/css/default.css';
+    $c->stash->{mail_to_admin} = $site->mail_to_admin // 'admin@computersystemconsulting.ca';
+    $c->stash->{mail_replyto} = $site->mail_replyto // 'helpdesk.computersystemconsulting.ca';
+    $c->stash->{SiteName} = $site->name;
+    $c->session->{SiteName} = $site->name;
 
-    # Log completion
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup', "Completed site_setup action");
-
+    # Set CSS URIs
     $c->stash(
-        default_css => $c->uri_for($css_view_name),
+        default_css => $c->uri_for($c->stash->{css_view_name}),
         menu_css => $c->uri_for('/static/css/menu.css'),
         log_css => $c->uri_for('/static/css/log.css'),
         todo_css => $c->uri_for('/static/css/todo.css'),
     );
-}
-    $c->stash->{ScriptDisplayName} = $site_display_name;
-    $c->stash->{css_view_name} = $css_view_name;
-    $c->stash->{mail_to_admin} = $mail_to_admin;
-    $c->stash->{mail_replyto} = $mail_replyto;
-    $c->stash->{SiteName} = $site_name;
-    $c->session->{SiteName} = $site_name;
 
     $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'site_setup',
         "Completed site_setup action with HostName: " . $c->stash->{HostName});
 }
 
-sub debug :Path('/debug') {
-    my ($self, $c) = @_;
-    my $site_name = $c->stash->{SiteName};
-    $c->stash(template => 'debug.tt');
-    $c->forward($c->view('TT'));
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'debug', "Completed debug action");
-}
+
 sub debug :Path('/debug') {
     my ($self, $c) = @_;
     my $site_name = $c->stash->{SiteName};
@@ -935,67 +898,6 @@
     $c->forward($c->view('TT'));
 }
 
-sub default :Path {
-    my ( $self, $c ) = @_;
-    $c->response->body( 'Page not found' );
-    $c->response->status(404);
-}
-# Special route for hosting
-
-
-sub default :Path {
-    my ( $self, $c ) = @_;
-
-    # Log the 404 error with detailed information
-    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',
-        "404 Not Found: " . $c->req->uri->path);
-    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',
-        "Request method: " . $c->req->method);
-    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',
-        "Controller: " . __PACKAGE__);
-
-    # Log the available controllers and their namespaces
-    my @controllers = sort keys %{$c->dispatcher->_controller_by_path};
-    $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',
-        "Available controllers: " . join(", ", @controllers));
-
-    # Log the available actions for this path
-    my $path = $c->req->uri->path;
-    my $actions = $c->dispatcher->get_actions_for_path($path);
-    if ($actions && @$actions) {
-        $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',
-            "Actions for path $path: " . join(", ", map { $_->reverse } @$actions));
-    } else {
-        $self->logging->log_with_details($c, 'warn', __FILE__, __LINE__, 'default',
-            "No actions found for path $path");
-    }
-
-    # Set up the 404 page
-    $c->stash(
-        template => 'error.tt',
-        error_title => '404 - Page Not Found',
-        error_msg => 'The page you requested could not be found.',
-        requested_path => $c->req->uri->path,
-        status_code => 404
-    );
-
-    # Set the HTTP status code
-    $c->response->status(404);
-
-    # Render the error template
-    $c->forward($c->view('TT'));
-}
-
-sub documentation :Path('documentation') :Args(0) {
-    my ( $self, $c ) = @_;
-    $c->stash(template => 'Documentation/Documentation.tt');
-}
-sub documentation :Path('documentation') :Args(0) {
-    my ( $self, $c ) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'documentation', "Redirecting to Documentation controller");
-    $c->response->redirect($c->uri_for('/Documentation'));
-}
-
 sub Documentation :Path('Documentation') :Args {
     my ( $self, $c, @args ) = @_;
     $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'Documentation', "Forwarding to Documentation controller with args: " . join(', ', @args));
@@ -1044,7 +946,7 @@
     $c->forward('/remotedb/index');
 }
 
-sub end : ActionClass('RenderView') {}
+
 sub end : ActionClass('RenderView') {}
 
 __PACKAGE__->meta->make_immutable;
Index: Comserv/lib/Comserv/Model/Site.pm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Comserv::Model::Site;\n\nuse Moose;\nuse namespace::autoclean;\nuse Try::Tiny;\nuse Comserv::Util::Logging;\nuse JSON;\nuse File::Slurp;\n\nextends 'Catalyst::Model';\nhas 'logging' => (\n    is => 'ro',\n    default => sub { Comserv::Util::Logging->instance }\n);\nhas 'schema' => (\n    is => 'ro',\n    required => 1,\n);\n\nsub COMPONENT {\n    my ($class, $app, $args) = @_;\n\n    my $schema = $app->model('DBEncy')->schema;\n    return $class->new({ %$args, schema => $schema });\n}\n\nsub get_all_sites {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_all_sites', \"Getting all sites\");\n    $self->schema->storage->ensure_connected;\n\n    my @sites;\n    try {\n        my $site_rs = $self->schema->resultset('Site');\n        @sites = $site_rs->all;\n    } catch {\n        # If there's an error about the theme column\n        if ($_ =~ /Unknown column 'me\\.theme'/) {\n            # Log the error\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_all_sites', \"Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.\");\n\n            # Get sites without theme column\n            my $site_rs = $self->schema->resultset('Site');\n            @sites = $site_rs->search(\n                {},\n                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt\n                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion\n                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name\n                                document_root_url link_target http_header_params image_root_url\n                                global_datafiles_directory templates_cache_directory app_datafiles_directory\n                                datasource_type cal_table http_header_description http_header_keywords)] }\n            );\n\n            # Add a default theme property to each site\n            foreach my $site (@sites) {\n                $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site->{name});\n            }\n\n            # Add a message to the flash\n            $c->flash->{error_msg} = \"The theme feature requires a database update. <a href='/admin/add_theme_column'>Click here to add the theme column</a>.\";\n        } else {\n            # For other errors, re-throw\n            die $_;\n        }\n    };\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_all_sites', \"Visited the site page\");\n    return \\@sites;\n}\n\nsub get_site_domain {\n    my ($self, $c, $domain) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_domain', \"Looking up domain: $domain\");\n\n    # Initialize debug_errors array if it doesn't exist\n    $c->stash->{debug_errors} //= [];\n\n    try {\n        # First check if the sitedomain table exists\n        my $dbh = $self->schema->storage->dbh;\n        my $sth = $dbh->table_info('', 'ency', 'sitedomain', 'TABLE');\n        my $table_exists = $sth->fetchrow_arrayref;\n\n        unless ($table_exists) {\n            my $error_msg = \"CRITICAL ERROR: sitedomain table does not exist in database\";\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);\n            push @{$c->stash->{debug_errors}}, $error_msg;\n\n            # Set specific error message for the user\n            $c->stash->{domain_error} = {\n                type => 'schema_missing',\n                message => \"The sitedomain table is missing from the database. Please run the database schema update script.\",\n                domain => $domain,\n                technical_details => \"Table 'sitedomain' does not exist in the database schema.\"\n            };\n\n            return undef;\n        }\n\n        # Look up the domain in the sitedomain table\n        my $result = $self->schema->resultset('SiteDomain')->find({ domain => $domain });\n\n        if ($result) {\n            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_domain',\n                \"Domain found: $domain (site_id: \" . $result->site_id . \")\");\n            return $result;\n        } else {\n            my $error_msg = \"DOMAIN ERROR: Domain '$domain' not found in sitedomain table\";\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);\n            push @{$c->stash->{debug_errors}}, $error_msg;\n\n            # Set specific error message for the user\n            $c->stash->{domain_error} = {\n                type => 'domain_missing',\n                message => \"The domain '$domain' is not configured in the system.\",\n                domain => $domain,\n                technical_details => \"Domain '$domain' not found in sitedomain table. Add it using the Site Administration interface.\",\n                action_required => \"Please add this domain to the sitedomain table and associate it with the appropriate site.\"\n            };\n\n            # Set SiteName to 'none' directly\n            $c->session->{SiteName} = 'none';\n            $c->stash->{SiteName} = 'none';\n\n            return undef;\n        }\n    } catch {\n        my $error = $_;\n        if ($error =~ /Table 'ency\\.sitedomain' doesn't exist/) {\n            my $error_msg = \"SCHEMA ERROR: Table 'ency.sitedomain' doesn't exist. Schema update required.\";\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);\n            push @{$c->stash->{debug_errors}}, $error_msg;\n\n            # Set specific error message for the user\n            $c->stash->{domain_error} = {\n                type => 'schema_error',\n                message => \"The database schema is outdated and missing required tables.\",\n                domain => $domain,\n                technical_details => \"Table 'ency.sitedomain' doesn't exist. Schema update required.\",\n                action_required => \"Please run the database schema update script.\"\n            };\n\n            return undef;\n        } else {\n            my $error_msg = \"DATABASE ERROR: Failed to query sitedomain table: $error\";\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);\n            push @{$c->stash->{debug_errors}}, $error_msg;\n\n            # Set specific error message for the user\n            $c->stash->{domain_error} = {\n                type => 'database_error',\n                message => \"A database error occurred while looking up the domain.\",\n                domain => $domain,\n                technical_details => \"Error: $error\",\n                action_required => \"Please check the database connection and configuration.\"\n            };\n\n            die $error;\n        }\n    };\n}\n\nsub add_site {\n    my ($self, $c, $site_details) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'add_site', \"Adding new site: \" . join(\", \", map { \"$_: $site_details->{$_}\" } keys %$site_details));\n\n    my $site_rs;\n    my $new_site;\n\n    try {\n        $site_rs = $self->schema->resultset('Site');\n        $new_site = $site_rs->create($site_details);\n    } catch {\n        # If there's an error about the theme column\n        if ($_ =~ /Unknown column 'me\\.theme'/) {\n            # Log the error\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'add_site', \"Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.\");\n\n            # Create site without theme column\n            my $filtered_details = {%$site_details};\n            delete $filtered_details->{theme};\n\n            $site_rs = $self->schema->resultset('Site');\n            $new_site = $site_rs->create($filtered_details);\n\n            # Add a default theme property\n            $new_site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $new_site->{name});\n\n            # Add a message to the flash\n            $c->flash->{error_msg} = \"The theme feature requires a database update. <a href='/admin/add_theme_column'>Click here to add the theme column</a>.\";\n        } else {\n            # For other errors, re-throw\n            die $_;\n        }\n    };\n\n    return $new_site;\n}\n\nsub update_site {\n    my ($self, $c,$site_id, $new_site_details) =  @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'update_site', \"Updating site with ID $site_id: \" . join(\", \", map { \"$_: $new_site_details->{$_}\" } keys %$new_site_details));\n    my $site_rs = $self->schema->resultset('Site');\n    my $site = $site_rs->find($site_id);\n    $site->update($new_site_details) if $site;\n    return $site;\n}\n\nsub delete_site {\n    my ($self, $c, $site_id) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'delete_site', \"Deleting site with ID $site_id\");\n\n    my $site;\n    try {\n        my $site_rs = $self->schema->resultset('Site');\n        $site = $site_rs->find({ id => $site_id });\n        $site->delete if $site;\n    } catch {\n        # If there's an error about the theme column\n        if ($_ =~ /Unknown column 'me\\.theme'/) {\n            # Log the error\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'delete_site', \"Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.\");\n\n            # Get site without theme column\n            my $site_rs = $self->schema->resultset('Site');\n            $site = $site_rs->find(\n                { id => $site_id },\n                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt\n                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion\n                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name\n                                document_root_url link_target http_header_params image_root_url\n                                global_datafiles_directory templates_cache_directory app_datafiles_directory\n                                datasource_type cal_table http_header_description http_header_keywords)] }\n            );\n\n            # Delete the site if found\n            $site->delete if $site;\n\n            # Add a default theme property\n            $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site->{name}) if $site;\n\n            # Add a message to the flash\n            $c->flash->{error_msg} = \"The theme feature requires a database update. <a href='/admin/add_theme_column'>Click here to add the theme column</a>.\";\n        } else {\n            # For other errors, re-throw\n            die $_;\n        }\n    };\n\n    return $site;\n}\n\nsub get_site_details_by_name {\n    my ($self, $c, $site_name) = @_;\n    print \" in get_site_details_by_name Site name: $site_name\\n\";\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details_by_name', \"Site name: $site_name\");\n\n    my $site;\n    try {\n        my $site_rs = $self->schema->resultset('Site');\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details_by_name', \"Visited the site page $site_rs\");\n        $site = $site_rs->find({ name => $site_name });\n    } catch {\n        # If there's an error about the theme column\n        if ($_ =~ /Unknown column 'me\\.theme'/) {\n            # Log the error\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_details_by_name', \"Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.\");\n\n            # Get site without theme column\n            my $site_rs = $self->schema->resultset('Site');\n            $site = $site_rs->find(\n                { name => $site_name },\n                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt\n                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion\n                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name\n                                document_root_url link_target http_header_params image_root_url\n                                global_datafiles_directory templates_cache_directory app_datafiles_directory\n                                datasource_type cal_table http_header_description http_header_keywords)] }\n            );\n\n            # Add a default theme property\n            $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site_name) if $site;\n\n            # Add a message to the flash\n            $c->flash->{error_msg} = \"The theme feature requires a database update. Please run the add_theme_column.pl script.\";\n        } else {\n            # For other errors, re-throw\n            die $_;\n        }\n    };\n\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details_by_name', \"Site found: \" . ($site ? $site->id : 'None'));\n    return $site;\n}\n\n# Renamed to avoid duplicate method\nsub get_site_domain_by_name {\n    my ($self, $c, $domain_name) = @_;\n\n    # Check if domain_name is defined\n    unless (defined $domain_name && $domain_name ne '') {\n        $self->logging->log_with_details(\n            $c,\n            'error',\n            __FILE__,\n            __LINE__,\n            'get_site_domain',\n            \"Domain name not provided\"\n        );\n        return;\n    }\n\n    # Attempt to query the SiteDomain table\n    my $site_domain;\n    eval {\n        $site_domain = $self->schema->resultset('SiteDomain')->find({ domain => $domain_name });\n    };\n\n    if ($@ || !$site_domain) {\n        # Log failure for missing or invalid domain\n        my $error = !$site_domain\n            ? \"Site domain '$domain_name' not found.\"\n            : \"Error querying site domain for '$domain_name': $@\";\n        $self->logging->log_with_details(\n            $c,\n            'error',\n            __FILE__,\n            __LINE__,\n            'get_site_domain',\n            $error\n        );\n\n        # Forward to the 'database_setup' action on failure\n        $c->forward('/admin/database_setup'); # Use the Admin controller's action\n        $c->detach; # Stop further processing\n        return;\n    }\n\n    # On success, log and return the site domain object\n    $self->logging->log_with_details(\n        $c,\n        'info',\n        __FILE__,\n        __LINE__,\n        'get_site_domain',\n        \"Site domain successfully retrieved for '$domain_name'.\"\n    );\n\n    return $site_domain;\n}\n\n\n\n# Renamed to avoid duplicate method\nsub get_site_domain_with_error_handling {\n    my ($self, $c, $domain_name) = @_;\n\n    # Log the attempt to fetch the site domain\n    $self->logging->log_with_details(\n        $c,\n        'info',\n        __FILE__,\n        __LINE__,\n        'get_site_domain',\n        \"Fetching site domain record for domain name: '$domain_name'.\"\n    );\n\n    # Try to ensure database connection with better error handling\n    my $is_connected = 0;\n    my $connection_error = '';\n\n    eval {\n        $is_connected = $self->schema->storage->ensure_connected;\n        $is_connected = 1 if $is_connected; # normalize to 1 if successful\n    };\n\n    if ($@) {\n        $connection_error = $@;\n    }\n\n    # If connection failed, log and return null\n    unless ($is_connected) {\n        # Log database connection failure with detailed error\n        $self->logging->log_with_details(\n            $c,\n            'error',\n            __FILE__,\n            __LINE__,\n            'get_site_domain',\n            \"Database connection failed: \" . ($connection_error || \"Unknown error\")\n        );\n\n        # Add a message to the stash for the user\n        if ($c && ref($c) eq 'Catalyst::Context') {\n            $c->stash->{db_connection_error} = 1;\n            $c->stash->{error_message} = \"Could not connect to the database. Please check your database configuration.\";\n        }\n\n        return;\n    }\n\n    # Query the SiteDomain table with better error handling\n    my $site_domain;\n    my $query_error = '';\n\n    eval {\n        my $site_domain_rs = $self->schema->resultset('SiteDomain');\n        $site_domain = $site_domain_rs->find({ domain => $domain_name });\n    };\n\n    if ($@) {\n        $query_error = $@;\n    }\n\n    # If query failed or no domain found, log and return null\n    if ($query_error || !$site_domain) {\n        # Log query failure or missing domain\n        my $error_message = $query_error || \"Domain '$domain_name' not found in SiteDomain table.\";\n        $self->logging->log_with_details(\n            $c,\n            'error',\n            __FILE__,\n            __LINE__,\n            'get_site_domain',\n            \"Failed to fetch site domain: $error_message\"\n        );\n\n        # Add a message to the stash if domain not found\n        if ($c && ref($c) eq 'Catalyst::Context' && !$query_error) {\n            $c->stash->{domain_not_found} = 1;\n            $c->stash->{domain_name} = $domain_name;\n        }\n\n        return;\n    }\n\n    # Log success and return the site domain object\n    $self->logging->log_with_details(\n        $c,\n        'info',\n        __FILE__,\n        __LINE__,\n        'get_site_domain',\n        \"Successfully retrieved site domain for '$domain_name'.\"\n    );\n\n    return $site_domain;\n}\n\nsub get_site_details {\n    my ($self, $site_id, $c) = @_;\n\n    # Check if site_id is defined\n    unless (defined $site_id && $site_id ne '') {\n        if ($c) {\n            $self->logging->log_with_details(\n                $c,\n                'error',\n                __FILE__,\n                __LINE__,\n                'get_site_details',\n                \"Site ID not provided\"\n            );\n        }\n        return $self->get_default_site();\n    }\n\n    # Try to get site details with error handling\n    my $site;\n    eval {\n        my $site_rs = $self->schema->resultset('Site');\n        $site = $site_rs->find({ id => $site_id });\n    };\n\n    # If there was an error or no site found, return default site\n    if ($@ || !$site) {\n        if ($c) {\n            $self->logging->log_with_details(\n                $c,\n                'error',\n                __FILE__,\n                __LINE__,\n                'get_site_details',\n                \"Failed to get site details for ID $site_id: \" . ($@ || \"Site not found\")\n            );\n        }\n        return $self->get_default_site();\n    }\n\n    # Log success\n    my ($self, $c, $site_id) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details', \"Site ID: $site_id\");\n\n    return $site;\n}\n\n# Renamed to avoid duplicate method\nsub get_site_details_by_name_with_error_handling {\n    my ($self, $c, $site_name) = @_;\n\n    # Log the attempt\n    if ($c) {\n        $self->logging->log_with_details(\n            $c,\n            'info',\n            __FILE__,\n            __LINE__,\n            'get_site_details_by_name_with_error_handling',\n            \"Site name: $site_name\"\n        );\n    }\n\n    # Return default values if no site name provided\n    unless (defined $site_name && $site_name ne '') {\n        return $self->get_default_site();\n    }\n\n    # Try to find the site by name\n    my $site;\n    eval {\n        my $site_rs = $self->schema->resultset('Site');\n        $site = $site_rs->find({ name => $site_name });\n    };\n\n    # If there was an error or no site found, return default site\n    if ($@ || !$site) {\n        if ($c) {\n            $self->logging->log_with_details(\n                $c,\n                'error',\n                __FILE__,\n                __LINE__,\n                'get_site_details_by_name_with_error_handling',\n                \"Failed to get site details for name $site_name: \" . ($@ || \"Site not found\")\n            );\n        }\n        return $self->get_default_site();\n    }\n\n    # Log success\n    if ($c) {\n        $self->logging->log_with_details(\n            $c,\n            'info',\n            __FILE__,\n            __LINE__,\n            'get_site_details_by_name_with_error_handling',\n            \"Site found: \" . $site->id\n        );\n    }\n\n\n    my $site;\n    try {\n        my $site_rs = $self->schema->resultset('Site');\n        $site = $site_rs->find({ id => $site_id });\n    } catch {\n        # If there's an error about the theme column\n        if ($_ =~ /Unknown column 'me\\.theme'/) {\n            # Log the error\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_details', \"Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.\");\n\n            # Get site without theme column\n            my $site_rs = $self->schema->resultset('Site');\n            $site = $site_rs->find(\n                { id => $site_id },\n                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt\n                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion\n                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name\n                                document_root_url link_target http_header_params image_root_url\n                                global_datafiles_directory templates_cache_directory app_datafiles_directory\n                                datasource_type cal_table http_header_description http_header_keywords)] }\n            );\n\n            # Add a default theme property\n            $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site->{name}) if $site;\n\n            # Add a message to the flash\n            $c->flash->{error_msg} = \"The theme feature requires a database update. Please run the add_theme_column.pl script.\";\n        } else {\n            # For other errors, re-throw\n            die $_;\n        }\n    };\n\n    return $site;\n}\n\n__PACKAGE__->meta->make_immutable;\n\n1;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/lib/Comserv/Model/Site.pm b/Comserv/lib/Comserv/Model/Site.pm
--- a/Comserv/lib/Comserv/Model/Site.pm	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/lib/Comserv/Model/Site.pm	(date 1742226357290)
@@ -8,584 +8,219 @@
 use File::Slurp;
 
 extends 'Catalyst::Model';
+
+# Attributes
 has 'logging' => (
     is => 'ro',
     default => sub { Comserv::Util::Logging->instance }
 );
+
 has 'schema' => (
     is => 'ro',
     required => 1,
 );
 
+# Component initialization
 sub COMPONENT {
     my ($class, $app, $args) = @_;
-
     my $schema = $app->model('DBEncy')->schema;
     return $class->new({ %$args, schema => $schema });
 }
 
+# Site operations
 sub get_all_sites {
     my ($self, $c) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_all_sites', "Getting all sites");
-    $self->schema->storage->ensure_connected;
+
+    $self->logging->log_with_details(
+        $c, 'info', __FILE__, __LINE__, 'get_all_sites',
+        "Getting all sites"
+    );
 
     my @sites;
     try {
         my $site_rs = $self->schema->resultset('Site');
         @sites = $site_rs->all;
     } catch {
-        # If there's an error about the theme column
-        if ($_ =~ /Unknown column 'me\.theme'/) {
-            # Log the error
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_all_sites', "Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.");
-
-            # Get sites without theme column
-            my $site_rs = $self->schema->resultset('Site');
-            @sites = $site_rs->search(
-                {},
-                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt
-                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion
-                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name
-                                document_root_url link_target http_header_params image_root_url
-                                global_datafiles_directory templates_cache_directory app_datafiles_directory
-                                datasource_type cal_table http_header_description http_header_keywords)] }
-            );
-
-            # Add a default theme property to each site
-            foreach my $site (@sites) {
-                $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site->{name});
-            }
-
-            # Add a message to the flash
-            $c->flash->{error_msg} = "The theme feature requires a database update. <a href='/admin/add_theme_column'>Click here to add the theme column</a>.";
-        } else {
-            # For other errors, re-throw
-            die $_;
-        }
+        my $error = $_;
+        $self->logging->log_with_details(
+            $c, 'error', __FILE__, __LINE__, 'get_all_sites',
+            "Error fetching sites: $error"
+        );
+        return [];
     };
 
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_all_sites', "Visited the site page");
     return \@sites;
 }
 
-sub get_site_domain {
-    my ($self, $c, $domain) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_domain', "Looking up domain: $domain");
-
-    # Initialize debug_errors array if it doesn't exist
-    $c->stash->{debug_errors} //= [];
-
-    try {
-        # First check if the sitedomain table exists
-        my $dbh = $self->schema->storage->dbh;
-        my $sth = $dbh->table_info('', 'ency', 'sitedomain', 'TABLE');
-        my $table_exists = $sth->fetchrow_arrayref;
-
-        unless ($table_exists) {
-            my $error_msg = "CRITICAL ERROR: sitedomain table does not exist in database";
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);
-            push @{$c->stash->{debug_errors}}, $error_msg;
-
-            # Set specific error message for the user
-            $c->stash->{domain_error} = {
-                type => 'schema_missing',
-                message => "The sitedomain table is missing from the database. Please run the database schema update script.",
-                domain => $domain,
-                technical_details => "Table 'sitedomain' does not exist in the database schema."
-            };
-
-            return undef;
-        }
-
-        # Look up the domain in the sitedomain table
-        my $result = $self->schema->resultset('SiteDomain')->find({ domain => $domain });
-
-        if ($result) {
-            $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_domain',
-                "Domain found: $domain (site_id: " . $result->site_id . ")");
-            return $result;
-        } else {
-            my $error_msg = "DOMAIN ERROR: Domain '$domain' not found in sitedomain table";
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);
-            push @{$c->stash->{debug_errors}}, $error_msg;
-
-            # Set specific error message for the user
-            $c->stash->{domain_error} = {
-                type => 'domain_missing',
-                message => "The domain '$domain' is not configured in the system.",
-                domain => $domain,
-                technical_details => "Domain '$domain' not found in sitedomain table. Add it using the Site Administration interface.",
-                action_required => "Please add this domain to the sitedomain table and associate it with the appropriate site."
-            };
-
-            # Set SiteName to 'none' directly
-            $c->session->{SiteName} = 'none';
-            $c->stash->{SiteName} = 'none';
-
-            return undef;
-        }
-    } catch {
-        my $error = $_;
-        if ($error =~ /Table 'ency\.sitedomain' doesn't exist/) {
-            my $error_msg = "SCHEMA ERROR: Table 'ency.sitedomain' doesn't exist. Schema update required.";
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);
-            push @{$c->stash->{debug_errors}}, $error_msg;
-
-            # Set specific error message for the user
-            $c->stash->{domain_error} = {
-                type => 'schema_error',
-                message => "The database schema is outdated and missing required tables.",
-                domain => $domain,
-                technical_details => "Table 'ency.sitedomain' doesn't exist. Schema update required.",
-                action_required => "Please run the database schema update script."
-            };
-
-            return undef;
-        } else {
-            my $error_msg = "DATABASE ERROR: Failed to query sitedomain table: $error";
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_domain', $error_msg);
-            push @{$c->stash->{debug_errors}}, $error_msg;
-
-            # Set specific error message for the user
-            $c->stash->{domain_error} = {
-                type => 'database_error',
-                message => "A database error occurred while looking up the domain.",
-                domain => $domain,
-                technical_details => "Error: $error",
-                action_required => "Please check the database connection and configuration."
-            };
-
-            die $error;
-        }
-    };
-}
-
-sub add_site {
-    my ($self, $c, $site_details) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'add_site', "Adding new site: " . join(", ", map { "$_: $site_details->{$_}" } keys %$site_details));
-
-    my $site_rs;
-    my $new_site;
-
-    try {
-        $site_rs = $self->schema->resultset('Site');
-        $new_site = $site_rs->create($site_details);
-    } catch {
-        # If there's an error about the theme column
-        if ($_ =~ /Unknown column 'me\.theme'/) {
-            # Log the error
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'add_site', "Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.");
-
-            # Create site without theme column
-            my $filtered_details = {%$site_details};
-            delete $filtered_details->{theme};
-
-            $site_rs = $self->schema->resultset('Site');
-            $new_site = $site_rs->create($filtered_details);
-
-            # Add a default theme property
-            $new_site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $new_site->{name});
-
-            # Add a message to the flash
-            $c->flash->{error_msg} = "The theme feature requires a database update. <a href='/admin/add_theme_column'>Click here to add the theme column</a>.";
-        } else {
-            # For other errors, re-throw
-            die $_;
-        }
-    };
-
-    return $new_site;
-}
-
-sub update_site {
-    my ($self, $c,$site_id, $new_site_details) =  @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'update_site', "Updating site with ID $site_id: " . join(", ", map { "$_: $new_site_details->{$_}" } keys %$new_site_details));
-    my $site_rs = $self->schema->resultset('Site');
-    my $site = $site_rs->find($site_id);
-    $site->update($new_site_details) if $site;
-    return $site;
-}
-
-sub delete_site {
+sub get_site_details {
     my ($self, $c, $site_id) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'delete_site', "Deleting site with ID $site_id");
+
+    return unless defined $site_id;
 
-    my $site;
+    $self->logging->log_with_details(
+        $c, 'info', __FILE__, __LINE__, 'get_site_details',
+        "Getting site details for ID: $site_id"
+    );
+
     try {
-        my $site_rs = $self->schema->resultset('Site');
-        $site = $site_rs->find({ id => $site_id });
-        $site->delete if $site;
+        my $site = $self->schema->resultset('Site')->find($site_id);
+        return $site if $site;
+
+        $self->logging->log_with_details(
+            $c, 'warn', __FILE__, __LINE__, 'get_site_details',
+            "Site not found for ID: $site_id"
+        );
+        return;
     } catch {
-        # If there's an error about the theme column
-        if ($_ =~ /Unknown column 'me\.theme'/) {
-            # Log the error
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'delete_site', "Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.");
-
-            # Get site without theme column
-            my $site_rs = $self->schema->resultset('Site');
-            $site = $site_rs->find(
-                { id => $site_id },
-                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt
-                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion
-                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name
-                                document_root_url link_target http_header_params image_root_url
-                                global_datafiles_directory templates_cache_directory app_datafiles_directory
-                                datasource_type cal_table http_header_description http_header_keywords)] }
-            );
-
-            # Delete the site if found
-            $site->delete if $site;
-
-            # Add a default theme property
-            $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site->{name}) if $site;
-
-            # Add a message to the flash
-            $c->flash->{error_msg} = "The theme feature requires a database update. <a href='/admin/add_theme_column'>Click here to add the theme column</a>.";
-        } else {
-            # For other errors, re-throw
-            die $_;
-        }
+        my $error = $_;
+        $self->logging->log_with_details(
+            $c, 'error', __FILE__, __LINE__, 'get_site_details',
+            "Error fetching site details: $error"
+        );
+        return;
     };
-
-    return $site;
 }
 
 sub get_site_details_by_name {
     my ($self, $c, $site_name) = @_;
-    print " in get_site_details_by_name Site name: $site_name\n";
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details_by_name', "Site name: $site_name");
+
+    return unless defined $site_name;
 
-    my $site;
+    $self->logging->log_with_details(
+        $c, 'info', __FILE__, __LINE__, 'get_site_details_by_name',
+        "Getting site details for name: $site_name"
+    );
+
     try {
-        my $site_rs = $self->schema->resultset('Site');
-        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details_by_name', "Visited the site page $site_rs");
-        $site = $site_rs->find({ name => $site_name });
+        my $site = $self->schema->resultset('Site')->find({ name => $site_name });
+        return $site if $site;
+
+        $self->logging->log_with_details(
+            $c, 'warn', __FILE__, __LINE__, 'get_site_details_by_name',
+            "Site not found for name: $site_name"
+        );
+        return;
     } catch {
-        # If there's an error about the theme column
-        if ($_ =~ /Unknown column 'me\.theme'/) {
-            # Log the error
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_details_by_name', "Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.");
-
-            # Get site without theme column
-            my $site_rs = $self->schema->resultset('Site');
-            $site = $site_rs->find(
-                { name => $site_name },
-                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt
-                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion
-                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name
-                                document_root_url link_target http_header_params image_root_url
-                                global_datafiles_directory templates_cache_directory app_datafiles_directory
-                                datasource_type cal_table http_header_description http_header_keywords)] }
-            );
-
-            # Add a default theme property
-            $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site_name) if $site;
-
-            # Add a message to the flash
-            $c->flash->{error_msg} = "The theme feature requires a database update. Please run the add_theme_column.pl script.";
-        } else {
-            # For other errors, re-throw
-            die $_;
-        }
-    };
-
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details_by_name', "Site found: " . ($site ? $site->id : 'None'));
-    return $site;
-}
-
-# Renamed to avoid duplicate method
-sub get_site_domain_by_name {
-    my ($self, $c, $domain_name) = @_;
-
-    # Check if domain_name is defined
-    unless (defined $domain_name && $domain_name ne '') {
+        my $error = $_;
         $self->logging->log_with_details(
-            $c,
-            'error',
-            __FILE__,
-            __LINE__,
-            'get_site_domain',
-            "Domain name not provided"
+            $c, 'error', __FILE__, __LINE__, 'get_site_details_by_name',
+            "Error fetching site details: $error"
         );
         return;
-    }
+    };
+}
 
-    # Attempt to query the SiteDomain table
-    my $site_domain;
-    eval {
-        $site_domain = $self->schema->resultset('SiteDomain')->find({ domain => $domain_name });
-    };
+sub get_site_domain {
+    my ($self, $c, $domain) = @_;
+
+    return unless defined $domain;
 
-    if ($@ || !$site_domain) {
-        # Log failure for missing or invalid domain
-        my $error = !$site_domain
-            ? "Site domain '$domain_name' not found."
-            : "Error querying site domain for '$domain_name': $@";
-        $self->logging->log_with_details(
-            $c,
-            'error',
-            __FILE__,
-            __LINE__,
-            'get_site_domain',
-            $error
-        );
+    $self->logging->log_with_details(
+        $c, 'info', __FILE__, __LINE__, 'get_site_domain',
+        "Looking up domain: $domain"
+    );
 
-        # Forward to the 'database_setup' action on failure
-        $c->forward('/admin/database_setup'); # Use the Admin controller's action
-        $c->detach; # Stop further processing
+    try {
+        my $site_domain = $self->schema->resultset('SiteDomain')->find({ domain => $domain });
+        return $site_domain if $site_domain;
+
+        $self->logging->log_with_details(
+            $c, 'warn', __FILE__, __LINE__, 'get_site_domain',
+            "Domain not found: $domain"
+        );
         return;
-    }
-
-    # On success, log and return the site domain object
-    $self->logging->log_with_details(
-        $c,
-        'info',
-        __FILE__,
-        __LINE__,
-        'get_site_domain',
-        "Site domain successfully retrieved for '$domain_name'."
-    );
-
-    return $site_domain;
+    } catch {
+        my $error = $_;
+        $self->logging->log_with_details(
+            $c, 'error', __FILE__, __LINE__, 'get_site_domain',
+            "Error looking up domain: $error"
+        );
+        return;
+    };
 }
 
+sub add_site {
+    my ($self, $c, $site_details) = @_;
 
+    return unless ref $site_details eq 'HASH';
 
-# Renamed to avoid duplicate method
-sub get_site_domain_with_error_handling {
-    my ($self, $c, $domain_name) = @_;
-
-    # Log the attempt to fetch the site domain
     $self->logging->log_with_details(
-        $c,
-        'info',
-        __FILE__,
-        __LINE__,
-        'get_site_domain',
-        "Fetching site domain record for domain name: '$domain_name'."
+        $c, 'info', __FILE__, __LINE__, 'add_site',
+        "Adding new site"
     );
 
-    # Try to ensure database connection with better error handling
-    my $is_connected = 0;
-    my $connection_error = '';
-
-    eval {
-        $is_connected = $self->schema->storage->ensure_connected;
-        $is_connected = 1 if $is_connected; # normalize to 1 if successful
-    };
+    try {
+        my $site = $self->schema->resultset('Site')->create($site_details);
+        return $site if $site;
 
-    if ($@) {
-        $connection_error = $@;
-    }
-
-    # If connection failed, log and return null
-    unless ($is_connected) {
-        # Log database connection failure with detailed error
         $self->logging->log_with_details(
-            $c,
-            'error',
-            __FILE__,
-            __LINE__,
-            'get_site_domain',
-            "Database connection failed: " . ($connection_error || "Unknown error")
+            $c, 'error', __FILE__, __LINE__, 'add_site',
+            "Failed to create site"
         );
-
-        # Add a message to the stash for the user
-        if ($c && ref($c) eq 'Catalyst::Context') {
-            $c->stash->{db_connection_error} = 1;
-            $c->stash->{error_message} = "Could not connect to the database. Please check your database configuration.";
-        }
-
         return;
-    }
-
-    # Query the SiteDomain table with better error handling
-    my $site_domain;
-    my $query_error = '';
-
-    eval {
-        my $site_domain_rs = $self->schema->resultset('SiteDomain');
-        $site_domain = $site_domain_rs->find({ domain => $domain_name });
-    };
-
-    if ($@) {
-        $query_error = $@;
-    }
-
-    # If query failed or no domain found, log and return null
-    if ($query_error || !$site_domain) {
-        # Log query failure or missing domain
-        my $error_message = $query_error || "Domain '$domain_name' not found in SiteDomain table.";
+    } catch {
+        my $error = $_;
         $self->logging->log_with_details(
-            $c,
-            'error',
-            __FILE__,
-            __LINE__,
-            'get_site_domain',
-            "Failed to fetch site domain: $error_message"
+            $c, 'error', __FILE__, __LINE__, 'add_site',
+            "Error creating site: $error"
         );
-
-        # Add a message to the stash if domain not found
-        if ($c && ref($c) eq 'Catalyst::Context' && !$query_error) {
-            $c->stash->{domain_not_found} = 1;
-            $c->stash->{domain_name} = $domain_name;
-        }
-
         return;
-    }
+    };
+}
 
-    # Log success and return the site domain object
+sub update_site {
+    my ($self, $c, $site_id, $site_details) = @_;
+
+    return unless defined $site_id && ref $site_details eq 'HASH';
+
     $self->logging->log_with_details(
-        $c,
-        'info',
-        __FILE__,
-        __LINE__,
-        'get_site_domain',
-        "Successfully retrieved site domain for '$domain_name'."
+        $c, 'info', __FILE__, __LINE__, 'update_site',
+        "Updating site ID: $site_id"
     );
-
-    return $site_domain;
-}
-
-sub get_site_details {
-    my ($self, $site_id, $c) = @_;
-
-    # Check if site_id is defined
-    unless (defined $site_id && $site_id ne '') {
-        if ($c) {
-            $self->logging->log_with_details(
-                $c,
-                'error',
-                __FILE__,
-                __LINE__,
-                'get_site_details',
-                "Site ID not provided"
-            );
-        }
-        return $self->get_default_site();
-    }
 
-    # Try to get site details with error handling
-    my $site;
-    eval {
-        my $site_rs = $self->schema->resultset('Site');
-        $site = $site_rs->find({ id => $site_id });
-    };
+    try {
+        my $site = $self->schema->resultset('Site')->find($site_id);
+        return unless $site;
 
-    # If there was an error or no site found, return default site
-    if ($@ || !$site) {
-        if ($c) {
-            $self->logging->log_with_details(
-                $c,
-                'error',
-                __FILE__,
-                __LINE__,
-                'get_site_details',
-                "Failed to get site details for ID $site_id: " . ($@ || "Site not found")
-            );
-        }
-        return $self->get_default_site();
-    }
+        $site->update($site_details);
+        return $site;
+    } catch {
+        my $error = $_;
+        $self->logging->log_with_details(
+            $c, 'error', __FILE__, __LINE__, 'update_site',
+            "Error updating site: $error"
+        );
+        return;
+    };
+}
 
-    # Log success
+sub delete_site {
     my ($self, $c, $site_id) = @_;
-    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'get_site_details', "Site ID: $site_id");
-
-    return $site;
-}
 
-# Renamed to avoid duplicate method
-sub get_site_details_by_name_with_error_handling {
-    my ($self, $c, $site_name) = @_;
+    return unless defined $site_id;
 
-    # Log the attempt
-    if ($c) {
-        $self->logging->log_with_details(
-            $c,
-            'info',
-            __FILE__,
-            __LINE__,
-            'get_site_details_by_name_with_error_handling',
-            "Site name: $site_name"
-        );
-    }
-
-    # Return default values if no site name provided
-    unless (defined $site_name && $site_name ne '') {
-        return $self->get_default_site();
-    }
-
-    # Try to find the site by name
-    my $site;
-    eval {
-        my $site_rs = $self->schema->resultset('Site');
-        $site = $site_rs->find({ name => $site_name });
-    };
-
-    # If there was an error or no site found, return default site
-    if ($@ || !$site) {
-        if ($c) {
-            $self->logging->log_with_details(
-                $c,
-                'error',
-                __FILE__,
-                __LINE__,
-                'get_site_details_by_name_with_error_handling',
-                "Failed to get site details for name $site_name: " . ($@ || "Site not found")
-            );
-        }
-        return $self->get_default_site();
-    }
-
-    # Log success
-    if ($c) {
-        $self->logging->log_with_details(
-            $c,
-            'info',
-            __FILE__,
-            __LINE__,
-            'get_site_details_by_name_with_error_handling',
-            "Site found: " . $site->id
-        );
-    }
+    $self->logging->log_with_details(
+        $c, 'info', __FILE__, __LINE__, 'delete_site',
+        "Deleting site ID: $site_id"
+    );
 
-
-    my $site;
     try {
-        my $site_rs = $self->schema->resultset('Site');
-        $site = $site_rs->find({ id => $site_id });
+        my $site = $self->schema->resultset('Site')->find($site_id);
+        return unless $site;
+
+        $site->delete;
+        return 1;
     } catch {
-        # If there's an error about the theme column
-        if ($_ =~ /Unknown column 'me\.theme'/) {
-            # Log the error
-            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'get_site_details', "Theme column doesn't exist in sites table. Please run the add_theme_column.pl script.");
-
-            # Get site without theme column
-            my $site_rs = $self->schema->resultset('Site');
-            $site = $site_rs->find(
-                { id => $site_id },
-                { columns => [qw(id name description affiliate pid auth_table home_view app_logo app_logo_alt
-                                app_logo_width app_logo_height css_view_name mail_from mail_to mail_to_discussion
-                                mail_to_admin mail_to_user mail_to_client mail_replyto site_display_name
-                                document_root_url link_target http_header_params image_root_url
-                                global_datafiles_directory templates_cache_directory app_datafiles_directory
-                                datasource_type cal_table http_header_description http_header_keywords)] }
-            );
-
-            # Add a default theme property
-            $site->{theme} = $c->model('ThemeConfig')->get_site_theme($c, $site->{name}) if $site;
-
-            # Add a message to the flash
-            $c->flash->{error_msg} = "The theme feature requires a database update. Please run the add_theme_column.pl script.";
-        } else {
-            # For other errors, re-throw
-            die $_;
-        }
+        my $error = $_;
+        $self->logging->log_with_details(
+            $c, 'error', __FILE__, __LINE__, 'delete_site',
+            "Error deleting site: $error"
+        );
+        return;
     };
-
-    return $site;
 }
 
+# Make the class immutable
 __PACKAGE__->meta->make_immutable;
 
 1;
\ No newline at end of file
Index: Comserv/root/static/css/themes/apis.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Theme: apis */\n:root {\n  --accent-color: #FFB900;\n  --background-color: #FFE082;\n  --border-color: #FFD54F;\n  --footer-bg: #FFE082;\n  --footer-text-color: #2C2C2C;\n  --header-bg: #FFE082;\n  --link-color: #B88A00;\n  --link-hover-color: #805F00;\n  --nav-bg: #FFE082;\n  --nav-link-color: #2C2C2C;\n  --nav-text: #2C2C2C;\n  --primary-color: #FFF8E1;\n  --secondary-color: #FFE8B8;\n  --success-color: #27ae60;\n  --table-header-bg: #FFE082;\n  --text-color: #2C2C2C;\n  --warning-color: #f39c12;\n}\n\nbody {\n  background-image: url('../../images/BMaster/honey2.jpg');\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/root/static/css/themes/apis.css b/Comserv/root/static/css/themes/apis.css
--- a/Comserv/root/static/css/themes/apis.css	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/root/static/css/themes/apis.css	(date 1742226436100)
@@ -20,7 +20,6 @@
 }
 
 body {
-  background-image: url('../../images/BMaster/honey2.jpg');
-
+  background-image: url('../../images/BMaster/honey2.jpg'); background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed;
 }
 
Index: Comserv/lib/Comserv/Util/Logging.pm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Comserv::Util::Logging;\n\n# IMPORTANT: Always use this logging system throughout the application.\n# Do NOT create new logging methods or use direct print statements.\n# The preferred logging format is:\n#   $self->logging->log_with_details($c, 'level', __FILE__, __LINE__, 'method_name', \"Message\");\n# Where level can be: 'info', 'debug', 'warn', 'error', etc.\n# This ensures consistent logging with file, line number, and method context.\n#\n# NOTE: This logging system has been updated to prevent recursion issues.\n# It no longer calls Catalyst's logging methods directly, but instead logs to a file\n# and adds messages to the debug_errors array in the stash.\n\nuse strict;\nuse warnings;\nuse namespace::autoclean;\nuse File::Spec;\nuse File::Copy;\nuse FindBin;\nuse File::Path qw(make_path);\nuse Fcntl qw(:flock LOCK_EX LOCK_UN O_WRONLY O_APPEND O_CREAT);\nuse POSIX qw(strftime);\nuse File::Spec;\nuse Fcntl qw(:flock O_WRONLY O_APPEND O_CREAT);\nuse POSIX qw(strftime); # For timestamp formatting\n\nmy $LOG_FH; # Global file handle for logging\nmy $LOG_FILE; # Global log file path\n\nmy $MAX_LOG_SIZE = 100 * 1024; # 100 KB max size for easier AI analysis\nmy $ROTATION_THRESHOLD = 80 * 1024; # Rotate at 80 KB to prevent exceeding max size\nmy $MAX_LOG_FILES = 20; # Maximum number of archived log files to keep\n\n# Declare package variables\nour $LOG_FH;\nour $LOG_FILE;\n# Internal subroutine to print log messages to STDERR and the log file\nsub _print_log {\n    my ($msg) = @_;\n    print STDERR \"$msg\\n\";\n    if (defined $LOG_FH) {\n        flock($LOG_FH, LOCK_EX);\n        print $LOG_FH \"$msg\\n\";\n        flock($LOG_FH, LOCK_UN);\n    }\n}\n\n# Log rotation method\nsub rotate_log {\n    my ($class) = @_;\n    return unless defined $LOG_FILE && -e $LOG_FILE;\n\n    my $file_size = -s $LOG_FILE;\n    _print_log(\"Current log file size: $file_size bytes, max size: $MAX_LOG_SIZE bytes\");\n    return if $file_size < $MAX_LOG_SIZE;\n\n    # Log that we're rotating the file\n    _print_log(\"Log file size ($file_size bytes) exceeds maximum size ($MAX_LOG_SIZE bytes). Rotating log file.\");\n\n    # Generate timestamped filename\n    my $timestamp = strftime(\"%Y%m%d_%H%M%S\", localtime);\n    my ($volume, $directories, $filename) = File::Spec->splitpath($LOG_FILE);\n    my $archive_dir = File::Spec->catdir($directories, 'archive');\n    make_path($archive_dir) unless -d $archive_dir;\n\n    my $archived_log = File::Spec->catfile($archive_dir, \"${filename}_${timestamp}\");\n\n    # Close current log file handle\n    close $LOG_FH if $LOG_FH;\n\n    # For very large files, we'll split them into chunks\n    if ($file_size > $MAX_LOG_SIZE * 2) {\n        _print_log(\"Log file is very large ($file_size bytes). Splitting into chunks of $MAX_LOG_SIZE bytes.\");\n        $archived_log = _split_large_log($LOG_FILE, $archive_dir, $filename, $timestamp, $MAX_LOG_SIZE);\n    } else {\n        # For smaller files, just move the whole file\n        move($LOG_FILE, $archived_log) or die \"Could not rotate log: $!\";\n    }\n\n    # Reopen log file\n    sysopen($LOG_FH, $LOG_FILE, O_WRONLY | O_APPEND | O_CREAT, 0644)\n        or die \"Cannot reopen log file after rotation: $!\";\n\n    # Clean up old log files if we have too many\n    _cleanup_old_logs($archive_dir, $filename);\n\n    _print_log(\"Log rotated: $archived_log\");\n}\n\n# Helper function to clean up old log files\nsub _cleanup_old_logs {\n    my ($archive_dir, $base_filename) = @_;\n\n    # Get all archived log files for this base filename\n    opendir(my $dh, $archive_dir) or do {\n        _print_log(\"Cannot open archive directory $archive_dir: $!\");\n        return;\n    };\n\n    my @log_files = grep { /^${base_filename}_\\d{8}_\\d{6}(_chunk\\d+)?$/ } readdir($dh);\n    closedir($dh);\n\n    # If we have more than MAX_LOG_FILES, delete the oldest ones\n    if (scalar(@log_files) > $MAX_LOG_FILES) {\n        # Extract timestamps from filenames for better sorting\n        my %file_timestamps;\n        foreach my $file (@log_files) {\n            if ($file =~ /^${base_filename}_(\\d{8}_\\d{6})(?:_chunk\\d+)?$/) {\n                $file_timestamps{$file} = $1;\n            } else {\n                # Fallback to modification time if filename doesn't match expected pattern\n                $file_timestamps{$file} = strftime(\"%Y%m%d_%H%M%S\", localtime((stat(File::Spec->catfile($archive_dir, $file)))[9]));\n            }\n        }\n\n        # Sort files by timestamp (oldest first)\n        @log_files = sort {\n            $file_timestamps{$a} cmp $file_timestamps{$b} ||\n            $a cmp $b  # Secondary sort by filename for chunks with same timestamp\n        } @log_files;\n\n        # Delete the oldest files\n        my $files_to_delete = scalar(@log_files) - $MAX_LOG_FILES;\n        for (my $i = 0; $i < $files_to_delete; $i++) {\n            my $file_to_delete = File::Spec->catfile($archive_dir, $log_files[$i]);\n            if (unlink($file_to_delete)) {\n                _print_log(\"Deleted old log file: $file_to_delete\");\n            } else {\n                _print_log(\"Failed to delete old log file: $file_to_delete - $!\");\n            }\n        }\n    }\n}\n\n# Helper function to generate a timestamp\nsub _get_timestamp {\n    return strftime(\"%Y-%m-%d %H:%M:%S\", localtime);\n}\n\n# Initialize the logging system\nsub init {\n    my ($class) = @_;\n\n    # Define the log file path\n    $LOG_FILE = \"$FindBin::Bin/../logs/application.log\";\n    print \"Initializing logging to $LOG_FILE\\n\";\n\n    # Ensure the logs directory exists\n    my $log_dir = \"$FindBin::Bin/../logs\";\n    unless (-d $log_dir) {\n        eval { make_path($log_dir) };\n        if ($@) {\n            _print_log(\"[ERROR] Failed to create log directory $log_dir: $@\");\n            die \"Failed to create log directory $log_dir: $@\\n\";\n        }\n        _print_log(\"Log directory created: $log_dir\");\n    } else {\n        _print_log(\"Log directory exists: $log_dir\");\n    }\n\n    # Open the log file\n    open($LOG_FH, '>>', $LOG_FILE) or do {\n        warn \"Can't open $LOG_FILE: $!\";\n        $LOG_FILE = '/tmp/comserv_app.log'; # Fallback to a temporary location\n        open($LOG_FH, '>>', $LOG_FILE) or warn \"Fallback log failed: $!\";\n    };\n\n    # Ensure the file handle is auto-flushed\n    select((select($LOG_FH), $| = 1)[0]);\n    _print_log(\"Log file opened: $log_file\");\n\n        # Log initialization\n        my $timestamp = strftime(\"%Y-%m-%d %H:%M:%S\", localtime);\n        print $LOG_FH \"[$timestamp] Logging system initialized\\n\";\n    }\n    # Write a test entry to ensure the log file is created\n    print $LOG_FH \"Test log entry\\n\";\n    _print_log(\"Wrote test log entry to file\");\n\n    # Set global log file path for rotation\n    $LOG_FILE = $log_file;\n    _print_log(\"Global log file path set to: $LOG_FILE\");\n\n    return 1;\n    # Log initialization message\n    log_with_details(undef, 'INFO', __FILE__, __LINE__, 'init', \"Logging system initialized with log file: $LOG_FILE\");\n}\n\n# Initialize on load\n__PACKAGE__->init();\n\n# Constructor\nsub new {\n    my ($class) = @_;\n    my $self = bless {}, $class;\n    return $self;\n}\n\n# Singleton-like instance method\nsub instance {\n    my ($class) = @_;\n    return $class->new();\n}\n\n# Log a message with detailed context\nsub log_with_details {\n    my ($self, $c, $level, $file, $line, $subroutine, $message) = @_;\n\n    # Default values\n    $level //= 'INFO';\n    $message //= 'No message provided';\n\n    # Format the log message\n    my $formatted_message = sprintf(\"[%s:%d] %s - %s\",\n                                   $file || 'unknown',\n                                   $line || 0,\n                                   $subroutine || 'unknown',\n                                   $message);\n\n    # Log to file - this is our primary logging mechanism\n    # (rotation is now handled in log_to_file)\n    log_to_file($log_message, undef, $level);\n\n    # Log to Catalyst context if available\n    if ($c && ref($c)) {\n        if ($c->can('log') && $c->log->can($level)) {\n            $c->log->$level($formatted_message);\n        }\n\n        if ($c->can('stash') && ref($c->stash) eq 'HASH') {\n            my $debug_errors = $c->stash->{debug_errors} ||= [];\n            push @$debug_errors, $formatted_message;\n        }\n    # Add to debug_errors in stash if Catalyst context is available\n    # But avoid calling $c->log methods to prevent recursion\n    if ($c && ref($c) && ref($c->stash) eq 'HASH') {\n        my $debug_errors = $c->stash->{debug_errors} ||= [];\n        push @$debug_errors, $log_message;\n    }\n\n    return $formatted_message;\n}\n\n# Log an error message\nsub log_error {\n    my ($self, $c, $file, $line, $error_message) = @_;\n\n    # Default values\n    $error_message //= 'No error message provided';\n\n    # Format the error message\n    my $formatted_message = sprintf(\"[ERROR] %s:%d - %s\",\n                                   $file || 'unknown',\n                                   $line || 0,\n                                   $error_message);\n\n    # Log to file - this is our primary logging mechanism\n    log_to_file($log_message, undef, 'ERROR');\n    # Log to file\n    _write_to_log($formatted_message, 'ERROR');\n\n    # Log to Catalyst context if available\n    if ($c && ref($c)) {\n        if ($c->can('log') && $c->log->can('error')) {\n            $c->log->error($formatted_message);\n        }\n\n    # Add to debug_errors in stash if Catalyst context is available\n    # But avoid calling $c->log methods to prevent recursion\n    if ($c && ref($c) && ref($c->stash) eq 'HASH') {\n        my $debug_errors = $c->stash->{debug_errors} ||= [];\n        push @$debug_errors, $log_message;\n    }\n\n    return $formatted_message;\n}\n\n# Internal function to write to the log file\nsub _write_to_log {\n    my ($message, $level) = @_;\n\n    # Default level\n    $level //= 'INFO';\n# Log a message to a file (defaults to the global log file)\nsub log_to_file {\n    my ($message, $file_path, $level) = @_;\n    $file_path //= $LOG_FILE || File::Spec->catfile($FindBin::Bin, '..', 'logs', 'application.log');\n    $level    //= 'INFO';\n\n    # Make sure logging is initialized\n    unless (defined $LOG_FILE && defined $LOG_FH) {\n        warn \"Logging system not initialized. Initializing now.\";\n        __PACKAGE__->init();\n    # Check file size before writing to ensure we don't exceed max size\n    if (defined $LOG_FILE && $file_path eq $LOG_FILE && -e $file_path) {\n        my $file_size = -s $file_path;\n        if ($file_size >= $ROTATION_THRESHOLD) {\n            _print_log(\"Pre-emptive log rotation triggered: $file_size bytes >= $ROTATION_THRESHOLD bytes\");\n            rotate_log();\n        }\n    }\n\n    # Declare $file with 'my' to fix the scoping issue\n    my $file;\n    unless (open $file, '>>', $file_path) {\n        _print_log(\"Failed to open file: $file_path\\n\");\n        return;\n    }\n\n    # Return if we still don't have a file handle\n    return unless defined $LOG_FH;\n\n    # Add timestamp\n    my $timestamp = strftime(\"%Y-%m-%d %H:%M:%S\", localtime);\n    my $log_entry = \"[$timestamp] [$level] $message\\n\";\n\n    # Write to log file with locking\n    eval {\n        flock($LOG_FH, LOCK_EX);\n        print $LOG_FH $log_entry;\n        flock($LOG_FH, LOCK_UN);\n    };\n\n    if ($@) {\n        warn \"Error writing to log: $@\";\n# DEPRECATED: Don't use this method directly - use log_with_details instead\n# This method is kept for backward compatibility\nsub log_to_catalyst {\n    my ($message, $c) = @_;\n    # Simply log to file to avoid recursion with Catalyst's logging system\n    _print_log(\"CATALYST LOG: $message\");\n    log_to_file(\"CATALYST LOG: $message\");\n}\n\n# Force log rotation regardless of file size\n# This can be called from admin interfaces\nsub force_log_rotation {\n    my ($class) = @_;\n    return unless defined $LOG_FILE && -e $LOG_FILE;\n\n    my $file_size = -s $LOG_FILE;\n    _print_log(\"Manual log rotation requested. Current log file size: $file_size bytes\");\n\n    # Generate timestamped filename base\n    my $timestamp = strftime(\"%Y%m%d_%H%M%S\", localtime);\n    my ($volume, $directories, $filename) = File::Spec->splitpath($LOG_FILE);\n    my $archive_dir = File::Spec->catdir($directories, 'archive');\n    make_path($archive_dir) unless -d $archive_dir;\n\n    # Close current log file handle\n    close $LOG_FH if $LOG_FH;\n\n    # For very large files, we'll split them into chunks\n    my $archived_log;\n\n    if ($file_size > $MAX_LOG_SIZE * 2) {\n        _print_log(\"Log file is very large ($file_size bytes). Splitting into chunks of $MAX_LOG_SIZE bytes.\");\n        $archived_log = _split_large_log($LOG_FILE, $archive_dir, $filename, $timestamp, $MAX_LOG_SIZE);\n    } else {\n        # For smaller files, just move the whole file\n        $archived_log = File::Spec->catfile($archive_dir, \"${filename}_${timestamp}\");\n        move($LOG_FILE, $archived_log) or die \"Could not rotate log: $!\";\n    }\n\n    # Reopen log file\n    sysopen($LOG_FH, $LOG_FILE, O_WRONLY | O_APPEND | O_CREAT, 0644)\n        or die \"Cannot reopen log file after rotation: $!\";\n\n    # Clean up old log files if we have too many\n    _cleanup_old_logs($archive_dir, $filename);\n\n    _print_log(\"Log manually rotated: $archived_log\");\n    return $archived_log;\n}\n\n# Helper function to split a large log file into smaller chunks\nsub _split_large_log {\n    my ($log_file, $archive_dir, $filename, $timestamp, $chunk_size) = @_;\n\n    # Open the original log file for reading\n    open my $in_fh, '<', $log_file or die \"Cannot open log file for reading: $!\";\n\n    # Create a temporary file for the new log\n    my $temp_log = \"${log_file}.new\";\n    open my $new_log_fh, '>', $temp_log or die \"Cannot create new log file: $!\";\n\n    my $chunk_num = 1;\n    my $bytes_read = 0;\n    my $current_chunk_file;\n    my $current_out_fh;\n    my $first_chunk_file;\n\n    # Read the file in chunks\n    while (my $line = <$in_fh>) {\n        $bytes_read += length($line);\n\n        # If we've exceeded the chunk size or this is the first chunk, create a new chunk file\n        if ($bytes_read > $chunk_size || !defined $current_out_fh) {\n            # Close the previous chunk file if it exists\n            if (defined $current_out_fh) {\n                close $current_out_fh;\n            }\n\n            # Create a new chunk file\n            $current_chunk_file = File::Spec->catfile($archive_dir, \"${filename}_${timestamp}_chunk${chunk_num}\");\n            $first_chunk_file //= $current_chunk_file; # Save the first chunk file name\n\n            open $current_out_fh, '>', $current_chunk_file or die \"Cannot create chunk file: $!\";\n            _print_log(\"Created new chunk file: $current_chunk_file\");\n\n            $chunk_num++;\n            $bytes_read = length($line);\n        }\n\n        # Write the line to the current chunk file\n        print $current_out_fh $line;\n    }\n\n    # Close all file handles\n    close $current_out_fh if defined $current_out_fh;\n    close $in_fh;\n    close $new_log_fh;\n\n    # Replace the original log file with the empty new one\n    rename $temp_log, $log_file or die \"Cannot replace log file: $!\";\n\n    return $first_chunk_file;\n}\n\n# Get current log file size in KB\nsub get_log_file_size {\n    my ($class, $custom_path) = @_;\n    my $file_path = $custom_path || $LOG_FILE;\n\n    # If we still don't have a path or the file doesn't exist, return 0\n    return 0 unless defined $file_path && -e $file_path;\n\n    my $size_bytes = -s $file_path;\n    return sprintf(\"%.2f\", $size_bytes / 1024); # Return size in KB\n}\n\n1;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/lib/Comserv/Util/Logging.pm b/Comserv/lib/Comserv/Util/Logging.pm
--- a/Comserv/lib/Comserv/Util/Logging.pm	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/lib/Comserv/Util/Logging.pm	(date 1742226396345)
@@ -24,8 +24,6 @@
 use Fcntl qw(:flock O_WRONLY O_APPEND O_CREAT);
 use POSIX qw(strftime); # For timestamp formatting
 
-my $LOG_FH; # Global file handle for logging
-my $LOG_FILE; # Global log file path
 
 my $MAX_LOG_SIZE = 100 * 1024; # 100 KB max size for easier AI analysis
 my $ROTATION_THRESHOLD = 80 * 1024; # Rotate at 80 KB to prevent exceeding max size
@@ -71,7 +69,8 @@
     # For very large files, we'll split them into chunks
     if ($file_size > $MAX_LOG_SIZE * 2) {
         _print_log("Log file is very large ($file_size bytes). Splitting into chunks of $MAX_LOG_SIZE bytes.");
-        $archived_log = _split_large_log($LOG_FILE, $archive_dir, $filename, $timestamp, $MAX_LOG_SIZE);
+        # Simplified approach - just move the file without splitting
+        move($LOG_FILE, $archived_log) or die "Could not rotate log: $!";
     } else {
         # For smaller files, just move the whole file
         move($LOG_FILE, $archived_log) or die "Could not rotate log: $!";
@@ -167,25 +166,18 @@
 
     # Ensure the file handle is auto-flushed
     select((select($LOG_FH), $| = 1)[0]);
-    _print_log("Log file opened: $log_file");
+    _print_log("Log file opened: $LOG_FILE");
 
-        # Log initialization
-        my $timestamp = strftime("%Y-%m-%d %H:%M:%S", localtime);
-        print $LOG_FH "[$timestamp] Logging system initialized\n";
-    }
+    # Log initialization
+    my $timestamp = strftime("%Y-%m-%d %H:%M:%S", localtime);
+    print $LOG_FH "[$timestamp] Logging system initialized\n";
+
     # Write a test entry to ensure the log file is created
     print $LOG_FH "Test log entry\n";
     _print_log("Wrote test log entry to file");
 
-    # Set global log file path for rotation
-    $LOG_FILE = $log_file;
-    _print_log("Global log file path set to: $LOG_FILE");
-
     return 1;
-    # Log initialization message
-    log_with_details(undef, 'INFO', __FILE__, __LINE__, 'init', "Logging system initialized with log file: $LOG_FILE");
 }
-
 # Initialize on load
 __PACKAGE__->init();
 
@@ -218,30 +210,17 @@
                                    $message);
 
     # Log to file - this is our primary logging mechanism
-    # (rotation is now handled in log_to_file)
-    log_to_file($log_message, undef, $level);
+    log_to_file($formatted_message, undef, $level);
 
     # Log to Catalyst context if available
-    if ($c && ref($c)) {
-        if ($c->can('log') && $c->log->can($level)) {
-            $c->log->$level($formatted_message);
-        }
-
-        if ($c->can('stash') && ref($c->stash) eq 'HASH') {
-            my $debug_errors = $c->stash->{debug_errors} ||= [];
-            push @$debug_errors, $formatted_message;
-        }
-    # Add to debug_errors in stash if Catalyst context is available
-    # But avoid calling $c->log methods to prevent recursion
-    if ($c && ref($c) && ref($c->stash) eq 'HASH') {
-        my $debug_errors = $c->stash->{debug_errors} ||= [];
-        push @$debug_errors, $log_message;
+    if ($c && ref($c) && ref($c->stash) eq 'HASH') {
+        my $debug_errors = $c->stash->{debug_errors} ||= [];
+        push @$debug_errors, $formatted_message;
     }
 
     return $formatted_message;
 }
 
-# Log an error message
 sub log_error {
     my ($self, $c, $file, $line, $error_message) = @_;
 
@@ -255,188 +234,60 @@
                                    $error_message);
 
     # Log to file - this is our primary logging mechanism
-    log_to_file($log_message, undef, 'ERROR');
-    # Log to file
-    _write_to_log($formatted_message, 'ERROR');
-
-    # Log to Catalyst context if available
-    if ($c && ref($c)) {
-        if ($c->can('log') && $c->log->can('error')) {
-            $c->log->error($formatted_message);
-        }
+    log_to_file($formatted_message, undef, 'ERROR');
 
     # Add to debug_errors in stash if Catalyst context is available
-    # But avoid calling $c->log methods to prevent recursion
     if ($c && ref($c) && ref($c->stash) eq 'HASH') {
         my $debug_errors = $c->stash->{debug_errors} ||= [];
-        push @$debug_errors, $log_message;
+        push @$debug_errors, $formatted_message;
     }
 
     return $formatted_message;
 }
 
-# Internal function to write to the log file
-sub _write_to_log {
-    my ($message, $level) = @_;
+# Define the log_dir method
+sub log_dir {
+    my ($self) = @_;
+    my $log_dir = "$FindBin::Bin/../logs";
+
+    # Ensure the logs directory exists
+    unless (-d $log_dir) {
+        eval { make_path($log_dir) };
+        if ($@) {
+            warn "[ERROR] Failed to create log directory $log_dir: $@";
+            # Fallback to /tmp
+            $log_dir = '/tmp';
+        }
+    }
 
-    # Default level
-    $level //= 'INFO';
-# Log a message to a file (defaults to the global log file)
+    return $log_dir;
+}
+
 sub log_to_file {
-    my ($message, $file_path, $level) = @_;
-    $file_path //= $LOG_FILE || File::Spec->catfile($FindBin::Bin, '..', 'logs', 'application.log');
-    $level    //= 'INFO';
-
-    # Make sure logging is initialized
-    unless (defined $LOG_FILE && defined $LOG_FH) {
-        warn "Logging system not initialized. Initializing now.";
-        __PACKAGE__->init();
-    # Check file size before writing to ensure we don't exceed max size
-    if (defined $LOG_FILE && $file_path eq $LOG_FILE && -e $file_path) {
-        my $file_size = -s $file_path;
-        if ($file_size >= $ROTATION_THRESHOLD) {
-            _print_log("Pre-emptive log rotation triggered: $file_size bytes >= $ROTATION_THRESHOLD bytes");
-            rotate_log();
-        }
-    }
+    my ($message, $level, $type) = @_;
+    my $self = __PACKAGE__->instance;
+
+    $level //= 'INFO';
+    $type //= 'general';
 
-    # Declare $file with 'my' to fix the scoping issue
-    my $file;
-    unless (open $file, '>>', $file_path) {
-        _print_log("Failed to open file: $file_path\n");
-        return;
-    }
-
-    # Return if we still don't have a file handle
-    return unless defined $LOG_FH;
-
-    # Add timestamp
-    my $timestamp = strftime("%Y-%m-%d %H:%M:%S", localtime);
-    my $log_entry = "[$timestamp] [$level] $message\n";
+    eval {
+        # Use simple timestamp instead of DateTime to avoid dependencies
+        my $timestamp = strftime("%Y-%m-%d %H:%M:%S", localtime);
+        my $date = strftime("%Y-%m-%d", localtime);
+
+        my $log_file = File::Spec->catfile(
+            $self->log_dir,
+            "${type}_${date}.log"
+        );
 
-    # Write to log file with locking
-    eval {
-        flock($LOG_FH, LOCK_EX);
-        print $LOG_FH $log_entry;
-        flock($LOG_FH, LOCK_UN);
+        open my $fh, '>>', $log_file or die "Cannot open log file $log_file: $!";
+        print $fh "[$timestamp] [$level] $message\n";
+        close $fh;
+
+        return 1;
     };
-
     if ($@) {
-        warn "Error writing to log: $@";
-# DEPRECATED: Don't use this method directly - use log_with_details instead
-# This method is kept for backward compatibility
-sub log_to_catalyst {
-    my ($message, $c) = @_;
-    # Simply log to file to avoid recursion with Catalyst's logging system
-    _print_log("CATALYST LOG: $message");
-    log_to_file("CATALYST LOG: $message");
-}
-
-# Force log rotation regardless of file size
-# This can be called from admin interfaces
-sub force_log_rotation {
-    my ($class) = @_;
-    return unless defined $LOG_FILE && -e $LOG_FILE;
-
-    my $file_size = -s $LOG_FILE;
-    _print_log("Manual log rotation requested. Current log file size: $file_size bytes");
-
-    # Generate timestamped filename base
-    my $timestamp = strftime("%Y%m%d_%H%M%S", localtime);
-    my ($volume, $directories, $filename) = File::Spec->splitpath($LOG_FILE);
-    my $archive_dir = File::Spec->catdir($directories, 'archive');
-    make_path($archive_dir) unless -d $archive_dir;
-
-    # Close current log file handle
-    close $LOG_FH if $LOG_FH;
-
-    # For very large files, we'll split them into chunks
-    my $archived_log;
-
-    if ($file_size > $MAX_LOG_SIZE * 2) {
-        _print_log("Log file is very large ($file_size bytes). Splitting into chunks of $MAX_LOG_SIZE bytes.");
-        $archived_log = _split_large_log($LOG_FILE, $archive_dir, $filename, $timestamp, $MAX_LOG_SIZE);
-    } else {
-        # For smaller files, just move the whole file
-        $archived_log = File::Spec->catfile($archive_dir, "${filename}_${timestamp}");
-        move($LOG_FILE, $archived_log) or die "Could not rotate log: $!";
+        warn "Failed to write to log file: $@";
+        return 0;
     }
-
-    # Reopen log file
-    sysopen($LOG_FH, $LOG_FILE, O_WRONLY | O_APPEND | O_CREAT, 0644)
-        or die "Cannot reopen log file after rotation: $!";
-
-    # Clean up old log files if we have too many
-    _cleanup_old_logs($archive_dir, $filename);
-
-    _print_log("Log manually rotated: $archived_log");
-    return $archived_log;
 }
-
-# Helper function to split a large log file into smaller chunks
-sub _split_large_log {
-    my ($log_file, $archive_dir, $filename, $timestamp, $chunk_size) = @_;
-
-    # Open the original log file for reading
-    open my $in_fh, '<', $log_file or die "Cannot open log file for reading: $!";
-
-    # Create a temporary file for the new log
-    my $temp_log = "${log_file}.new";
-    open my $new_log_fh, '>', $temp_log or die "Cannot create new log file: $!";
-
-    my $chunk_num = 1;
-    my $bytes_read = 0;
-    my $current_chunk_file;
-    my $current_out_fh;
-    my $first_chunk_file;
-
-    # Read the file in chunks
-    while (my $line = <$in_fh>) {
-        $bytes_read += length($line);
-
-        # If we've exceeded the chunk size or this is the first chunk, create a new chunk file
-        if ($bytes_read > $chunk_size || !defined $current_out_fh) {
-            # Close the previous chunk file if it exists
-            if (defined $current_out_fh) {
-                close $current_out_fh;
-            }
-
-            # Create a new chunk file
-            $current_chunk_file = File::Spec->catfile($archive_dir, "${filename}_${timestamp}_chunk${chunk_num}");
-            $first_chunk_file //= $current_chunk_file; # Save the first chunk file name
-
-            open $current_out_fh, '>', $current_chunk_file or die "Cannot create chunk file: $!";
-            _print_log("Created new chunk file: $current_chunk_file");
-
-            $chunk_num++;
-            $bytes_read = length($line);
-        }
-
-        # Write the line to the current chunk file
-        print $current_out_fh $line;
-    }
-
-    # Close all file handles
-    close $current_out_fh if defined $current_out_fh;
-    close $in_fh;
-    close $new_log_fh;
-
-    # Replace the original log file with the empty new one
-    rename $temp_log, $log_file or die "Cannot replace log file: $!";
-
-    return $first_chunk_file;
-}
-
-# Get current log file size in KB
-sub get_log_file_size {
-    my ($class, $custom_path) = @_;
-    my $file_path = $custom_path || $LOG_FILE;
-
-    # If we still don't have a path or the file doesn't exist, return 0
-    return 0 unless defined $file_path && -e $file_path;
-
-    my $size_bytes = -s $file_path;
-    return sprintf("%.2f", $size_bytes / 1024); # Return size in KB
-}
-
-1;
\ No newline at end of file
Index: Comserv/root/setup/DefaultDBI.tt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[% ViewVersion = 'v 0.02 2024/05/01 setup/DefaultDBI.tt'  %]\n[% IF data.debug == 1 %]\n <p>[% ViewVersion %] </p>\n Using application database connection\n[% END %]\n\n[%# This file provides database access for templates through the application's models\n    instead of direct DBI connections. This ensures that all database connections\n    use the same configuration and credentials. %]\n\n[% MACRO get_data(model_name, method_name, params) BLOCK %]\n    [% # This macro allows templates to get data from models\n       # Usage: [% data = INCLUDE get_data('ModelName', 'method_name', {param1 => 'value1'}) %]\n\n       # Call the appropriate model method through the Catalyst context\n       result = c.model(model_name).$method_name(params);\n\n       # Return the result\n       result;\n    %]\n[% END %]\n\n[% MACRO execute_query(database, query) BLOCK %]\n    [% # This macro allows templates to execute custom queries through the RemoteDB model\n       # Usage: [% results = INCLUDE execute_query('DBName', 'SELECT * FROM table') %]\n\n       # Use the RemoteDB model to execute the query\n       IF database == 'ENCY' || database == 'ency' %]\n           [% results = c.model('DBEncy').schema.storage.dbh.selectall_arrayref(query, { Slice => {} }) %]\n       [% ELSIF database == 'FORAGER' || database == 'forager' %]\n           [% results = c.model('DBForager').schema.storage.dbh.selectall_arrayref(query, { Slice => {} }) %]\n       [% ELSE %]\n           [% # For remote databases, use the RemoteDB model\n              results = c.model('RemoteDB').execute_query(c, database, query, []) %]\n       [% END %]\n\n       # Return the results\n       results;\n    %]\n[% END %]
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/root/setup/DefaultDBI.tt b/Comserv/root/setup/DefaultDBI.tt
--- a/Comserv/root/setup/DefaultDBI.tt	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/root/setup/DefaultDBI.tt	(date 1742226396358)
@@ -25,14 +25,14 @@
        # Usage: [% results = INCLUDE execute_query('DBName', 'SELECT * FROM table') %]
 
        # Use the RemoteDB model to execute the query
-       IF database == 'ENCY' || database == 'ency' %]
-           [% results = c.model('DBEncy').schema.storage.dbh.selectall_arrayref(query, { Slice => {} }) %]
-       [% ELSIF database == 'FORAGER' || database == 'forager' %]
-           [% results = c.model('DBForager').schema.storage.dbh.selectall_arrayref(query, { Slice => {} }) %]
-       [% ELSE %]
-           [% # For remote databases, use the RemoteDB model
-              results = c.model('RemoteDB').execute_query(c, database, query, []) %]
-       [% END %]
+       IF database == 'ENCY' || database == 'ency';
+           results = c.model('DBEncy').schema.storage.dbh.selectall_arrayref(query, { Slice => {} });
+       ELSIF database == 'FORAGER' || database == 'forager';
+           results = c.model('DBForager').schema.storage.dbh.selectall_arrayref(query, { Slice => {} });
+       ELSE;
+           # For remote databases, use the RemoteDB model
+           results = c.model('RemoteDB').execute_query(c, database, query, []);
+       END;
 
        # Return the results
        results;
Index: Comserv/root/Documentation/site_domain_resolution.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/root/Documentation/site_domain_resolution.md b/Comserv/root/Documentation/site_domain_resolution.md
new file mode 100644
--- /dev/null	(date 1742226357251)
+++ b/Comserv/root/Documentation/site_domain_resolution.md	(date 1742226357251)
@@ -0,0 +1,104 @@
+# Site Domain Resolution Guide
+
+## Overview
+
+This document explains how the Comserv application resolves domains to sites and common issues that can occur in this process.
+
+## How Domain Resolution Works
+
+1. When a request comes in, the `Root` controller's `auto` method calls `setup_site`.
+2. The `setup_site` method extracts the domain from the request.
+3. If no site name is set in the session, it looks up the domain in the `sitedomain` table.
+4. If a matching domain is found, it retrieves the associated site details.
+5. The site's name and home_view are used to determine which controller should handle the request.
+
+## Common Issues
+
+### 1. Parameter Order Mismatch
+
+One recurring issue is a parameter order mismatch in the `get_site_details` method call. The correct order is:
+
+```perl
+$c->model('Site')->get_site_details($c, $site_id);
+```
+
+Incorrect order:
+
+```perl
+$c->model('Site')->get_site_details($site_id, $c);  # WRONG!
+```
+
+This causes the site details to not be retrieved correctly, resulting in all sites showing the default home page.
+
+### 2. Missing Domain in sitedomain Table
+
+If a domain is not found in the `sitedomain` table, the application will fall back to the default site.
+
+### 3. Incorrect home_view Setting
+
+If a site's `home_view` field is set to a controller that doesn't exist, the application will fall back to the Root controller.
+
+## How to Fix Domain Resolution Issues
+
+### 1. Check Parameter Order
+
+Ensure all calls to `get_site_details` have the correct parameter order: context first, then site ID.
+
+### 2. Verify Domain in Database
+
+Make sure the domain is properly added to the `sitedomain` table and associated with the correct site ID.
+
+```sql
+SELECT * FROM sitedomain WHERE domain = 'example.com';
+```
+
+### 3. Check Site Configuration
+
+Verify that the site record has the correct `home_view` value:
+
+```sql
+SELECT id, name, home_view FROM sites WHERE id = [site_id];
+```
+
+### 4. Enable Debug Mode
+
+Enable debug mode to see detailed logging about the domain resolution process:
+
+```
+http://yourdomain.com/?debug=1
+```
+
+### 5. Check Controller Existence
+
+Make sure the controller specified in `home_view` actually exists and is properly configured.
+
+## Preventing Future Issues
+
+1. **Use Consistent Parameter Order**: Always follow the convention of passing the context (`$c`) as the first parameter.
+
+2. **Add Validation**: Consider adding parameter validation to critical methods to catch incorrect parameter order.
+
+3. **Use Named Parameters**: For complex methods, consider using named parameters:
+
+```perl
+$c->model('Site')->get_site_details(
+    context => $c,
+    site_id => $site_id
+);
+```
+
+4. **Regular Testing**: Periodically test all domains to ensure they resolve to the correct sites.
+
+5. **Documentation**: Keep this documentation updated with any changes to the domain resolution process.
+
+## Troubleshooting Steps
+
+If a site is showing the default home page instead of the expected content:
+
+1. Reset your session: `/reset_session`
+2. Enable debug mode: `?debug=1`
+3. Check the logs for domain resolution errors
+4. Verify the domain exists in the `sitedomain` table
+5. Check that the site's `home_view` points to a valid controller
+6. Ensure the controller's namespace is correctly set
+7. Verify the controller's index method is properly defined
\ No newline at end of file
Index: Comserv/root/Documentation/completed_items.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"completed_items\":[{\"status\":\"completed\",\"commit\":\"theme_editor_ui_improvements\",\"item\":\"Enhanced Theme Editor UI - Added tabbed interface and improved color pickers\",\"date_completed\":\"2024-06-13\",\"date_created\":\"2024-06-13\"},{\"date_created\":\"2024-06-14\",\"date_completed\":\"2024-06-14\",\"status\":\"completed\",\"item\":\"Improved Theme Editor Preview Layout - Made preview match actual site layout and fixed styling issues\",\"commit\":\"theme_editor_layout_match\"},{\"date_created\":\"2024-06-14\",\"item\":\"Enhanced Theme Editor Font Selectors - Added visual font previews and fixed background display\",\"commit\":\"theme_editor_visual_fonts\",\"status\":\"completed\",\"date_completed\":\"2024-06-14\"},{\"date_created\":\"2024-06-14\",\"date_completed\":\"2024-06-14\",\"status\":\"completed\",\"commit\":\"theme_editor_advanced_text\",\"item\":\"Enhanced Theme Editor Text Options - Added detailed text styling with font selectors and site name customization\"},{\"date_completed\":\"2024-06-14\",\"commit\":\"theme_editor_realistic_preview\",\"item\":\"Enhanced Theme Editor Preview - Made preview match actual page layout and fixed background display\",\"status\":\"completed\",\"date_created\":\"2024-06-14\"},{\"date_completed\":\"2024-06-14\",\"status\":\"completed\",\"item\":\"Added Interactive Preview to Theme Editor - Made preview elements clickable to navigate to their settings\",\"commit\":\"theme_editor_interactive_preview\",\"date_created\":\"2024-06-14\"},{\"status\":\"completed\",\"commit\":\"theme_editor_ui_improvements\",\"item\":\"Enhanced Theme Editor UI - Added sticky preview and improved background display\",\"date_completed\":\"2024-06-13\",\"date_created\":\"2024-06-13\"},{\"date_completed\":\"2024-06-13\",\"status\":\"completed\",\"commit\":\"theme_editor_file_browser\",\"item\":\"Added File Browser to Theme Editor - Simplified image selection with visual browser\",\"date_created\":\"2024-06-13\"},{\"date_completed\":\"2024-06-12\",\"status\":\"completed\",\"commit\":\"theme_editor_background\",\"item\":\"Enhanced Theme Editor - Added support for background images and special styles\",\"date_created\":\"2024-06-12\"},{\"date_created\":\"2024-06-11\",\"date_completed\":\"2024-06-11\",\"commit\":\"theme_editor_links\",\"item\":\"Fixed Theme Editor Links - Added direct links for better navigation\",\"status\":\"completed\"},{\"date_completed\":\"2024-06-10\",\"commit\":\"theme_editor_templates\",\"item\":\"Fixed Theme Editor Templates - Corrected template syntax for hyphenated variable names\",\"status\":\"completed\",\"date_created\":\"2024-06-10\"},{\"item\":\"Fixed Theme Editor File Paths - Ensured the theme files are found correctly\",\"commit\":\"theme_editor_paths\",\"status\":\"completed\",\"date_completed\":\"2024-06-09\",\"date_created\":\"2024-06-09\"},{\"date_created\":\"2024-06-08\",\"date_completed\":\"2024-06-08\",\"status\":\"completed\",\"commit\":\"theme_editor_routing\",\"item\":\"Fixed Theme Editor Routing - Ensured the Advanced Theme Editor is accessible\"},{\"date_created\":\"2024-06-07\",\"date_completed\":\"2024-06-07\",\"status\":\"completed\",\"commit\":\"theme_application\",\"item\":\"Fixed Theme Application - Ensured themes are properly applied to all pages\"},{\"date_created\":\"2024-06-06\",\"date_completed\":\"2024-06-06\",\"status\":\"completed\",\"item\":\"Added Theme Editor - Created advanced interface for editing theme definitions\",\"commit\":\"theme_editor\"},{\"date_created\":\"2024-06-05\",\"status\":\"completed\",\"item\":\"Fixed Theme Previews and Selection - Ensured all themes are available and properly displayed\",\"commit\":\"fixed_theme_previews\",\"date_completed\":\"2024-06-05\"},{\"date_completed\":\"2024-06-04\",\"status\":\"completed\",\"item\":\"Fixed JSON-Based Theme System - Updated to match original CSS files exactly\",\"commit\":\"fixed_json_theme_system\",\"date_created\":\"2024-06-04\"},{\"date_created\":\"2024-06-03\",\"date_completed\":\"2024-06-03\",\"status\":\"completed\",\"commit\":\"enhanced_json_theme_system\",\"item\":\"Enhanced JSON-Based Theme System - Added support for legacy elements and background images\"},{\"date_created\":\"2024-06-02\",\"item\":\"JSON-Based Theme System - Implemented structured theme storage and management\",\"commit\":\"json_theme_system\",\"status\":\"completed\",\"date_completed\":\"2024-06-02\"},{\"status\":\"completed\",\"item\":\"Theme Preview System - Implemented accurate theme previews and updated documentation\",\"commit\":\"theme_preview_system\",\"date_completed\":\"2024-06-01\",\"date_created\":\"2024-06-01\"},{\"date_completed\":\"2024-05-31\",\"commit\":\"a1b2c3d4\",\"item\":\"Documentation Workflow Guidelines - Improved workflow order and added new fields information\",\"status\":\"completed\",\"date_created\":\"2024-05-31\"},{\"date_created\":\"2024-05-31\",\"date_completed\":\"2024-05-31\",\"item\":\"Documentation Workflow Guidelines - Created comprehensive workflow for maintaining documentation\",\"commit\":\"a1b2c3d4\",\"status\":\"completed\"},{\"date_created\":\"2024-05-31\",\"item\":\"Enhanced Documentation System - Added collapsible sections and improved application start tracking\",\"commit\":\"a1b2c3d4\",\"status\":\"completed\",\"date_completed\":\"2024-05-31\"},{\"date_created\":\"2024-05-30\",\"status\":\"completed\",\"commit\":\"a1b2c3d4e5f6\",\"item\":\"Theme System Documentation - Comprehensive guide to the new theme system\",\"date_completed\":\"2024-05-30\"},{\"date_created\":\"2024-05-28\",\"date_completed\":\"2024-05-28\",\"commit\":\"f6e5d4c3b2a1\",\"item\":\"Administrator Guide - Updated with new admin features\",\"status\":\"completed\"},{\"date_created\":\"2024-05-25\",\"commit\":\"1a2b3c4d5e6f\",\"item\":\"Database Schema - Updated with new tables and relationships\",\"status\":\"completed\",\"date_completed\":\"2024-05-25\"},{\"date_created\":\"2024-05-24\",\"item\":\"Created the Git Workflow guidelines section\",\"status\":\"completed\",\"date_completed\":\"2024-05-24\"},{\"date_completed\":\"2024-05-24\",\"item\":\"Added the Testing Guidelines section\",\"status\":\"completed\",\"date_created\":\"2024-05-24\"},{\"date_created\":\"2024-05-24\",\"date_completed\":\"2024-05-24\",\"item\":\"Rewrite the Git workflow guidelines in guidelines.tt to include a definition of what is meant by \\\"Git workflow\\\" and outline the specific steps developers should follow to ensure a smooth and effective Git-based development process.\",\"status\":\"completed\"},{\"date_created\":\"2024-05-24\",\"date_completed\":\"2024-05-24\",\"item\":\"Create a Git commit based on the completed items, following the Git Workflow guidelines.\",\"commit\":\"7g8h9i0j1k2l\",\"status\":\"completed\"},{\"date_completed\":\"2024-05-24\",\"item\":\"Create a place to track completed items, such as a new file, a table, or a JSON file.\",\"status\":\"completed\",\"date_created\":\"2024-05-24\"},{\"date_completed\":\"2024-05-24\",\"item\":\"Once commit is done move the items from to the completed_items.json. Create new fields for date_completed and date_created.\",\"status\":\"completed\",\"date_created\":\"2024-05-24\"},{\"date_created\":\"2025-03-16\",\"date_completed\":\"2025-03-16\",\"status\":\"completed\",\"commit\":\"system\",\"item\":\"Application started on 2025-03-16\"}]}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/root/Documentation/completed_items.json b/Comserv/root/Documentation/completed_items.json
--- a/Comserv/root/Documentation/completed_items.json	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/root/Documentation/completed_items.json	(date 1742226396323)
@@ -1,1 +1,1 @@
-{"completed_items":[{"status":"completed","commit":"theme_editor_ui_improvements","item":"Enhanced Theme Editor UI - Added tabbed interface and improved color pickers","date_completed":"2024-06-13","date_created":"2024-06-13"},{"date_created":"2024-06-14","date_completed":"2024-06-14","status":"completed","item":"Improved Theme Editor Preview Layout - Made preview match actual site layout and fixed styling issues","commit":"theme_editor_layout_match"},{"date_created":"2024-06-14","item":"Enhanced Theme Editor Font Selectors - Added visual font previews and fixed background display","commit":"theme_editor_visual_fonts","status":"completed","date_completed":"2024-06-14"},{"date_created":"2024-06-14","date_completed":"2024-06-14","status":"completed","commit":"theme_editor_advanced_text","item":"Enhanced Theme Editor Text Options - Added detailed text styling with font selectors and site name customization"},{"date_completed":"2024-06-14","commit":"theme_editor_realistic_preview","item":"Enhanced Theme Editor Preview - Made preview match actual page layout and fixed background display","status":"completed","date_created":"2024-06-14"},{"date_completed":"2024-06-14","status":"completed","item":"Added Interactive Preview to Theme Editor - Made preview elements clickable to navigate to their settings","commit":"theme_editor_interactive_preview","date_created":"2024-06-14"},{"status":"completed","commit":"theme_editor_ui_improvements","item":"Enhanced Theme Editor UI - Added sticky preview and improved background display","date_completed":"2024-06-13","date_created":"2024-06-13"},{"date_completed":"2024-06-13","status":"completed","commit":"theme_editor_file_browser","item":"Added File Browser to Theme Editor - Simplified image selection with visual browser","date_created":"2024-06-13"},{"date_completed":"2024-06-12","status":"completed","commit":"theme_editor_background","item":"Enhanced Theme Editor - Added support for background images and special styles","date_created":"2024-06-12"},{"date_created":"2024-06-11","date_completed":"2024-06-11","commit":"theme_editor_links","item":"Fixed Theme Editor Links - Added direct links for better navigation","status":"completed"},{"date_completed":"2024-06-10","commit":"theme_editor_templates","item":"Fixed Theme Editor Templates - Corrected template syntax for hyphenated variable names","status":"completed","date_created":"2024-06-10"},{"item":"Fixed Theme Editor File Paths - Ensured the theme files are found correctly","commit":"theme_editor_paths","status":"completed","date_completed":"2024-06-09","date_created":"2024-06-09"},{"date_created":"2024-06-08","date_completed":"2024-06-08","status":"completed","commit":"theme_editor_routing","item":"Fixed Theme Editor Routing - Ensured the Advanced Theme Editor is accessible"},{"date_created":"2024-06-07","date_completed":"2024-06-07","status":"completed","commit":"theme_application","item":"Fixed Theme Application - Ensured themes are properly applied to all pages"},{"date_created":"2024-06-06","date_completed":"2024-06-06","status":"completed","item":"Added Theme Editor - Created advanced interface for editing theme definitions","commit":"theme_editor"},{"date_created":"2024-06-05","status":"completed","item":"Fixed Theme Previews and Selection - Ensured all themes are available and properly displayed","commit":"fixed_theme_previews","date_completed":"2024-06-05"},{"date_completed":"2024-06-04","status":"completed","item":"Fixed JSON-Based Theme System - Updated to match original CSS files exactly","commit":"fixed_json_theme_system","date_created":"2024-06-04"},{"date_created":"2024-06-03","date_completed":"2024-06-03","status":"completed","commit":"enhanced_json_theme_system","item":"Enhanced JSON-Based Theme System - Added support for legacy elements and background images"},{"date_created":"2024-06-02","item":"JSON-Based Theme System - Implemented structured theme storage and management","commit":"json_theme_system","status":"completed","date_completed":"2024-06-02"},{"status":"completed","item":"Theme Preview System - Implemented accurate theme previews and updated documentation","commit":"theme_preview_system","date_completed":"2024-06-01","date_created":"2024-06-01"},{"date_completed":"2024-05-31","commit":"a1b2c3d4","item":"Documentation Workflow Guidelines - Improved workflow order and added new fields information","status":"completed","date_created":"2024-05-31"},{"date_created":"2024-05-31","date_completed":"2024-05-31","item":"Documentation Workflow Guidelines - Created comprehensive workflow for maintaining documentation","commit":"a1b2c3d4","status":"completed"},{"date_created":"2024-05-31","item":"Enhanced Documentation System - Added collapsible sections and improved application start tracking","commit":"a1b2c3d4","status":"completed","date_completed":"2024-05-31"},{"date_created":"2024-05-30","status":"completed","commit":"a1b2c3d4e5f6","item":"Theme System Documentation - Comprehensive guide to the new theme system","date_completed":"2024-05-30"},{"date_created":"2024-05-28","date_completed":"2024-05-28","commit":"f6e5d4c3b2a1","item":"Administrator Guide - Updated with new admin features","status":"completed"},{"date_created":"2024-05-25","commit":"1a2b3c4d5e6f","item":"Database Schema - Updated with new tables and relationships","status":"completed","date_completed":"2024-05-25"},{"date_created":"2024-05-24","item":"Created the Git Workflow guidelines section","status":"completed","date_completed":"2024-05-24"},{"date_completed":"2024-05-24","item":"Added the Testing Guidelines section","status":"completed","date_created":"2024-05-24"},{"date_created":"2024-05-24","date_completed":"2024-05-24","item":"Rewrite the Git workflow guidelines in guidelines.tt to include a definition of what is meant by \"Git workflow\" and outline the specific steps developers should follow to ensure a smooth and effective Git-based development process.","status":"completed"},{"date_created":"2024-05-24","date_completed":"2024-05-24","item":"Create a Git commit based on the completed items, following the Git Workflow guidelines.","commit":"7g8h9i0j1k2l","status":"completed"},{"date_completed":"2024-05-24","item":"Create a place to track completed items, such as a new file, a table, or a JSON file.","status":"completed","date_created":"2024-05-24"},{"date_completed":"2024-05-24","item":"Once commit is done move the items from to the completed_items.json. Create new fields for date_completed and date_created.","status":"completed","date_created":"2024-05-24"},{"date_created":"2025-03-16","date_completed":"2025-03-16","status":"completed","commit":"system","item":"Application started on 2025-03-16"}]}
\ No newline at end of file
+{"completed_items":[{"date_created":"2024-06-13","date_completed":"2024-06-13","status":"completed","commit":"theme_editor_ui_improvements","item":"Enhanced Theme Editor UI - Added tabbed interface and improved color pickers"},{"item":"Improved Theme Editor Preview Layout - Made preview match actual site layout and fixed styling issues","commit":"theme_editor_layout_match","status":"completed","date_completed":"2024-06-14","date_created":"2024-06-14"},{"date_created":"2024-06-14","date_completed":"2024-06-14","commit":"theme_editor_visual_fonts","item":"Enhanced Theme Editor Font Selectors - Added visual font previews and fixed background display","status":"completed"},{"date_completed":"2024-06-14","date_created":"2024-06-14","status":"completed","item":"Enhanced Theme Editor Text Options - Added detailed text styling with font selectors and site name customization","commit":"theme_editor_advanced_text"},{"commit":"theme_editor_realistic_preview","item":"Enhanced Theme Editor Preview - Made preview match actual page layout and fixed background display","status":"completed","date_created":"2024-06-14","date_completed":"2024-06-14"},{"commit":"theme_editor_interactive_preview","item":"Added Interactive Preview to Theme Editor - Made preview elements clickable to navigate to their settings","status":"completed","date_created":"2024-06-14","date_completed":"2024-06-14"},{"status":"completed","item":"Enhanced Theme Editor UI - Added sticky preview and improved background display","commit":"theme_editor_ui_improvements","date_completed":"2024-06-13","date_created":"2024-06-13"},{"date_created":"2024-06-13","date_completed":"2024-06-13","status":"completed","commit":"theme_editor_file_browser","item":"Added File Browser to Theme Editor - Simplified image selection with visual browser"},{"date_created":"2024-06-12","date_completed":"2024-06-12","commit":"theme_editor_background","item":"Enhanced Theme Editor - Added support for background images and special styles","status":"completed"},{"status":"completed","item":"Fixed Theme Editor Links - Added direct links for better navigation","commit":"theme_editor_links","date_completed":"2024-06-11","date_created":"2024-06-11"},{"date_completed":"2024-06-10","date_created":"2024-06-10","status":"completed","item":"Fixed Theme Editor Templates - Corrected template syntax for hyphenated variable names","commit":"theme_editor_templates"},{"date_completed":"2024-06-09","date_created":"2024-06-09","item":"Fixed Theme Editor File Paths - Ensured the theme files are found correctly","commit":"theme_editor_paths","status":"completed"},{"date_completed":"2024-06-08","date_created":"2024-06-08","item":"Fixed Theme Editor Routing - Ensured the Advanced Theme Editor is accessible","commit":"theme_editor_routing","status":"completed"},{"date_completed":"2024-06-07","date_created":"2024-06-07","status":"completed","item":"Fixed Theme Application - Ensured themes are properly applied to all pages","commit":"theme_application"},{"item":"Added Theme Editor - Created advanced interface for editing theme definitions","commit":"theme_editor","status":"completed","date_completed":"2024-06-06","date_created":"2024-06-06"},{"date_completed":"2024-06-05","date_created":"2024-06-05","status":"completed","item":"Fixed Theme Previews and Selection - Ensured all themes are available and properly displayed","commit":"fixed_theme_previews"},{"item":"Fixed JSON-Based Theme System - Updated to match original CSS files exactly","commit":"fixed_json_theme_system","status":"completed","date_completed":"2024-06-04","date_created":"2024-06-04"},{"date_created":"2024-06-03","date_completed":"2024-06-03","commit":"enhanced_json_theme_system","item":"Enhanced JSON-Based Theme System - Added support for legacy elements and background images","status":"completed"},{"commit":"json_theme_system","item":"JSON-Based Theme System - Implemented structured theme storage and management","status":"completed","date_created":"2024-06-02","date_completed":"2024-06-02"},{"status":"completed","item":"Theme Preview System - Implemented accurate theme previews and updated documentation","commit":"theme_preview_system","date_completed":"2024-06-01","date_created":"2024-06-01"},{"commit":"a1b2c3d4","item":"Documentation Workflow Guidelines - Improved workflow order and added new fields information","status":"completed","date_created":"2024-05-31","date_completed":"2024-05-31"},{"date_completed":"2024-05-31","date_created":"2024-05-31","item":"Documentation Workflow Guidelines - Created comprehensive workflow for maintaining documentation","commit":"a1b2c3d4","status":"completed"},{"commit":"a1b2c3d4","item":"Enhanced Documentation System - Added collapsible sections and improved application start tracking","status":"completed","date_created":"2024-05-31","date_completed":"2024-05-31"},{"date_completed":"2024-05-30","date_created":"2024-05-30","status":"completed","item":"Theme System Documentation - Comprehensive guide to the new theme system","commit":"a1b2c3d4e5f6"},{"status":"completed","item":"Administrator Guide - Updated with new admin features","commit":"f6e5d4c3b2a1","date_completed":"2024-05-28","date_created":"2024-05-28"},{"date_completed":"2024-05-25","date_created":"2024-05-25","item":"Database Schema - Updated with new tables and relationships","commit":"1a2b3c4d5e6f","status":"completed"},{"status":"completed","item":"Created the Git Workflow guidelines section","date_completed":"2024-05-24","date_created":"2024-05-24"},{"date_completed":"2024-05-24","date_created":"2024-05-24","status":"completed","item":"Added the Testing Guidelines section"},{"date_created":"2024-05-24","date_completed":"2024-05-24","status":"completed","item":"Rewrite the Git workflow guidelines in guidelines.tt to include a definition of what is meant by \"Git workflow\" and outline the specific steps developers should follow to ensure a smooth and effective Git-based development process."},{"date_created":"2024-05-24","date_completed":"2024-05-24","status":"completed","commit":"7g8h9i0j1k2l","item":"Create a Git commit based on the completed items, following the Git Workflow guidelines."},{"date_completed":"2024-05-24","date_created":"2024-05-24","item":"Create a place to track completed items, such as a new file, a table, or a JSON file.","status":"completed"},{"date_completed":"2024-05-24","date_created":"2024-05-24","item":"Once commit is done move the items from to the completed_items.json. Create new fields for date_completed and date_created.","status":"completed"},{"commit":"system","item":"Application started on 2025-03-17","status":"completed","date_created":"2025-03-17","date_completed":"2025-03-17"}]}
\ No newline at end of file
Index: Comserv/lib/Comserv/Controller/Documentation.pm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Comserv::Controller::Documentation;\nuse Moose;\nuse namespace::autoclean;\nuse Comserv::Util::Logging;\nuse File::Find;\nuse File::Basename;\n\nBEGIN { extends 'Catalyst::Controller'; }\n\nhas 'logging' => (\n    is => 'ro',\n    default => sub { Comserv::Util::Logging->instance }\n);\n\n# Store documentation pages\nhas 'documentation_pages' => (\n    is => 'ro',\n    default => sub { {} },\n    lazy => 1,\n);\n\n# Initialize - scan for documentation files\nsub BUILD {\n    my ($self) = @_;\n\n    # Log the start of BUILD\n    my $file = __FILE__;\n    my $line = __LINE__;\n    Comserv::Util::Logging::log_to_file(\"[$file:$line] Starting BUILD method for Documentation controller\", undef, 'INFO');\n\n    # Scan the Documentation directory for all files\n    my $doc_dir = \"root/Documentation\";\n    if (-d $doc_dir) {\n        find(\n            {\n                wanted => sub {\n                    my $file = $_;\n                    # Skip directories\n                    return if -d $file;\n\n                    my $basename = basename($file);\n                    my $path = $File::Find::name;\n                    $path =~ s/^root\\///; # Remove 'root/' prefix\n\n                    # Create a safe key for the documentation_pages hash\n                    my $key;\n\n                    # Handle .tt files\n                    if ($file =~ /\\.tt$/) {\n                        $key = basename($file, '.tt');\n                    } else {\n                        # Handle other file types (json, md, etc.)\n                        my ($name, $ext) = split(/\\./, $basename, 2);\n                        if ($ext) {\n                            $key = \"${name}_${ext}\";\n                        } else {\n                            $key = $basename;\n                        }\n                    }\n\n                    # Store the path with the key\n                    $self->documentation_pages->{$key} = $path;\n                },\n                no_chdir => 1,\n            },\n            $doc_dir\n        );\n    }\n\n    # Log the discovered documentation pages without context object\n    $file = __FILE__;\n    $line = __LINE__;\n    my $message = \"Found \" . scalar(keys %{$self->documentation_pages}) . \" documentation pages\";\n\n    # Use log_to_file directly since we don't have a context object in BUILD\n    Comserv::Util::Logging::log_to_file(\"[$file:$line] BUILD - $message\", undef, 'INFO');\n}\n\n# Main documentation index\nsub index :Path :Args(0) {\n    my ($self, $c) = @_;\n\n    # Log the action\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', \"Accessing documentation index\");\n\n    # Get list of available documentation pages\n    my $pages = $self->documentation_pages;\n\n    # Sort pages alphabetically for better presentation\n    my @sorted_pages = sort keys %$pages;\n\n    # Create a structured list of documentation pages with metadata\n    my $structured_pages = {};\n    foreach my $page_name (@sorted_pages) {\n        my $path = $pages->{$page_name};\n        my $title = $self->_format_title($page_name);\n\n        # Always use the view action with the page name as parameter\n        my $url = $c->uri_for($self->action_for('view'), [$page_name]);\n\n        $structured_pages->{$page_name} = {\n            title => $title,\n            path => $path,\n            url => $url,\n        };\n    }\n\n    # Load the completed items JSON file\n    my $json_file = $c->path_to('root', 'Documentation', 'completed_items.json');\n    my $completed_items = [];\n\n    if (-e $json_file) {\n        # Read the JSON file\n        eval {\n            open my $fh, '<:encoding(UTF-8)', $json_file or die \"Cannot open $json_file: $!\";\n            my $json_content = do { local $/; <$fh> };\n            close $fh;\n\n            # Parse the JSON content\n            require JSON;\n            my $data = JSON::decode_json($json_content);\n\n            # Sort items by date_created in descending order (newest first)\n            $completed_items = [\n                sort { $b->{date_created} cmp $a->{date_created} }\n                @{$data->{completed_items}}\n            ];\n        };\n        if ($@) {\n            $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'index', \"Error loading completed items JSON: $@\");\n        }\n    }\n\n    # Add pages and completed items to stash\n    $c->stash(\n        documentation_pages => $pages,\n        structured_pages => $structured_pages,\n        sorted_page_names => \\@sorted_pages,\n        completed_items => $completed_items,\n        template => 'Documentation/index.tt'\n    );\n\n    $c->forward($c->view('TT'));\n}\n\n# Helper method to format page names into readable titles\nsub _format_title {\n    my ($self, $page_name) = @_;\n\n    # Convert underscores to spaces and capitalize each word\n    my $title = $page_name;\n    $title =~ s/_/ /g;\n    $title = join(' ', map { ucfirst $_ } split(/\\s+/, $title));\n\n    return $title;\n}\n\n# Display specific documentation page\nsub view :Path :Args(1) {\n    my ($self, $c, $page) = @_;\n\n    # Log the action\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'view', \"Accessing documentation page: $page\");\n\n    # Sanitize the page name to prevent directory traversal\n    $page =~ s/[^a-zA-Z0-9_\\.]//g;\n\n    # First check if it's a direct file request (with extension)\n    if ($page =~ /\\./) {\n        my $file_path = \"Documentation/$page\";\n        my $full_path = $c->path_to('root', $file_path);\n\n        if (-e $full_path && !-d $full_path) {\n            # Determine content type based on file extension\n            my $content_type = 'text/plain';  # Default\n            if ($page =~ /\\.json$/i) {\n                $content_type = 'application/json';\n            } elsif ($page =~ /\\.html?$/i) {\n                $content_type = 'text/html';\n            } elsif ($page =~ /\\.css$/i) {\n                $content_type = 'text/css';\n            } elsif ($page =~ /\\.js$/i) {\n                $content_type = 'application/javascript';\n            } elsif ($page =~ /\\.pdf$/i) {\n                $content_type = 'application/pdf';\n            } elsif ($page =~ /\\.(jpe?g|png|gif)$/i) {\n                $content_type = 'image/' . lc($1);\n            }\n\n            # Read the file - binary mode for all files to be safe\n            open my $fh, '<:raw', $full_path or die \"Cannot open $full_path: $!\";\n            my $content = do { local $/; <$fh> };\n            close $fh;\n\n            # Set the response\n            $c->response->content_type($content_type);\n            $c->response->body($content);\n            return;\n        }\n    }\n\n    # If not a direct file or file not found, try as a template\n    my $template_path = \"Documentation/$page.tt\";\n    my $full_path = $c->path_to('root', $template_path);\n\n    if (-e $full_path) {\n        # Set the template\n        $c->stash(template => $template_path);\n    } else {\n        # Log the error\n        $self->logging->log_with_details($c, 'error', __FILE__, __LINE__, 'view', \"Documentation page not found: $page\");\n\n        # Set error message\n        $c->stash(\n            error_msg => \"Documentation page '$page' not found\",\n            template => 'Documentation/error.tt'\n        );\n    }\n\n    $c->forward($c->view('TT'));\n}\n\n# Auto method for all documentation requests\nsub auto :Private {\n    my ($self, $c) = @_;\n\n    # Get the current action\n    my $action = $c->action->name;\n\n    # Get the path from the request\n    my $path = $c->req->path;\n\n    # If the path starts with 'documentation/' and isn't a known action\n    if ($path =~ m{^documentation/(.+)$} &&\n        $action ne 'index' &&\n        $action ne 'view' &&\n        !$c->controller('Documentation')->action_for($action)) {\n\n        my $page = $1;\n\n        # Log the action\n        $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto',\n            \"Redirecting documentation request to view action: $page\");\n\n        # Forward to the view action with the page name\n        $c->forward('view', [$page]);\n        return 0; # Skip further processing\n    }\n\n    return 1; # Continue processing\n}\n\n# IMPORTANT: We're completely disabling dynamic route registration\n# to avoid the \"Can't locate object method 'attributes'\" errors\nsub register_actions {\n    my ($self, $app) = @_;\n\n    # Call the parent method first to register the explicitly defined actions\n    $self->next::method($app);\n\n    # Log that we're skipping dynamic route registration\n    Comserv::Util::Logging::log_to_file(\n        \"Skipping dynamic route registration for documentation pages to avoid package conflicts\",\n        undef, 'INFO'\n    );\n\n    # We're intentionally NOT registering dynamic routes for documentation pages\n    # This prevents the \"Can't locate object method 'attributes'\" errors\n    # Instead, we'll handle all documentation page requests through the 'view' action\n}\n\n# Theme system documentation\nsub theme_system :Path('theme_system') :Args(0) {\n    my ($self, $c) = @_;\n\n    # Log the action\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'theme_system', \"Accessing theme system documentation\");\n\n    # Set the template\n    $c->stash(template => 'Documentation/theme_system.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Theme system implementation documentation\nsub theme_system_implementation :Path('theme_system_implementation') :Args(0) {\n    my ($self, $c) = @_;\n\n    # Log the action\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'theme_system_implementation',\n        \"Accessing theme system implementation documentation\");\n\n    # Check if the markdown file exists\n    my $md_file = $c->path_to('root', 'Documentation', 'theme_system_implementation.md');\n\n    if (-e $md_file) {\n        # Read the markdown file\n        open my $fh, '<:encoding(UTF-8)', $md_file or die \"Cannot open $md_file: $!\";\n        my $content = do { local $/; <$fh> };\n        close $fh;\n\n        # Pass the content to the template\n        $c->stash(\n            markdown_content => $content,\n            template => 'Documentation/markdown_viewer.tt'\n        );\n    } else {\n        # If the file doesn't exist, show an error\n        $c->stash(\n            error_msg => \"Documentation file 'theme_system_implementation.md' not found\",\n            template => 'Documentation/error.tt'\n        );\n    }\n\n    $c->forward($c->view('TT'));\n}\n\n# Explicitly define routes for common documentation pages\n# This allows for better URL structure and SEO\n\n# Document management documentation\nsub document_management :Path('document_management') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'document_management', \"Accessing document management documentation\");\n    $c->stash(template => 'Documentation/document_management.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Recent updates\nsub recent_updates :Path('recent_updates') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'recent_updates', \"Accessing recent updates documentation\");\n    $c->stash(template => 'Documentation/recent_updates.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Admin documentation\nsub admin :Path('admin') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'admin', \"Accessing admin documentation\");\n    $c->stash(template => 'Documentation/admin.tt');\n    $c->forward($c->view('TT'));\n}\n\n# System overview\nsub system_overview :Path('system_overview') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'system_overview', \"Accessing system overview documentation\");\n    $c->stash(template => 'Documentation/system_overview.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Architecture\nsub architecture :Path('architecture') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'architecture', \"Accessing architecture documentation\");\n    $c->stash(template => 'Documentation/architecture.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Installation guide\nsub installation :Path('installation') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'installation', \"Accessing installation documentation\");\n    $c->stash(template => 'Documentation/installation.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Completed items JSON\nsub completed_items_json :Path('completed_items.json') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'completed_items_json', \"Accessing completed items JSON\");\n\n    # Read the JSON file\n    my $json_file = $c->path_to('root', 'Documentation', 'completed_items.json');\n    my $json_content = '';\n\n    if (-e $json_file) {\n        open my $fh, '<:raw', $json_file or die \"Cannot open $json_file: $!\";\n        $json_content = do { local $/; <$fh> };\n        close $fh;\n    }\n\n    # Set the response\n    $c->response->content_type('application/json');\n    $c->response->body($json_content);\n}\n\n# Configuration\nsub configuration :Path('configuration') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'configuration', \"Accessing configuration documentation\");\n    $c->stash(template => 'Documentation/configuration.tt');\n    $c->forward($c->view('TT'));\n}\n\n# User guide\nsub user_guide :Path('user_guide') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'user_guide', \"Accessing user guide documentation\");\n    $c->stash(template => 'Documentation/user_guide.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Admin guide\nsub admin_guide :Path('admin_guide') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'admin_guide', \"Accessing admin guide documentation\");\n    $c->stash(template => 'Documentation/admin_guide.tt');\n    $c->forward($c->view('TT'));\n}\n\n# API reference\nsub api_reference :Path('api_reference') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'api_reference', \"Accessing API reference documentation\");\n    $c->stash(template => 'Documentation/api_reference.tt');\n    $c->forward($c->view('TT'));\n}\n\n# Database schema\nsub database_schema :Path('database_schema') :Args(0) {\n    my ($self, $c) = @_;\n    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'database_schema', \"Accessing database schema documentation\");\n    $c->stash(template => 'Documentation/database_schema.tt');\n    $c->forward($c->view('TT'));\n}\n\n__PACKAGE__->meta->make_immutable;\n\n1;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/lib/Comserv/Controller/Documentation.pm b/Comserv/lib/Comserv/Controller/Documentation.pm
--- a/Comserv/lib/Comserv/Controller/Documentation.pm	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/lib/Comserv/Controller/Documentation.pm	(date 1742226396333)
@@ -19,14 +19,13 @@
     lazy => 1,
 );
 
+# Initialize - scan for documentation files
 # Initialize - scan for documentation files
 sub BUILD {
     my ($self) = @_;
 
-    # Log the start of BUILD
-    my $file = __FILE__;
-    my $line = __LINE__;
-    Comserv::Util::Logging::log_to_file("[$file:$line] Starting BUILD method for Documentation controller", undef, 'INFO');
+    # Create a logging instance
+    my $logging = $self->logging;
 
     # Scan the Documentation directory for all files
     my $doc_dir = "root/Documentation";
@@ -67,13 +66,16 @@
         );
     }
 
-    # Log the discovered documentation pages without context object
-    $file = __FILE__;
-    $line = __LINE__;
+    # Log the number of pages found using the logging attribute
     my $message = "Found " . scalar(keys %{$self->documentation_pages}) . " documentation pages";
-
-    # Use log_to_file directly since we don't have a context object in BUILD
-    Comserv::Util::Logging::log_to_file("[$file:$line] BUILD - $message", undef, 'INFO');
+    $logging->log_with_details(
+        undef,  # No context object in BUILD
+        'info',
+        __FILE__,
+        __LINE__,
+        'BUILD',
+        $message
+    );
 }
 
 # Main documentation index
Index: Comserv/lib/Comserv/Controller/USBM.pm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Comserv::Controller::USBM;\nuse Moose;\nuse namespace::autoclean;\n\nBEGIN { extends 'Catalyst::Controller'; }\n\nsub index :Path('/') :Args(0) {\n    my ( $self, $c ) = @_;\n   $c->session->{MailServer} = \"http://webmail.usbm.ca\";\n\n     $c->stash(template => 'USBM/USBM.tt');\n}\n\n\n\n=encoding utf8\n\n=head1 AUTHOR\n\nShanta McBain\n\n=head1 LICENSE\n\nThis library is free software. You can redistribute it and/or modify\nit under the same terms as Perl itself.\n\n=cut\n\n__PACKAGE__->meta->make_immutable;\n\n1;\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/lib/Comserv/Controller/USBM.pm b/Comserv/lib/Comserv/Controller/USBM.pm
--- a/Comserv/lib/Comserv/Controller/USBM.pm	(revision 6c2539c32fe273080e129323779b21dbb498090b)
+++ b/Comserv/lib/Comserv/Controller/USBM.pm	(date 1742226396350)
@@ -1,14 +1,34 @@
 package Comserv::Controller::USBM;
 use Moose;
 use namespace::autoclean;
+use Comserv::Util::Logging;
 
 BEGIN { extends 'Catalyst::Controller'; }
 
-sub index :Path('/') :Args(0) {
+# Set the namespace for this controller
+__PACKAGE__->config(namespace => 'USBM');
+
+has 'logging' => (
+    is => 'ro',
+    default => sub { Comserv::Util::Logging->instance }
+);
+
+sub auto :Private {
+    my ($self, $c) = @_;
+    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', "USBM controller auto method called");
+    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', "Request path: " . $c->req->uri->path);
+    return 1; # Allow the request to proceed
+}
+
+sub index :Path :Args(0) {
     my ( $self, $c ) = @_;
-   $c->session->{MailServer} = "http://webmail.usbm.ca";
+    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', "USBM index method called");
+
+    $c->session->{MailServer} = "http://webmail.usbm.ca";
 
-     $c->stash(template => 'USBM/USBM.tt');
+    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'index', "Setting template to USBM/USBM.tt");
+    $c->stash(template => 'USBM/USBM.tt');
+    $c->forward($c->view('TT'));
 }
 
 
Index: Comserv/root/Documentation/controller_routing_guidelines.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Comserv/root/Documentation/controller_routing_guidelines.md b/Comserv/root/Documentation/controller_routing_guidelines.md
new file mode 100644
--- /dev/null	(date 1742226396327)
+++ b/Comserv/root/Documentation/controller_routing_guidelines.md	(date 1742226396327)
@@ -0,0 +1,89 @@
+# Controller Routing Guidelines
+
+## Overview
+
+This document provides guidelines for setting up controllers in the Comserv application to ensure proper routing and prevent common issues like the "all sites returning the USBM home page" problem.
+
+## Common Issues
+
+One recurring issue in our application has been that all sites sometimes return the USBM home page. This happens when a controller incorrectly captures the root path (`/`) for all domains.
+
+## Proper Controller Setup
+
+### 1. Always Set a Namespace
+
+Every controller should explicitly set its namespace to match the controller name:
+
+```perl
+# In Comserv::Controller::MySite
+__PACKAGE__->config(namespace => 'MySite');
+```
+
+This ensures that the controller only responds to paths that start with `/MySite`.
+
+### 2. Use Appropriate Action Attributes
+
+- **:Path** - Use with caution. If used without arguments, it captures the controller's namespace.
+  - `:Path('/')` - Captures the root path for ALL domains (avoid this in site-specific controllers)
+  - `:Path('/specific')` - Captures a specific absolute path
+  - `:Path` - Captures the controller's namespace path
+
+- **:Local** - Safer option. Appends the method name to the controller's namespace.
+  - `sub method :Local` - Captures `/Namespace/method`
+
+- **:Chained** - Best for complex applications. Creates a chain of actions.
+
+### 3. Include Proper Logging
+
+Always include logging in your controllers:
+
+```perl
+use Comserv::Util::Logging;
+
+has 'logging' => (
+    is => 'ro',
+    default => sub { Comserv::Util::Logging->instance }
+);
+
+sub auto :Private {
+    my ($self, $c) = @_;
+    $self->logging->log_with_details($c, 'info', __FILE__, __LINE__, 'auto', 
+        "Controller auto method called");
+    return 1;
+}
+```
+
+### 4. Forward to View
+
+Always explicitly forward to the view in your action methods:
+
+```perl
+$c->stash(template => 'MyTemplate.tt');
+$c->forward($c->view('TT'));
+```
+
+## Site-Specific Controllers
+
+For site-specific controllers:
+
+1. Name the controller after the site (e.g., `Comserv::Controller::USBM` for USBM site)
+2. Set the namespace to match the site name
+3. Use `:Path` without arguments or `:Local` for the index method
+4. Do NOT use `:Path('/')` in site-specific controllers
+
+## Root Controller
+
+Only the `Comserv::Controller::Root` should handle the root path (`/`). It determines which site to display based on the domain and other factors.
+
+## Testing
+
+After creating or modifying a controller, test it with multiple domains to ensure it doesn't capture routes it shouldn't.
+
+## Troubleshooting
+
+If all sites start showing the same content:
+
+1. Check for controllers using `:Path('/')` incorrectly
+2. Verify the `sitedomain` table has correct entries
+3. Check the logging for routing issues
+4. Ensure the `Root` controller's `auto` and `index` methods are working correctly
\ No newline at end of file
