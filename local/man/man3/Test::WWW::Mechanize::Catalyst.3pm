.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::WWW::Mechanize::Catalyst 3pm"
.TH Test::WWW::Mechanize::Catalyst 3pm 2019-02-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test::WWW::Mechanize::Catalyst \- Test::WWW::Mechanize for Catalyst
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&  # We\*(Aqre in a t/*.t test script...
\&  use Test::WWW::Mechanize::Catalyst;
\&
\&  # To test a Catalyst application named \*(AqCatty\*(Aq:
\&  my $mech = Test::WWW::Mechanize::Catalyst\->new(catalyst_app => \*(AqCatty\*(Aq);
\&
\&  $mech\->get_ok("/"); # no hostname needed
\&  is($mech\->ct, "text/html");
\&  $mech\->title_is("Root", "On the root page");
\&  $mech\->content_contains("This is the root page", "Correct content");
\&  $mech\->follow_link_ok({text => \*(AqHello\*(Aq}, "Click on Hello");
\&  # ... and all other Test::WWW::Mechanize methods
\&  
\&  # White label site testing
\&  $mech\->host("foo.com");
\&  $mech\->get_ok("/");
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Catalyst is an elegant MVC Web Application Framework.
Test::WWW::Mechanize is a subclass of WWW::Mechanize that incorporates
features for web application testing. The Test::WWW::Mechanize::Catalyst
module meshes the two to allow easy testing of Catalyst applications without
needing to start up a web server.
.PP
Testing web applications has always been a bit tricky, normally
requiring starting a web server for your application and making real HTTP
requests to it. This module allows you to test Catalyst web
applications but does not require a server or issue HTTP
requests. Instead, it passes the HTTP request object directly to
Catalyst. Thus you do not need to use a real hostname:
"http://localhost/" will do. However, this is optional. The following
two lines of code do exactly the same thing:
.PP
.Vb 2
\&  $mech\->get_ok(\*(Aq/action\*(Aq);
\&  $mech\->get_ok(\*(Aqhttp://localhost/action\*(Aq);
.Ve
.PP
Links which do not begin with / or are not for localhost can be handled
as normal Web requests \- this is handy if you have an external 
single sign-on system. You must set allow_external to true for this:
.PP
.Vb 1
\&  $mech\->allow_external(1);
.Ve
.PP
You can also test a remote server by setting the environment variable
CATALYST_SERVER; for example:
.PP
.Vb 1
\&  $ CATALYST_SERVER=http://example.com/myapp prove \-l t
.Ve
.PP
will run the same tests on the application running at
http://example.com/myapp regardless of whether or not you specify
http:://localhost for Test::WWW::Mechanize::Catalyst.
.PP
Furthermore, if you set CATALYST_SERVER, the server will be regarded 
as a remote server even if your links point to localhost. Thus, you
can use Test::WWW::Mechanize::Catalyst to test your live webserver
running on your local machine, if you need to test aspects of your
deployment environment (for example, configuration options in an
http.conf file) instead of just the Catalyst request handling.
.PP
This makes testing fast and easy. Test::WWW::Mechanize provides
functions for common web testing scenarios. For example:
.PP
.Vb 4
\&  $mech\->get_ok( $page );
\&  $mech\->title_is( "Invoice Status", "Make sure we\*(Aqre on the invoice page" );
\&  $mech\->content_contains( "Andy Lester", "My name somewhere" );
\&  $mech\->content_like( qr/(cpan|perl)\e.org/, "Link to perl.org or CPAN" );
.Ve
.PP
This module supports cookies automatically.
.PP
To use this module you must pass it the name of the application. See
the SYNOPSIS above.
.PP
Note that Catalyst has a special development feature: the debug
screen. By default this module will treat responses which are the
debug screen as failures. If you actually want to test debug screens,
please use:
.PP
.Vb 1
\&  $mech\->{catalyst_debug} = 1;
.Ve
.PP
An alternative to this module is Catalyst::Test.
.SH CONSTRUCTOR
.IX Header "CONSTRUCTOR"
.SS new
.IX Subsection "new"
Behaves like, and calls, WWW::Mechanize's \f(CW\*(C`new\*(C'\fR method.  Any params
passed in get passed to WWW::Mechanize's constructor. Note that we
need to pass the name of the Catalyst application to the "use":
.PP
.Vb 2
\&  use Test::WWW::Mechanize::Catalyst \*(AqCatty\*(Aq;
\&  my $mech = Test::WWW::Mechanize::Catalyst\->new;
.Ve
.SH METHODS
.IX Header "METHODS"
.SS allow_external
.IX Subsection "allow_external"
Links which do not begin with / or are not for localhost can be handled
as normal Web requests \- this is handy if you have an external 
single sign-on system. You must set allow_external to true for this:
.PP
.Vb 1
\&  $mech\->allow_external(1);
.Ve
.PP
head2 catalyst_app
.PP
The name of the Catalyst app which we are testing against. Read-only.
.SS host
.IX Subsection "host"
The host value to set the "Host:" HTTP header to, if none is present already in
the request. If not set (default) then Catalyst::Test will set this to
localhost:80
.SS clear_host
.IX Subsection "clear_host"
Unset the host attribute.
.SS has_host
.IX Subsection "has_host"
Do we have a value set for the host attribute
.ie n .SS "$mech\->get_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->get_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->get_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fBget()\fR, with similar options, except the
second argument needs to be a hash reference, not a hash. Returns true or 
false.
.ie n .SS "$mech\->title_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_is( $str [, $desc ] )"
Tells if the title of the page is the given string.
.PP
.Vb 1
\&    $mech\->title_is( "Invoice Summary" );
.Ve
.ie n .SS "$mech\->title_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_like( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_like( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->title_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_unlike( $regex [, $desc ] )"
Tells if the title of the page does NOT match the given regex.
.PP
.Vb 1
\&    $mech\->title_unlike( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->content_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_is( $str [, $desc ] )"
Tells if the content of the page matches the given string.
.ie n .SS "$mech\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_contains( $str [, $desc ] )"
Tells if the content of the page contains \fR\f(CI$str\fR\fI\fR.
.ie n .SS "$mech\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_lacks( $str [, $desc ] )"
Tells if the content of the page lacks \fR\f(CI$str\fR\fI\fR.
.ie n .SS "$mech\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_like( $regex [, $desc ] )"
Tells if the content of the page matches \fR\f(CI$regex\fR\fI\fR.
.ie n .SS "$mech\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_unlike( $regex [, $desc ] )"
Tells if the content of the page does NOT match \fR\f(CI$regex\fR\fI\fR.
.ie n .SS "$mech\->page_links_ok( [ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_ok( [ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_ok( [ $desc ] )"
Follow all links on the current page and test for HTTP status 200
.PP
.Vb 1
\&    $mech\->page_links_ok(\*(AqCheck all links\*(Aq);
.Ve
.ie n .SS "$mech\->page_links_content_like( $regex,[ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_like( \f(CW$regex\fP,[ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_like( $regex,[ $desc ] )"
Follow all links on the current page and test their contents for \fR\f(CI$regex\fR\fI\fR.
.PP
.Vb 2
\&    $mech\->page_links_content_like( qr/foo/,
\&      \*(AqCheck all links contain "foo"\*(Aq );
.Ve
.ie n .SS "$mech\->page_links_content_unlike( $regex,[ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_unlike( \f(CW$regex\fP,[ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_unlike( $regex,[ $desc ] )"
Follow all links on the current page and test their contents do not
contain the specified regex.
.PP
.Vb 2
\&    $mech\->page_links_content_unlike(qr/Restricted/,
\&      \*(AqCheck all links do not contain Restricted\*(Aq);
.Ve
.ie n .SS "$mech\->links_ok( $links [, $desc ] )"
.el .SS "\f(CW$mech\fP\->links_ok( \f(CW$links\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->links_ok( $links [, $desc ] )"
Check the current page for specified links and test for HTTP status
200.  The links may be specified as a reference to an array containing
WWW::Mechanize::Link objects, an array of URLs, or a scalar URL
name.
.PP
.Vb 2
\&    my @links = $mech\->find_all_links( url_regex => qr/cnn\e.com$/ );
\&    $mech\->links_ok( \e@links, \*(AqCheck all links for cnn.com\*(Aq );
\&
\&    my @links = qw( index.html search.html about.html );
\&    $mech\->links_ok( \e@links, \*(AqCheck main links\*(Aq );
\&
\&    $mech\->links_ok( \*(Aqindex.html\*(Aq, \*(AqCheck link to index\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_is( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_is( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_is( $links, $status [, $desc ] )"
Check the current page for specified links and test for HTTP status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_status_is( \e@links, 403,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_isnt( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_isnt( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_isnt( $links, $status [, $desc ] )"
Check the current page for specified links and test for HTTP status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_status_isnt( \e@links, 404,
\&      \*(AqCheck all links are not 404\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_like( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_like( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_like( $links, $regex [, $desc ] )"
Check the current page for specified links and test the content of
each against \fR\f(CI$regex\fR\fI\fR.  The links may be specified as a reference to
an array containing WWW::Mechanize::Link objects, an array of URLs,
or a scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&        \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_unlike( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_unlike( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_unlike( $links, $regex [, $desc ] )"
Check the current page for specified links and test that the content of each
does not match \fR\f(CI$regex\fR\fI\fR.  The links may be specified as a reference to
an array containing WWW::Mechanize::Link objects, an array of URLs,
or a scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "follow_link_ok( \e%parms [, $comment] )"
.el .SS "follow_link_ok( \e%parms [, \f(CW$comment\fP] )"
.IX Subsection "follow_link_ok( %parms [, $comment] )"
Makes a \f(CWfollow_link()\fR call and executes tests on the results.
The link must be found, and then followed successfully.  Otherwise,
this test fails.
.PP
\&\fR\f(CI%parms\fR\fI\fR is a hashref containing the params to pass to \f(CWfollow_link()\fR.
Note that the params to \f(CWfollow_link()\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $agent\->follow_link_ok( {n=>3}, "looking for 3rd link" );
.Ve
.PP
As with other test functions, \f(CW$comment\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fBfollow_link()\fR
is not available.
.SH CAVEATS
.IX Header "CAVEATS"
.SS "External Redirects and allow_external"
.IX Subsection "External Redirects and allow_external"
If you use non-fully qualified urls in your test scripts (i.e. anything without
a host, such as \f(CW\*(C`\->get_ok( "/foo")\*(C'\fR ) and your app redirects to an
external URL, expect to be bitten once you come back to your application's urls
(it will try to request them on the remote server). This is due to a limitation
in WWW::Mechanize.
.PP
One workaround for this is that if you are expecting to redirect to an external
site, clone the TWMC object and use the cloned object for the external
redirect.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Related modules which may be of interest: Catalyst,
Test::WWW::Mechanize, WWW::Mechanize.
.SH AUTHOR
.IX Header "AUTHOR"
Ash Berlin \f(CW\*(C`<ash@cpan.org>\*(C'\fR (current maintainer)
.PP
Original Author: Leon Brocard, \f(CW\*(C`<acme@astray.com>\*(C'\fR
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (C) 2005\-9, Leon Brocard
.SH LICENSE
.IX Header "LICENSE"
This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.
