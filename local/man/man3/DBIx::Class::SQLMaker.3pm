.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker 3pm"
.TH DBIx::Class::SQLMaker 3pm 2022-05-15 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::SQLMaker \- An SQL::Abstract::Classic\-like SQL maker class
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module serves as a mere "nexus class" providing
SQL::Abstract::Classic\-like functionality to DBIx::Class itself, and
to a number of database-engine-specific subclasses. This indirection is
explicitly maintained in order to allow swapping out the core of SQL
generation within DBIC on per\-\f(CW$schema\fR basis without major architectural
changes. It is guaranteed by design and tests that this fast-switching
will continue being maintained indefinitely.
.SS "Implementation switching"
.IX Subsection "Implementation switching"
See "connect_call_rebase_sqlmaker" in DBIx::Class::Storage::DBI
.SH ROADMAP
.IX Header "ROADMAP"
Some maintainer musings on the current state of SQL generation within DBIC as
of October 2019
.SS "Folding of most (or all) of SQL::Abstract::Classic (SQLAC) into DBIC."
.IX Subsection "Folding of most (or all) of SQL::Abstract::Classic (SQLAC) into DBIC."
The rise of complex prefetch use, and the general streamlining of result
parsing within DBIC ended up pushing the actual SQL generation to the forefront
of many casual performance profiles. While the idea behind the SQLAC-like API
is sound, the actual implementation is terribly inefficient (once again bumping
into the ridiculously high overhead of perl function calls).
.PP
Given that SQLAC has a \fBvery\fR distinct life on its own, and will hopefully
continue to be used within an order of magnitude more projects compared to
DBIC, it is prudent to \fBnot\fR disturb the current call chains within SQLAC
itself. Instead in the future an effort will be undertaken to seek a more
thorough decoupling of DBIC SQL generation from reliance on SQLAC, possibly
to a point where \fBin the future DBIC may no longer depend on
SQL::Abstract::Classic\fR at all.
.PP
\&\fBThe SQL::Abstract::Classic library itself will continue being maintained\fR
although it is not likely to gain many extra features, notably it will \fBNOT\fR
add further dialect support, at least not within the preexisting
\&\f(CW\*(C`SQL::Abstract::Classic\*(C'\fR namespace.
.PP
Such streamlining work (if undertaken) will take into consideration the
following constraints:
.IP "Main API compatibility" 4
.IX Item "Main API compatibility"
The object returned by \f(CW\*(C`$schema\->storage\->sqlmaker\*(C'\fR needs to be able to
satisfy most of the basic tests found in the current-at-the-time SQLAC dist.
While things like case or
logic or even worse
convert will definitely remain
unsupported, the rest of the tests should pass (within reason).
.IP "Ability to replace SQL::Abstract::Classic with a derivative module" 4
.IX Item "Ability to replace SQL::Abstract::Classic with a derivative module"
During the initial work on Data::Query, which later was slated to occupy
the preexisting namespace of SQL::Abstract, the test suite of DBIC turned
out to be an invaluable asset to iron out hard-to-reason-about corner cases.
In addition the test suite is much more vast and intricate than the tests of
SQLAC itself. This state of affairs is way too valuable to sacrifice in order
to gain faster SQL generation. Thus the
SQLMaker rebase
functionality introduced in DBIC v0.082850 along with extra CI configurations
will continue to ensure that DBIC can be used with an off-the-CPAN SQLAC and
derivatives, and that it continues to flawlessly run its entire test suite.
While this will undoubtedly complicate the future implementation of a better
performing SQL generator, it will preserve both the usability of the test suite
for external projects and will keep SQL::Abstract::Classic from regressions
in the future.
.PP
Aside from these constraints it is becoming more and more practical to simply
stop using SQLAC in day-to-day production deployments of DBIC. The flexibility
of the internals is simply not worth the performance cost.
.SS "Relationship to SQL::Abstract and what formerly was known as Data::Query (DQ)"
.IX Subsection "Relationship to SQL::Abstract and what formerly was known as Data::Query (DQ)"
When initial work on DQ was taking place, the tools in ::Storage::DBIHacks
 <https://github.com/Perl5/DBIx-Class/blob/master/lib/DBIx/Class/Storage/DBIHacks.pm>
were only beginning to take shape, and it wasn't clear how important they will
become further down the road. In fact the \fIregexing all over the place\fR was
considered an ugly stop-gap, and even a couple of highly entertaining talks
were given to that effect. As the use-cases of DBIC were progressing, and
evidence for the importance of supporting arbitrary SQL was mounting, it became
clearer that DBIC itself would not really benefit in any significant way from
tigher integration with DQ, but on the contrary is likely to lose crucial
functionality <https://github.com/Perl5/DBIx-Class/blob/7ef1a09ec4/lib/DBIx/Class/Storage/DBIHacks.pm#L373-L396>
while the corners of the brand new DQ/SQLA codebase are sanded off.
.PP
The current stance on DBIC/SQLA integration is that it would mainly benefit
SQLA by having access to the very extensive "early adopter" test suite, in the
same manner as early DBIC benefitted tremendously from usurping the Class::DBI
test suite. As far as the DBIC user-base \- there are no immediate large-scale
upsides to deep SQLA integration, neither in terms of API nor in performance.
As such it is unlikely that DBIC will switch back to using SQL::Abstract in
its core any time soon, if ever.
.PP
Accordingly the DBIC development effort will in the foreseable future ignore
the existence of the new-guts SQLA, and will continue optimizing the
preexisting SQLAC-based solution, potentially "organically growing" its own
compatible implementation. Also, as described higher up, the ability to plug a
separate SQLAC-compatible class providing the necessary surface API will remain
possible, and will be protected at all costs in order to continue providing
SQLA and friends access to the test cases of DBIC.
.SH "FURTHER QUESTIONS?"
.IX Header "FURTHER QUESTIONS?"
Check the list of additional DBIC resources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This module is free software copyright
by the DBIx::Class (DBIC) authors. You can
redistribute it and/or modify it under the same terms as the
DBIx::Class library.
