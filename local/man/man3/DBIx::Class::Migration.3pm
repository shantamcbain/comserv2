.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Migration 3pm"
.TH DBIx::Class::Migration 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Migration \- Use the best tools together for sane database migrations
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use DBIx::Class::Migration;
\&
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema_class => \*(AqMyApp::Schema\*(Aq,
\&      schema_args => \e@connect_opts);
.Ve
.PP
Alternatively:
.PP
.Vb 2
\&    use DBIx::Class::Migration;
\&    use MyApp::Schema;
\&
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema => MyApp::Schema\->connect(@connect_opts));
.Ve
.PP
Informational Commands:
.PP
.Vb 1
\&    $migration\->status;
.Ve
.PP
Preparing and using Migrations:
.PP
.Vb 4
\&    $migration\->prepare;
\&    $migration\->install;
\&    $migration\->upgrade;
\&    $migration\->downgrade;
.Ve
.PP
Commands for working with Fixtures:
.PP
.Vb 3
\&    $migration\->dump_named_sets;
\&    $migration\->dump_all_sets;
\&    $migration\->populate;
.Ve
.PP
Utility Commands:
.PP
.Vb 6
\&    $migration\->drop_tables;
\&    $migration\->delete_table_rows;
\&    $migration\->make_schema;
\&    $migration\->install_if_needed;
\&    $migration\->install_version_storage;
\&    $migration\->diagram;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
DBIx::Class::DeploymentHandler is a state of the art solution to the problem
of creating sane workflows for versioning DBIx::Class managed database
projects.  However, since it is more of a toolkit for building custom versioning
and migration workflows than an expression of a particular migration practice,
it might not always be the most approachable tool.  If you are starting a new
DBIx::Class project and you don't have a particular custom workflow need,
you might prefer to simply be given a reasonable clear and standard practice,
rather than a toolkit with a set of example scripts.
.PP
DBIx::Class::Migration defines some logic which combines both
DBIx::Class::DeploymentHandler and DBIx::Class::Fixtures, along with
a standard tutorial, to give you a simple and straightforward approach to
solving the problem of how to best create database versions, migrations and
testing data.  Additionally it builds on tools like Test::mysqld and
Test::Postgresql58 along with DBD::Sqlite in order to assist you in quickly
creating a local development database sandbox.  It offers some integration
points to testing your database, via tools like Test::DBIx::Class in order to
make testing your database driven logic less painful.  Lastly, we offer some
thoughts on good development patterns in using databases with application
frameworks like Catalyst.
.PP
DBIx::Class::Migration offers code and advice based on my experience of using
DBIx::Class for several years, which hopefully can help you bootstrap a new
project.  The solutions given should work for you if you want to use DBIx::Class
and have database migrations, but don't really know what to do next.  These
solutions should scale upward from a small project to a medium project involving
many developers and more than one target environment (DEV \-> QA \-> Production.)
If you have very complex database versioning requirements, huge teams and
difficult architectual issues, you might be better off building something on
top of DBIx::Class::DeploymentHandler directly.
.PP
DBIx::Class::Migration is a base class upon which interfaces like
DBIx::Class::Migration::Script are built.
.PP
Please see DBIx::Class::Migration::Tutorial for more approachable
documentation.  If you want to read a high level feature overview, see
DBIx::Class::Migration::Features.  The remainder of this POD is API level
documentation on the various internals.
.SH ATTRIBUTES
.IX Header "ATTRIBUTES"
This class defines the following attributes.
.SS db_sandbox_builder_class
.IX Subsection "db_sandbox_builder_class"
Accept Str.  Defaults to 'DBIx::Class::Migration::TargetDirSandboxBuilder'
.PP
The name of the helper class which builds the class that builds database
sandboxs.  By default we build database sandboxes in the "target_dir", which
is what DBIx::Class::Migration::TargetDirSandboxBuilder does.  We can also
build database sandboxes in a temporary directory using
DBIx::Class::Migration::TempDirSandboxBuilder.  You might prefer that for
running tests, for example.
.SS db_sandbox_class
.IX Subsection "db_sandbox_class"
Accepts Str.  Not Required (defaults to 'DBIx::Class::Migration::SqliteSandbox').
.PP
Unless you already have a database setup and running (as you probably do in
production) we need to auto create a database 'sandbox' that is isolated to
your development local.  This class is a delegate that performs this job if you
don't want to go to the trouble of installing and setting up a local database
yourself.
.PP
This must point to a class that expects \f(CW\*(C`target_dir\*(C'\fR and \f(CW\*(C`schema_class\*(C'\fR for
initialization arguments and must define a method \f(CW\*(C`make_sandbox\*(C'\fR that returns
an array which can be sent to "connect" in DBIx::Class::Schema.
.PP
This defaults to DBIx::Class::Migration::SqliteSandbox.  Currently we have
support for MySQL and Postgresql via DBIx::Class::Migration::MySQLSandbox
and DBIx::Class::Migration::PgSandbox, but you will need to side install
Test::mysqld and Test::Postgresql58 (In other words you'd need to add
these \f(CW\*(C`Test::*\*(C'\fR namespace modules to your \f(CW\*(C`Makefile.PL\*(C'\fR or \f(CW\*(C`dist.ini\*(C'\fR).
.SS db_sandbox
.IX Subsection "db_sandbox"
Accepts: Object.  Not required.
.PP
This is an instantiated object as defined by "db_sandbox_class".  It is a
delegate for the work of automatically creating a local database sandbox that
is useful for developers and for quickly bootstrapping a project.
.SS schema_class
.IX Subsection "schema_class"
Accepts Str.  Not Required (but if missing, you need to populate "schema").
.PP
This is the schema we use as the basis for creating, managing and running your
deployments.  This should be the full package namespace defining your subclass
of DBIx::Class::Schema.  For example \f(CW\*(C`MyApp::Schema\*(C'\fR.
.PP
If the "schema_class" cannot be loaded, a hard exception will be thrown.
.SS schema_args
.IX Subsection "schema_args"
Accepts ArrayRef.  Required but lazily builds from defaults
.PP
Provides arguments passed to \f(CW\*(C`connect\*(C'\fR on your "schema_class".  Should
connect to a database.
.PP
This is an arrayref that would work the same as "connect" in DBIx::Class::Schema.
If you choose to create an instance of DBIx::Class::Migration by providing a
schema_class, you can use this to customize how we connect to a database.
.PP
If you don't provide a value, we will automatically create a SQLite based
database connection with the following DSN:
.PP
.Vb 1
\&    DBD:SQLite:[path to target_dir]/[db_file_name].db
.Ve
.PP
Where \f(CW\*(C`[path to target_dir]\*(C'\fR is "target_dir" and [db_file_name] is a converted
version of "schema_class".  For example if you set schema_class to:
.PP
.Vb 1
\&    MyApp::Schema
.Ve
.PP
Then [db_file_name] would be \f(CW\*(C`myapp\-schema\*(C'\fR.
.PP
Basically, this means you can start testing your database designs right off
without a lot of effort, just point at a schema_class and get deploying!
.SS schema
.IX Subsection "schema"
Accepts: Object of DBIx::Class::Schema.  Not required.
.PP
If you already have a connected schema (subclass of DBIx::Class::Schema)
you can simple point to it, skipping schema_class and schema_args.  You
might for example be using Catalyst and want to build deployments for a
database that is listed in configuration:
.PP
.Vb 2
\&    use MyCatalyst::App;
\&    use DBIx::Class::Migration;
\&
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema => MyCatalyst::App\->model(\*(AqSchema\*(Aq)\->schema,
\&      %{MyCatalyst::App\->config\->{extra_migration_init_args}};
\&    );
.Ve
.SS target_dir_builder_class
.IX Subsection "target_dir_builder_class"
Accepts:  Str, Defaults to 'DBIx::Class::Migration::ShareDirBuilder'
This is a class that is used as a helper to build "target_dir" should the
user not provide a value.  Default is DBIx::Class::Migration::ShareDirBuilder
.SS target_dir_builder
.IX Subsection "target_dir_builder"
An instance of whatever is in "target_dir_builder_class".  Used by the lazy
build method of "target_dir" to default a directory where the migrations are
actually placed.
.SS target_dir
.IX Subsection "target_dir"
Accepts Str.  Required (lazy builds to your distribution \f(CW\*(C`/share\*(C'\fR directory).
.PP
This is the directory we store our migration and fixture files.  Inside this
directory we will create a \f(CW\*(C`fixtures\*(C'\fR and \f(CW\*(C`migrations\*(C'\fR sub-directory.
.PP
Although you can specify the directory, if you leave it undefined, we will use
File::ShareDir::ProjectDistDir to locate the \f(CW\*(C`/share\*(C'\fR directory for your
project and place the files there.  This is the recommended approach, and is
considered a community practice in regards to where to store your distribution
non code files.  Please see File::ShareDir::ProjectDistDir as well as
File::ShareDir for more information.
.PP
This uses whatever is in "schema_class" to determine your project (and look
for a \f(CW\*(C`share\*(C'\fR directory, which you'll need to create in your project root).
If you don't have a "schema_class" defined, you must have a "schema",
and we'll infer the class via \f(CWref($self\->schema)\fR.
.PP
\&\fBNOTE:\fR You'll need to make the \f(CW\*(C`/share\*(C'\fR directory if you are going to use
the default option.  We don't automatically create it for you.
.SS schema_loader_class
.IX Subsection "schema_loader_class"
Accepts Str.  Required
.PP
Because your application subclass of DBIx::Class::Schema is going to
change a lot, sometimes we need to generate our own schema and get one that is
in a known, good state.  Mostly this is used by the commands to drop tables
and clear tables.
.PP
Defaults to DBIx::Class::Migration::SchemaLoader.  You'll probably only
need to change this if your database is crazy and you need to massage the
init arguments to DBIx::Class::Schema::Loader.
.SS schema_loader
.IX Subsection "schema_loader"
Accepts Object.  Required but lazy builds.
.PP
This is a factory that provider autoloaded schema based on the current schema's
database.  It is automatically created and you are unlikely to need to set this
manually.
.SS dbic_fixture_class
.IX Subsection "dbic_fixture_class"
Accepts Str.  Required
.PP
This is the class we use when creating instances of DBIx::Class::Fixtures.
You'll probably need to review the docs for that and understand how configuration
rules work in order to best take advantage of the system.
.PP
Defaults to DBIx::Class::Fixtures.  You'll probably not need to change this
unless you have some unusual needs regarding fixtures.
.SS dbic_fixtures_extra_args
.IX Subsection "dbic_fixtures_extra_args"
Accepts HashRef. Required, but Defaults to Empty Hashref
.PP
Allows you to pass some additional arguments when creating instances of
"dbic_fixture_class".  These arguments can be used to override the default
initial arguments.
.SS deployment_handler_class
.IX Subsection "deployment_handler_class"
Accepts Str.  Required
.PP
This is the class we use when creating instances of DBIx::Class::DeploymentHandler.
It would be ideal that you review those docs in order to better understand the
overall architecture of the system.
.PP
Defaults to DBIx::Class::DeploymentHandler.  You'll probably not need to
change this unless you need a custom deployment handler, and if you do, I
can't be sure this framework will work correctly, particularly if you are not
using monotonic versioning.
.SS dbic_dh_args
.IX Subsection "dbic_dh_args"
Accepts HashRef.  Required and defaults to a hashref setting
\&\f(CW\*(C`sql_translator_args\*(C'\fR's \f(CW\*(C`quote_identifiers\*(C'\fR to a true value, which
despite being documented as the default, is not the case in practice.
.PP
Used to pass custom args when building a DBIx::Class::DeploymentHandler.
Please see the docs for that class for more.  Useful args might be \f(CW\*(C`databases\*(C'\fR,
\&\f(CW\*(C`to_version\*(C'\fR and \f(CW\*(C`force_overwrite\*(C'\fR.
.SS dbic_dh
.IX Subsection "dbic_dh"
Accepts Instance of DBIx::Class::DeploymentHandler.  Required but lazily
built from default data and dbic_dh_args.
.PP
You probably won't need to build your own deployment handler and pass it in
(unlike schema, where it might actually be useful).  Be careful it you do
since this framework makes some assumptions about your deployment handler (for
example we assume you are using the monotonic versioning).
.PP
When this attribute is lazily built, we merge "dbic_dh_args" with the
following defaults:
.PP
.Vb 3
\&      schema => Points to $self\->schema
\&      script_directory => Points to catdir($self\->target_dir, \*(Aqmigrations\*(Aq)
\&      databases => Inferred from your connected schema, defaults to SQLite
.Ve
.PP
"dbic_dh_args" will overwrite the defaults, if you pass them.
.SS extra_schemaloader_args
.IX Subsection "extra_schemaloader_args"
Optional.  Accepts a HashRef of arguments you can use to influence how
DBIx::Class::Schema::Loader works.  This HashRef would get passed as
\&\f(CW\*(C`loader_options\*(C'\fR (see "make_schema_at" in DBIx::Class::Schema::Loader.
.PP
Meaningful options are described at DBIx::Class::Schema::Loader::Base.
.SH METHODS
.IX Header "METHODS"
This class defines the following methods for public use
.SS new
.IX Subsection "new"
Used to create an new instance of DBIx::Class::Migration.  There's a couple
of paths to creating this instance.
.PP
\fISpecify a schema_class and optionally schema_args\fR
.IX Subsection "Specify a schema_class and optionally schema_args"
.PP
.Vb 5
\&    use DBIx::Class::Migration;
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema_class => \*(AqMyApp::Schema\*(Aq,
\&      schema_args => [@connect_info],
\&    );
.Ve
.PP
This is probably the most general approach, and is recommended unless you
already have a connected instance of your DBIx::Class::Schema subclass.
.PP
"schema_args" would be anything you'd pass to "connect" in DBIx::Class::Schema.
see "schema_args" for how we construct default connect information if you
choose to leave this undefined.
.PP
\fISpecify a schema\fR
.IX Subsection "Specify a schema"
.PP
There may be some cases when you already have a schema object constructed and
would prefer to just use that.  For example, you may be using Catalyst and
wish to build custom scripts using the built-in dependency and service lookup:
.PP
.Vb 2
\&    use MyCatalyst::App;
\&    use DBIx::Class::Migration;
\&
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema => MyCatalyst::App\->model(\*(AqSchema\*(Aq)\->schema,
\&      %{MyCatalyst::App\->config\->{extra_migration_init_args}};
\&    );
.Ve
.PP
Be careful of potential locking issues when using some databases like SQLite.
.PP
\fIOPTIONAL: Specify a target_dir\fR
.IX Subsection "OPTIONAL: Specify a target_dir"
.PP
Optionally, you can specify your migrations target directory (where your
migrations get created), in your init arguments.  This option can be combined
with either approach listed above.
.PP
.Vb 6
\&    use DBIx::Class::Migration;
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema_class => \*(AqMyApp::Schema\*(Aq,
\&      schema_args => [@connect_info],
\&      target_dir => \*(Aq/opt/database\-migrations\*(Aq,
\&    );
.Ve
.PP
If you leave this undefined we default to using the \f(CW\*(C`share\*(C'\fR directory in your
distribution root.  This is generally the community supported place for non
code data, but if you have huge fixture sets you might wish to place them in
an alternative location.
.PP
\fIOPTIONAL: Specify a db_sandbox_dir\fR
.IX Subsection "OPTIONAL: Specify a db_sandbox_dir"
.PP
Be default if you allow for a local database sandbox (as you might during early
development and you don't want to work to make a database) that sandbox gets
built in the 'target_dir'.  Since other bits in the target_dir are probably
going to be in your project repository and the sandbox generally isnt, you
might wish to build the sandbox in an alternative location.  This setting
allows that:
.PP
.Vb 6
\&    use DBIx::Class::Migration;
\&    my $migration = DBIx::Class::Migration\->new(
\&      schema_class => \*(AqMyApp::Schema\*(Aq,
\&      schema_args => [@connect_info],
\&      db_sandbox_dir => \*(Aq~/opt/database\-sandbox\*(Aq,
\&    );
.Ve
.PP
This then gives you a nice totally standalone database sandbox which you can
reuse for other projects, etc.
.PP
\fIOPTIONAL: Specify dbic_dh_args\fR
.IX Subsection "OPTIONAL: Specify dbic_dh_args"
.PP
Optionally, you can specify additional arguments to the constructor for the
"dbic_dh" attribute.  Useful arguments might include additional \f(CW\*(C`databases\*(C'\fR
we should build fixtures for, \f(CW\*(C`to_version\*(C'\fR and \f(CW\*(C`force_overwrite\*(C'\fR.
.PP
See "" in DBIx::Class::DeploymentHandler for more information on supported init
arguments.  See "dbic_dh" for how we merge default arguments with your custom
arguments.
.PP
\fIOther Initial Arguments\fR
.IX Subsection "Other Initial Arguments"
.PP
For normal usage the remaining init args are probably not particularly useful
and reflect a desire for long term code flexibility and clean design.
.SS version
.IX Subsection "version"
Prints to STDOUT a message regarding the version of <DBIC:Migration> that you
are currently running.
.SS status
.IX Subsection "status"
Returns the state of the deployed database (if it is deployed) and the state
of the current \f(CW\*(C`schema\*(C'\fR version.  Sends this as a string to STDOUT
.SS prepare
.IX Subsection "prepare"
Creates a \f(CW\*(C`fixtures\*(C'\fR and \f(CW\*(C`migrations\*(C'\fR directory under "target_dir" (if they
don't already exist) and makes deployment files for the current schema.  If
deployment files exist, will fail unless you "overwrite_migrations".
.PP
The \f(CW\*(C`migrations\*(C'\fR directory reflects a directory structure as documented in
DBIx::Class::DeploymentHandler.
.PP
If this is the first version, we create directories and initial DLL, etc.  For
versions greater than 1, we will also generate diffs and copy any fixture
configs etc (as well as generating a fresh 'all_table.json' fixture config). For
safety reasons, we never overwrite any fixture configs.
.SS install
.IX Subsection "install"
Installs either the current schema version (if already prepared) or the target
version specified via any \f(CW\*(C`to_version\*(C'\fR flags sent as an dbic_dh_args to the
database which is connected via "schema".
.PP
If you try to install to a database that has already been installed, you'll get
an error.  See "drop_tables".
.SS upgrade
.IX Subsection "upgrade"
Run upgrade files to bring the database into sync with the current schema
version.
.SS downgrade
.IX Subsection "downgrade"
Run down files to bring the database down to the previous version from what is
installed to the database
.SS drop_tables
.IX Subsection "drop_tables"
Drops all the tables in the connected database with no backup or recovery.  For
real! (Make sure you are not connected to Prod, for example).
.SS delete_table_rows
.IX Subsection "delete_table_rows"
Does a \f(CW\*(C`delete\*(C'\fR on each table in the database, which clears out all your data
but preserves tables.  For Real!  You might want this if you need to load
and unload fixture sets during testing, or perhaps to get rid of data that
accumulated in the database while running an app in development, before dumping
fixtures.
.SS dump_named_sets
.IX Subsection "dump_named_sets"
Given an array of fixture set names, dump them for the current database version.
.SS dump_all_sets
.IX Subsection "dump_all_sets"
Takes no arguments just dumps all the sets we can find for the current database
version.
.SS make_schema
.IX Subsection "make_schema"
Given an existing database, reverse engineer a DBIx::Class Schema in the
"target_dir" (under \f(CW\*(C`dumped_db\*(C'\fR).  You can use this if you need to bootstrap
your DBIC files.
.SS populate
.IX Subsection "populate"
Given an array of fixture set names, populate the current database version with
the matching sets for that version.
.PP
Skips the table \f(CW\*(C`dbix_class_deploymenthandler_versions\*(C'\fR, so you don't lose
deployment info (this is different from "drop_tables" which does delete it.)
.SS diagram
.IX Subsection "diagram"
Experimental feature.  Although not specifically a migration task, I find it
useful to output visuals of my databases.  This command will place a file in
your "target_dir" called \f(CW\*(C`db\-diagram\-vXXX.png\*(C'\fR where \f(CW\*(C`XXX\*(C'\fR is he current
\&\f(CW\*(C`schema\*(C'\fR version.
.PP
This is using the Graphviz producer (SQL::Translator::Producer::GraphViz)
which in turn requires Graphviz.  Since this is not always trivial to
install, I do not require it.  You will need to add it manually to your
\&\f(CW\*(C`Makefile.PL\*(C'\fR or \f(CW\*(C`dist.ini\*(C'\fR and manage it yourself.
.PP
This feature is experimental and currently does not offer any options, as I
am still determining the best way to meet the need without exceeding the
scope of DBIx::Class::Migration.  Consider this command a 'freebee' and
please don't depend on it in your custom code.
.SS install_if_needed
.IX Subsection "install_if_needed"
If the database is not installed, do so.  Accepts a hash of callbacks or
instructions to perform should installation be needed/
.PP
.Vb 6
\&    $migration\->install_if_needed(
\&      on_install => sub {
\&        my ($schema, $local_migration) = @_;
\&        DBIx::Class::Migration::Population\->new(
\&          schema=>shift)\->populate(\*(Aqall_tables\*(Aq);
\&      });
.Ve
.PP
The following callbacks / instructions are permitted
.IP on_install 4
.IX Item "on_install"
Accepts: Coderef
.Sp
Given a coderef, execute it after the database is installed.  The coderef
gets passed two arguments: \f(CW$schema\fR and \f(CW$self\fR (the current migration
object).
.IP default_fixture_sets 4
.IX Item "default_fixture_sets"
Accepts: Arrayref of fixture sets
.Sp
.Vb 2
\&    $migration\->install_if_needed(
\&      default_fixture_sets => [\*(Aqall_tables\*(Aq]);
.Ve
.Sp
After database installation, populate the fixtures in order.
.SS install_version_storage
.IX Subsection "install_version_storage"
If the targeted (connected) database does not have the versioning tables
installed, this will install them.  The version is set to whatever your
\&\f(CW\*(C`schema\*(C'\fR version currently is.
.PP
You will only need to use this command in the case where you have an existing
database that you are reverse engineering and you need to setup versioning
storage since you can't rebuild the database from scratch (such as if you have
a huge production database that you now want to start versioning).
.SS delete_named_sets
.IX Subsection "delete_named_sets"
Given a (or a list) of fixture sets, delete them if the exist in the current
schema version.
.PP
Yes, this really deletes, you've been warned (check in your code to a source
control repository).
.SH ENVIRONMENT
.IX Header "ENVIRONMENT"
When running DBIx::Class::Migration we set some \f(CW%ENV\fR variables during
installation, up / downgrading, so that your Perl run scripts (see
"DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator\e'PERL SCRIPTS'")
can receive some useful information.  The Following \f(CW%ENV\fR variables are set:
.PP
.Vb 6
\&    DBIC_MIGRATION_SCHEMA_CLASS => $self\->schema_class
\&    DBIC_MIGRATION_TARGET_DIR => $self\->target_dir
\&    DBIC_MIGRATION_FIXTURE_DIR => catdir($self\->target_dir, \*(Aqfixtures\*(Aq, $self\->dbic_dh\->schema_version),
\&    DBIC_MIGRATION_SCHEMA_VERSION => $self\->dbic_dh\->schema_version
\&    DBIC_MIGRATION_TO_VERSION => $self\->dbic_dh\->to_version
\&    DBIC_MIGRATION_DATABASE_VERSION => $self\->dbic_dh\->schema_version || 0
.Ve
.PP
You might find having these available in your migration scripts useful for
doing things like 'populate a database from a fixture set, if it exists, but
if not run a bunch of inserts.
.SH THANKS
.IX Header "THANKS"
Because of the awesomeness of CPAN and the work of many others, all this
functionality is provided with a few hundred lines of code.  In fact, I spent
a lot more time writing docs and tests than anything else. Here are some
particular projects / people I'd like to thank:
.PP
First, thanks to \f(CW\*(C`mst\*(C'\fR for providing me a big chunk of code that served to
kickstart my work, and served as an valuable prototype.
.PP
Thanks to \f(CW\*(C`frew\*(C'\fR for the awesome DBIx::Class::DeploymentHandler which gives
us such a powerful base for organizing database versions.  Thanks to all the
authors of DBIx::Class::Fixtures for giving me a foundation for managing
sets of data.  Lastly, thanks to the DBIx::Class cabal for all the work done
in making the DBIx::Class ORM so amazingly powerful.
.PP
Additionally thanks to the creators / maintainers for Test::mysqld and
Test::Postgresql58, which made it easy to create developer level sandboxes for
these popular open source databases.
.PP
As usual, thanks to the Moose cabal for making Perl programming fun and
beautiful.  Lastly, a shout-out to the Dist::Zilla cabal for making it so I
don't need to write my own build and deployment tools.
.SH AUTHOR
.IX Header "AUTHOR"
John Napiorkowski <email:jjnapiork@cpan.org>
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
The following is a list of identified contributors.  Please let me know if I
missed you.
.PP
.Vb 10
\&    https://github.com/pjcj
\&    https://github.com/chromatic
\&    https://github.com/bentglasstube
\&    https://github.com/logie17
\&    https://github.com/RsrchBoy
\&    https://github.com/vkroll
\&    https://github.com/felliott
\&    https://github.com/mkrull
\&    https://github.com/moltar
\&    https://github.com/andyjones
\&    https://github.com/pnu
\&    https://github.com/n7st
\&    https://github.com/willsheppard
\&    https://github.com/mulletboy2
\&    https://github.com/mohawk2
\&    https://github.com/manwar
\&    https://github.com/upasana\-me
\&    https://github.com/rabbiveesh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Class::DeploymentHandler, DBIx::Class::Fixtures, DBIx::Class,
DBIx::Class::Schema::Loader, Moo, DBIx::Class::Migration::Script,
DBIx::Class::Migration::Population, dbic-migration, SQL::Translator,
Test::mysqld, Test::Postgresql58.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2013\-2015, John Napiorkowski <email:jjnapiork@cpan.org>
.PP
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
