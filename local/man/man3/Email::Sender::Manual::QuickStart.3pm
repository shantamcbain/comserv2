.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Email::Sender::Manual::QuickStart 3pm"
.TH Email::Sender::Manual::QuickStart 3pm 2024-01-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Email::Sender::Manual::QuickStart \- how to start using Email::Sender right now
.SH VERSION
.IX Header "VERSION"
version 2.601
.SH "PERL VERSION"
.IX Header "PERL VERSION"
This library should run on perls released even a long time ago.  It should
work on any version of perl released in the last five years.
.PP
Although it may work on older versions of perl, no guarantee is made that the
minimum required version will not be increased.  The version may be increased
for any reason, and there is no promise that patches will be accepted to
lower the minimum required perl.
.SH "QUICK START"
.IX Header "QUICK START"
.SS "Let's Send Some Mail!"
.IX Subsection "Let's Send Some Mail!"
No messing around, let's just send some mail.
.PP
.Vb 3
\&  use strict;
\&  use Email::Sender::Simple qw(sendmail);
\&  use Email::MIME;
\&
\&  # You can make an email object in lots of ways.  Pick one you like!
\&  my $email = Email::MIME\->create(...);
\&
\&  sendmail($email);
.Ve
.PP
That's it.  Your message goes out into the internet and tries to get delivered
to \f(CW\*(C`x.ample@example.com\*(C'\fR.
.PP
In the example above, \f(CW$email\fR could be an Email::MIME object, a MIME::Entity,
a string containing an email message, or one of several other types of input.
If \f(CW\*(C`Email::Abstract\*(C'\fR can understand a value, it can be passed to
Email::Sender::Simple.  Email::Sender::Simple tries to make a good guess about
how to send the message.  It will usually try to use the \fIsendmail\fR program on
unix-like systems and to use SMTP on Windows.  You can specify a transport, if
you need to, but normally that shouldn't be an issue.  (See "Picking a
Transport", though, for more information.)
.PP
Also note that we imported and used a \f(CW\*(C`sendmail\*(C'\fR routine in the example above.
This is exactly the same as saying:
.PP
.Vb 1
\&  Email::Sender::Simple\->send($email);
.Ve
.PP
\&...but it's a lot easier to type.  You can use either one.
.PP
\fIenvelope information\fR
.IX Subsection "envelope information"
.PP
We didn't have to tell Email::Sender::Simple where to send the message.  If you
don't specify recipients, it will use all the email addresses it can find in
the \fITo\fR and \fICc\fR headers by default.  It will use Email::Address::XS to
parse those fields.  Similarly, if no sender is specified, it will use the
first address found in the \fIFrom\fR header.
.PP
In most email transmission systems, though, the headers are not by necessity
tied to the addresses used as the sender and recipients.  For example, your
message header might say "From: mailing\-list@example.com" while your SMTP
client says "MAIL FROM:<verp\-1234@lists.example.com>".  This is a
powerful feature, and is necessary for many email application.  Being able to
set those distinctly is important, and Email::Sender::Simple lets you do this:
.PP
.Vb 1
\&  sendmail($email, { to => [ $to_1, $to_2 ], from => $sender });
.Ve
.PP
\fIin case of error\fR
.IX Subsection "in case of error"
.PP
When the message is sent successfully (at least on to its next hop),
\&\f(CW\*(C`sendmail\*(C'\fR will return a true value \-\- specifically, an
Email::Sender::Success object.  This object only rarely has much use.
What's more useful is what happens if the message can't be sent.
.PP
If there is an error sending the message, an exception will be thrown.  It will
be an object belonging to the class Email::Sender::Failure.  This object
will have a \f(CW\*(C`message\*(C'\fR attribute describing the nature of the failure.  There
are several specialized forms of failure, like
Email::Sender::Failure::Multi, which is thrown when more than one error is
encountered when trying to send.  You don't need to know about these to use
Email::Sender::Simple, though.  All you need to know is that \f(CW\*(C`sendmail\*(C'\fR
returns true on success and dies on failure.
.PP
If you'd rather not have to catch exceptions for failure to send mail, you can
use the \f(CW\*(C`try_to_send\*(C'\fR method, which can be imported as \f(CW\*(C`try_to_sendmail\*(C'\fR.
This method will return just false on failure to send mail.
.PP
For example:
.PP
.Vb 1
\&  Email::Sender::Simple\->try_to_send($email, { ... });
\&
\&  use Email::Sender::Simple qw(try_to_sendmail);
\&  try_to_sendmail($email, { ... });
.Ve
.PP
Some Email::Sender transports can signal success if some, but not all,
recipients could be reached.  Email::Sender::Simple does its best to ensure
that this never happens.  When you are using Email::Sender::Simple, mail should
either be sent or not.  Partial success should never occur.
.SS "Picking a Transport"
.IX Subsection "Picking a Transport"
\fIpassing in your own transport\fR
.IX Subsection "passing in your own transport"
.PP
If Email::Sender::Simple doesn't pick the transport you want, or if you have
more specific needs, you can specify a transport in several ways.  The simplest
is to build a transport object and pass it in.  You can read more about
transports elsewhere.  For now, we'll just assume that you need to send mail
via SMTP on an unusual port.  You can send mail like this:
.PP
.Vb 4
\&  my $transport = Email::Sender::Transport::SMTP\->new({
\&    host => \*(Aqsmtp.example.com\*(Aq,
\&    port => 2525,
\&  });
\&
\&  sendmail($email, { transport => $transport });
.Ve
.PP
Now, instead of guessing at what transport to use, Email::Sender::Simple will
use the one you provided.  This transport will have to be specified for each
call to \f(CW\*(C`sendmail\*(C'\fR, so you might want to look at other options, which follow.
.PP
\fIspecifying transport in the environment\fR
.IX Subsection "specifying transport in the environment"
.PP
If you have a program that makes several calls to Email::Sender::Simple, and
you need to run this program using a different mailserver, you can set
environment variables to change the default.  For example:
.PP
.Vb 3
\&  $ export EMAIL_SENDER_TRANSPORT=SMTP
\&  $ export EMAIL_SENDER_TRANSPORT_host=smtp.example.com
\&  $ export EMAIL_SENDER_TRANSPORT_port=2525
\&
\&  $ perl your\-program
.Ve
.PP
It is important to note that if you have set the default transport by using the
environment, \fIno subsequent \fR\f(CI\*(C`transport\*(C'\fR\fI args to \fR\f(CI\*(C`sendmail\*(C'\fR\fI will be
respected\fR.  If you set the default transport via the environment, that's it.
Everything will use that transport.  (Also, note that while we gave the host and
port arguments above in lower case, the casing of arguments in the environment
is flattened to support systems where environment variables are of a fixed
case.  So, \f(CW\*(C`EMAIL_SENDER_TRANSPORT_PORT\*(C'\fR would also work.
.PP
This is extremely valuable behavior, as it allows you to audit every message
that would be sent by a program by running something like this:
.PP
.Vb 2
\&  $ export EMAIL_SENDER_TRANSPORT=Maildir
\&  $ perl your\-program
.Ve
.PP
In that example, any message sent via Email::Sender::Simple would be delivered
to a maildir in the current directory.
.PP
\fIsubclassing to change the default transport\fR
.IX Subsection "subclassing to change the default transport"
.PP
If you want to use a library that will behave like Email::Sender::Simple but
with a different default transport, you can subclass Email::Sender::Simple and
replace the \f(CW\*(C`build_default_transport\*(C'\fR method.
.SS Testing
.IX Subsection "Testing"
Email::Sender::Simple makes it very, very easy to test code that sends email.
The simplest way is to do something like this:
.PP
.Vb 3
\&  use Test::More;
\&  BEGIN { $ENV{EMAIL_SENDER_TRANSPORT} = \*(AqTest\*(Aq }
\&  use YourCode;
\&
\&  YourCode\->run;
\&
\&  my @deliveries = Email::Sender::Simple\->default_transport\->deliveries;
.Ve
.PP
Now you've got an array containing every delivery performed through
Email::Sender::Simple, in order.  Because you set the transport via the
environment, no other code will be able to force a different transport.
.PP
When testing code that forks, Email::Sender::Transport::SQLite can be used
to allow every child process to deliver to a single, easy to inspect
destination database.
.SS "Hey, where's my Bcc support?"
.IX Subsection "Hey, where's my Bcc support?"
A common question is "Why doesn't Email::Sender::Simple automatically respect
my Bcc header?"  This is often combined with, "Here is a patch to 'fix' it."
This is not a bug or oversight. Bcc is being ignored intentionally for now
because simply adding the Bcc addresses to the message recipients would not
produce the usually-desired behavior.
.PP
For example, here is a set of headers:
.PP
.Vb 4
\&  From: sender@example.com
\&  To:   to_rcpt@example.com
\&  Cc:   cc_rcpt@example.com
\&  Bcc:  the_boss@example.com
.Ve
.PP
In this case, we'd expect the message to be delivered to three people:
to_rcpt, cc_rcpt, and the_boss.  This is why it's often suggested that the
Bcc header should be a source for envelope recipients.  In fact, though, a
message with a Bcc header should probably be delivered \fIonly\fR to the Bcc
recipients.  The "B" in Bcc means "blind."  The other recipients should not
see who has been Bcc'd.  This means you want to send \fItwo\fR messages:  one to
to_rcpt and cc_rcpt, with no Bcc header present; and another to the_boss
only, with the Bcc header.  \fBIf you just pick up Bcc addresses as
recipients, everyone will see who was Bcc'd.\fR
.PP
Email::Sender::Simple promises to send messages atomically.  That is:  it
won't deliver to only some of the recipients, and not to others.  That means
it can't automatically detect the Bcc header and make two deliveries.  There
would be a possibility for the second to fail after the first succeeded,
which would break the promise of a pure failure or success.
.PP
The other strategy for dealing with Bcc is to remove the Bcc header from the
message and then inject the message with an envelope including the Bcc
addresses.  The envelope information will not be visible to the final
recipients, so this is safe.  Unfortunately, this requires modifying the
message, and Email::Sender::Simple should not be altering the mutable email
object passed to it.  There is no \f(CW\*(C`clone\*(C'\fR method on Email::Abstract, so it
cannot just build a clone and modify that, either.  When such a method
exists, Bcc handling may be possible.
.PP
\fIExample Bcc Handling\fR
.IX Subsection "Example Bcc Handling"
.PP
If you want to support the Bcc header now, it is up to you to deal with how
you want to munge the mail and inject the (possibly) munged copies into your
outbound mailflow.  It is not reasonable to suggest that
Email::Sender::Simple do this job.
.PP
Example 1: Explicitly set the envelope recipients for Bcc recipients
.IX Subsection "Example 1: Explicitly set the envelope recipients for Bcc recipients"
.PP
Create the email without a Bcc header, send it to the Bcc users explicitly
and then send it to the To/Cc users implicitly.
.PP
.Vb 1
\&  my $message = create_email_mime_msg;  # <\- whatever you do to get the message
\&
\&  $message\->header_set(\*(Aqbcc\*(Aq);          # delete the Bcc header before sending
\&  sendmail($message, { to => $rcpt });  # send to explicit Bcc address
\&  sendmail($message);                   # and then send as normal
.Ve
.PP
Example 2: Explicitly set the envelope recipients for all recipients
.IX Subsection "Example 2: Explicitly set the envelope recipients for all recipients"
.PP
You can make a single call to \f(CW\*(C`sendmail\*(C'\fR by pulling all the recipient
addresses from the headers yourself and specifying all the envelope
recipients once.  Again, delete the Bcc header before the message is sent.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "This is awesome!  Where can I learn more?"
.IX Subsection "This is awesome! Where can I learn more?"
Have a look at Email::Sender::Manual, where all the manual's documents are
listed.  You can also look at the documentation for Email::Sender::Simple
and the various Email::Sender::Transport classes.
.SH AUTHOR
.IX Header "AUTHOR"
Ricardo Signes <cpan@semiotic.systems>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2024 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
