.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator 3pm"
.TH DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator 3pm 2024-07-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator \- Manage your SQL and Perl migrations in nicely laid out directories
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This class is the meat of DBIx::Class::DeploymentHandler.  It takes care
of generating serialized schemata  as well as sql files to move from one
version of a schema to the rest.  One of the hallmark features of this class
is that it allows for multiple sql files for deploy and upgrade, allowing
developers to fine tune deployment.  In addition it also allows for perl
files to be run at any stage of the process.
.PP
For basic usage see DBIx::Class::DeploymentHandler::HandlesDeploy.  What's
documented here is extra fun stuff or private methods.
.SH "DIRECTORY LAYOUT"
.IX Header "DIRECTORY LAYOUT"
Arguably this is the best feature of DBIx::Class::DeploymentHandler.
It's spiritually based upon DBIx::Migration::Directories, but has a
lot of extensions and modifications, so even if you are familiar with it,
please read this.  I feel like the best way to describe the layout is with
the following example:
.PP
.Vb 10
\& $sql_migration_dir
\& |\- _source
\& |  |\- deploy
\& |     |\- 1
\& |     |  \`\- 001\-auto.yml
\& |     |\- 2
\& |     |  \`\- 001\-auto.yml
\& |     \`\- 3
\& |        \`\- 001\-auto.yml
\& |\- SQLite
\& |  |\- downgrade
\& |  |  \`\- 2\-1
\& |  |     \`\- 001\-auto.sql
\& |  |\- deploy
\& |  |  \`\- 1
\& |  |     \`\- 001\-auto.sql
\& |  \`\- upgrade
\& |     |\- 1\-2
\& |     |  \`\- 001\-auto.sql
\& |     \`\- 2\-3
\& |        \`\- 001\-auto.sql
\& |\- _common
\& |  |\- downgrade
\& |  |  \`\- 2\-1
\& |  |     \`\- 002\-remove\-customers.pl
\& |  \`\- upgrade
\& |     \`\- 1\-2
\& |     |  \`\- 002\-generate\-customers.pl
\& |     \`\- _any
\& |        \`\- 999\-bump\-action.pl
\& \`\- MySQL
\&    |\- downgrade
\&    |  \`\- 2\-1
\&    |     \`\- 001\-auto.sql
\&    |\- initialize
\&    |  \`\- 1
\&    |     |\- 001\-create_database.pl
\&    |     \`\- 002\-create_users_and_permissions.pl
\&    |\- deploy
\&    |  \`\- 1
\&    |     \`\- 001\-auto.sql
\&    \`\- upgrade
\&       \`\- 1\-2
\&          \`\- 001\-auto.sql
.Ve
.PP
So basically, the code
.PP
.Vb 1
\& $dm\->deploy(1)
.Ve
.PP
on an \f(CW\*(C`SQLite\*(C'\fR database that would simply run
\&\f(CW\*(C`$sql_migration_dir/SQLite/deploy/1/001\-auto.sql\*(C'\fR.  Next,
.PP
.Vb 1
\& $dm\->upgrade_single_step([1,2])
.Ve
.PP
would run \f(CW\*(C`$sql_migration_dir/SQLite/upgrade/1\-2/001\-auto.sql\*(C'\fR followed by
\&\f(CW\*(C`$sql_migration_dir/_common/upgrade/1\-2/002\-generate\-customers.pl\*(C'\fR, and
finally punctuated by
\&\f(CW\*(C`$sql_migration_dir/_common/upgrade/_any/999\-bump\-action.pl\*(C'\fR.
.PP
\&\f(CW\*(C`.pl\*(C'\fR files don't have to be in the \f(CW\*(C`_common\*(C'\fR directory, but most of the time
they should be, because perl scripts are generally database independent.
.PP
Note that unlike most steps in the process, \f(CW\*(C`initialize\*(C'\fR will not run SQL, as
there may not even be an database at initialize time.  It will run perl scripts
just like the other steps in the process, but nothing is passed to them.
Until people have used this more it will remain freeform, but a recommended use
of initialize is to have it prompt for username and password, and then call the
appropriate \f(CW\*(C`CREATE DATABASE\*(C'\fR commands etc.
.SS "Directory Specification"
.IX Subsection "Directory Specification"
The following subdirectories are recognized by this DeployMethod:
.ie n .IP """_source""" 2
.el .IP \f(CW_source\fR 2
.IX Item "_source"
This directory can contain the following directories:
.RS 2
.ie n .IP """deploy""" 2
.el .IP \f(CWdeploy\fR 2
.IX Item "deploy"
This directory merely contains directories named after schema
versions, which in turn contain \f(CW\*(C`yaml\*(C'\fR files that are serialized versions
of the schema at that version.  These files are not for editing by hand.
.RE
.RS 2
.RE
.ie n .IP """_preprocess_schema""" 2
.el .IP \f(CW_preprocess_schema\fR 2
.IX Item "_preprocess_schema"
This directory can contain the following directories:
.RS 2
.ie n .IP """downgrade""" 2
.el .IP \f(CWdowngrade\fR 2
.IX Item "downgrade"
This directory merely contains directories named after migrations, which are of
the form \f(CW\*(C`$from_version\-$to_version\*(C'\fR.  Inside of these directories you may put
Perl scripts which are to return a subref that takes the arguments \f(CW\*(C`$from_schema, $to_schema\*(C'\fR, which are SQL::Translator::Schema objects.
.ie n .IP """upgrade""" 2
.el .IP \f(CWupgrade\fR 2
.IX Item "upgrade"
This directory merely contains directories named after migrations, which are of
the form \f(CW\*(C`$from_version\-$to_version\*(C'\fR.  Inside of these directories you may put
Perl scripts which are to return a subref that takes the arguments \f(CW\*(C`$from_schema, $to_schema\*(C'\fR, which are SQL::Translator::Schema objects.
.RE
.RS 2
.Sp
A typical usage of \f(CW\*(C`_preprocess_schema\*(C'\fR is to define indices or other non-DBIC
type metadata.  Here is an example of how one might do that:
.Sp
The following coderef could be placed in a file called
\&\fI_preprocess_schema/1\-2/001\-add\-user\-index.pl\fR
.Sp
.Vb 2
\& sub {
\&    my ($from, $to) = @_;
\&
\&    $to\->get_table(\*(AqUsers\*(Aq)\->add_index(
\&       name => \*(Aqidx_Users_name\*(Aq,
\&       fields => [\*(Aqname\*(Aq],
\&    )
\& }
.Ve
.Sp
This would ensure that in version 2 of the schema the generated migrations
include an index on \f(CW\*(C`Users.name\*(C'\fR.  Frustratingly, due to the nature of
SQL::Translator, you'll need to add this to each migration or it will detect
that it was left out and kindly remove the index for you.
.Sp
An alternative to the above, which is likely to be a lot less annoying, is to
define such data in your schema directly, and only change it as you need to:
.Sp
.Vb 1
\& package MyApp::Schema::Result::User;
\&
\& #[...]
\&
\& sub sqlt_deploy_hook ( $self, $sqlt_table ) {
\&    $sqlt_table\->add_index(name => \*(Aqidx_Users_name\*(Aq, fields => [ \*(Aqname\*(Aq ]);
\& }
.Ve
.RE
.ie n .IP $storage_type 2
.el .IP \f(CW$storage_type\fR 2
.IX Item "$storage_type"
This is a set of scripts that gets run depending on what your storage type is.
If you are not sure what your storage type is, take a look at the producers
listed for SQL::Translator.  Also note, \f(CW\*(C`_common\*(C'\fR is a special case.
\&\f(CW\*(C`_common\*(C'\fR will get merged into whatever other files you already have.  This
directory can contain the following directories itself:
.RS 2
.ie n .IP """initialize""" 2
.el .IP \f(CWinitialize\fR 2
.IX Item "initialize"
If you are using the \f(CW\*(C`initialize\*(C'\fR functionality,
you should call \fBinitialize()\fR before calling \f(CW\*(C`install\*(C'\fR. This has the same structure as the
\&\f(CW\*(C`deploy\*(C'\fR subdirectory as well; that is, it has a directory for each schema
version.  Unlike \f(CW\*(C`deploy\*(C'\fR, \f(CW\*(C`upgrade\*(C'\fR, and \f(CW\*(C`downgrade\*(C'\fR though, it can only run
\&\f(CW\*(C`.pl\*(C'\fR files, and the coderef in the perl files get no arguments passed to them.
.ie n .IP """deploy""" 2
.el .IP \f(CWdeploy\fR 2
.IX Item "deploy"
Gets run when the schema is \f(CW\*(C`deploy\*(C'\fRed.  Structure is a directory per schema
version, and then files are merged with \f(CW\*(C`_common\*(C'\fR and run in filename order.
\&\f(CW\*(C`.sql\*(C'\fR files are merely run, as expected.  \f(CW\*(C`.pl\*(C'\fR files are run according to
"PERL SCRIPTS".
.ie n .IP """upgrade""" 2
.el .IP \f(CWupgrade\fR 2
.IX Item "upgrade"
Gets run when the schema is \f(CW\*(C`upgrade\*(C'\fRd.  Structure is a directory per upgrade
step, (for example, \f(CW\*(C`1\-2\*(C'\fR for upgrading from version 1 to version 2,) and then
files are merged with \f(CW\*(C`_common\*(C'\fR and run in filename order.  \f(CW\*(C`.sql\*(C'\fR files are
merely run, as expected.  \f(CW\*(C`.pl\*(C'\fR files are run according to "PERL SCRIPTS".
.ie n .IP """downgrade""" 2
.el .IP \f(CWdowngrade\fR 2
.IX Item "downgrade"
Gets run when the schema is \f(CW\*(C`downgrade\*(C'\fRd.  Structure is a directory per
downgrade step, (for example, \f(CW\*(C`2\-1\*(C'\fR for downgrading from version 2 to version
1,) and then files are merged with \f(CW\*(C`_common\*(C'\fR and run in filename order.
\&\f(CW\*(C`.sql\*(C'\fR files are merely run, as expected.  \f(CW\*(C`.pl\*(C'\fR files are run according to
"PERL SCRIPTS".
.RE
.RS 2
.RE
.PP
Note that there can be an \f(CW\*(C`_any\*(C'\fR in the place of any of the versions (like
\&\f(CW\*(C`1\-2\*(C'\fR or \f(CW1\fR), which means those scripts will be run \fBevery\fR time.  So if
you have an \f(CW\*(C`_any\*(C'\fR in \f(CW\*(C`_common/upgrade\*(C'\fR, that script will get run for every
upgrade.
.SH "PERL SCRIPTS"
.IX Header "PERL SCRIPTS"
A perl script for this tool is very simple.  It merely needs to contain an
anonymous sub that takes a DBIx::Class::Schema and the version set as it's
arguments.
.PP
A very basic perl script might look like:
.PP
.Vb 1
\& #!perl
\&
\& use strict;
\& use warnings;
\&
\& use DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers
\&    \*(Aqschema_from_schema_loader\*(Aq;
\&
\& schema_from_schema_loader({ naming => \*(Aqv4\*(Aq }, sub {
\&   my $schema = shift;
\&
\&   # [1] for deploy, [1,2] for upgrade or downgrade, probably used with _any
\&   my $versions = shift;
\&
\&   $schema\->resultset(\*(AqUsers\*(Aq)\->create({
\&     name => \*(Aqroot\*(Aq,
\&     password => \*(Aqroot\*(Aq,
\&   })
\& })
.Ve
.PP
Note that the above uses
"schema_from_schema_loader" in DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers.
Using a raw coderef is strongly discouraged as it is likely to break as you
modify your schema.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This class is an implementation of
DBIx::Class::DeploymentHandler::HandlesDeploy.  Pretty much all the
documentation is there.
.SH ATTRIBUTES
.IX Header "ATTRIBUTES"
.SS ignore_ddl
.IX Subsection "ignore_ddl"
This attribute will, when set to true (default is false), cause the DM to use
SQL::Translator to use the \f(CW\*(C`_source\*(C'\fR's serialized SQL::Translator::Schema
instead of any pregenerated SQL.  If you have a development server this is
probably the best plan of action as you will not be putting as many generated
files in your version control.  Goes well with with \f(CW\*(C`databases\*(C'\fR of \f(CW\*(C`[]\*(C'\fR.
.SS force_overwrite
.IX Subsection "force_overwrite"
When this attribute is true generated files will be overwritten when the
methods which create such files are run again.  The default is false, in which
case the program will die with a message saying which file needs to be deleted.
.SS schema
.IX Subsection "schema"
The DBIx::Class::Schema (\fBrequired\fR) that is used to talk to the database
and generate the DDL.
.SS storage
.IX Subsection "storage"
The DBIx::Class::Storage that is \fIactually\fR used to talk to the database
and generate the DDL.  This is automatically created with "_build_storage".
.SS sql_translator_args
.IX Subsection "sql_translator_args"
The arguments that get passed to SQL::Translator when it's used.
.SS script_directory
.IX Subsection "script_directory"
The directory (default \f(CW\*(Aqsql\*(Aq\fR) that scripts are stored in
.SS databases
.IX Subsection "databases"
The types of databases (default \f(CW\*(C`[qw( MySQL SQLite PostgreSQL )]\*(C'\fR) to
generate files for
.SS txn_prep
.IX Subsection "txn_prep"
This attribute will, when set to false (default is true), cause the DM to
\&\fIgenerate\fR SQL without enclosing \f(CW\*(C`BEGIN\*(C'\fR and \f(CW\*(C`COMMIT\*(C'\fR statements.
.PP
The (current) default behavior is to create DDLs wrapped in transactions and
to remove anything that looks like a transaction from the generated DDLs
later \fIwhen running the deployment\fR.
.PP
Since this default behavior is error prone it is strictly recommended to set
the \f(CW\*(C`txn_prep\*(C'\fR attribute to false and remove all transaction statements from
previously generated DDLs.
.SS txn_wrap
.IX Subsection "txn_wrap"
Set to true (which is the default) to wrap all upgrades and deploys in a single
transaction. This option should be false if the DDL files contain transaction
statements.
.PP
Keep in mind that not all DBMSes support transactions over DDL statements.
.SS schema_version
.IX Subsection "schema_version"
The version the schema on your harddrive is at.  Defaults to
\&\f(CW\*(C`$self\->schema\->schema_version\*(C'\fR.
.SS version_source
.IX Subsection "version_source"
The source name used to register the version storage with \f(CW\*(C`schema\*(C'\fR.  Defaults
to \f(CW\*(C`_\|_VERSION\*(C'\fR.
.SH AUTHOR
.IX Header "AUTHOR"
Arthur Axel "fREW" Schmidt <frioux+cpan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
