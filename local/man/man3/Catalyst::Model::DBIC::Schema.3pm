.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Model::DBIC::Schema 3pm"
.TH Catalyst::Model::DBIC::Schema 3pm 2023-07-30 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::Model::DBIC::Schema \- DBIx::Class::Schema Model Class
.SH SYNOPSIS
.IX Header "SYNOPSIS"
First, prepare your database schema using DBIx::Class, see
Catalyst::Helper::Model::DBIC::Schema for how to generate a
DBIx::Class::Schema from your database using the Helper script, and
DBIx::Class::Schema::Loader::Base.
.PP
A typical usage of the helper script would be:
.PP
.Vb 3
\&    script/myapp_create.pl model FilmDB DBIC::Schema MyApp::Schema::FilmDB \e
\&        create=static dbi:mysql:filmdb dbusername dbpass \e
\&        quote_names=1
.Ve
.PP
If you are unfamiliar with DBIx::Class, see DBIx::Class::Manual::Intro
first.
.PP
These examples assume that you already have a schema called
\&\f(CW\*(C`MyApp::Schema::FilmDB\*(C'\fR, which defines some Result classes for tables in
\&\f(CW\*(C`MyApp::Schema::FilmDB::Result::Actor\*(C'\fR and
\&\f(CW\*(C`MyApp::Schema::FilmDB::Result::Film\*(C'\fR. Either created by the helper script (as
shown above) or manually.
.PP
The helper also creates a Model in \f(CW\*(C`lib/MyApp/Model/FilmDB.pm\*(C'\fR, if you already
have a schema you can create just the Model using:
.PP
.Vb 2
\&    script/myapp_create.pl model FilmDB DBIC::Schema MyApp::Schema::FilmDB
\&        dbi:mysql:filmdb dbusername dbpass
.Ve
.PP
The connect_info is optional and will be hardcoded into the Model if provided.
It's better to configure it in your Catalyst config file, which will also
override any hardcoded config, see "connect_info" for examples.
.PP
Now you have a working Model which accesses your separate DBIC Schema. This can
be used/accessed in the normal Catalyst manner, via \f(CW\*(C`$c\->model()\*(C'\fR:
.PP
.Vb 2
\&  my $db_model = $c\->model(\*(AqFilmDB\*(Aq);         # a Catalyst::Model
\&  my $dbic     = $c\->model(\*(AqFilmDB\*(Aq)\->schema; # the actual DBIC object
.Ve
.PP
There is also a shortcut, which returns a DBIx::Class::ResultSet directly,
instead of a Catalyst::Model:
.PP
.Vb 1
\&  my $rs = $c\->model(\*(AqFilmDB::Actor\*(Aq);
.Ve
.PP
See DBIx::Class::ResultSet to find out more about which methods can be
called on ResultSets.
.PP
You can also define your own ResultSet methods to encapsulate the
database/business logic of your applications. These go into, for example,
\&\f(CW\*(C`lib/MyApp/Schema/FilmDB/ResultSet/Actor.pm\*(C'\fR. The class must inherit from
DBIx::Class::ResultSet and is automatically loaded.
.PP
Then call your methods like any other DBIx::Class::ResultSet method:
.PP
.Vb 1
\&    $c\->model(\*(AqFilmDB::Actor\*(Aq)\->SAG_members
.Ve
.SS "Some examples:"
.IX Subsection "Some examples:"
.Vb 2
\&  # to access schema methods directly:
\&  $c\->model(\*(AqFilmDB\*(Aq)\->schema\->source(...);
\&
\&  # to access the source object, resultset, and class:
\&  $c\->model(\*(AqFilmDB\*(Aq)\->source(...);
\&  $c\->model(\*(AqFilmDB\*(Aq)\->resultset(...);
\&  $c\->model(\*(AqFilmDB\*(Aq)\->class(...);
\&
\&  # For resultsets, there\*(Aqs an even quicker shortcut:
\&  $c\->model(\*(AqFilmDB::Actor\*(Aq)
\&  # is the same as $c\->model(\*(AqFilmDB\*(Aq)\->resultset(\*(AqActor\*(Aq)
\&
\&  # To get the composed schema for making new connections:
\&  my $newconn = $c\->model(\*(AqFilmDB\*(Aq)\->composed_schema\->connect(...);
\&
\&  # Or the same thing via a convenience shortcut:
\&  my $newconn = $c\->model(\*(AqFilmDB\*(Aq)\->connect(...);
\&
\&  # or, if your schema works on different storage drivers:
\&  my $newconn = $c\->model(\*(AqFilmDB\*(Aq)\->composed_schema\->clone();
\&  $newconn\->storage_type(\*(Aq::LDAP\*(Aq);
\&  $newconn\->connection(...);
\&
\&  # and again, a convenience shortcut
\&  my $newconn = $c\->model(\*(AqFilmDB\*(Aq)\->clone();
\&  $newconn\->storage_type(\*(Aq::LDAP\*(Aq);
\&  $newconn\->connection(...);
.Ve
.PP
To set up authentication, see "Setting up DBIC authentication" below.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is a Catalyst Model for DBIx::Class::Schema\-based Models.  See
the documentation for Catalyst::Helper::Model::DBIC::Schema for
information on generating these Models via Helper scripts.
.PP
When your Catalyst app starts up, a thin Model layer is created as an interface
to your DBIC Schema. It should be clearly noted that the model object returned
by \f(CW\*(C`$c\->model(\*(AqFilmDB\*(Aq)\*(C'\fR is NOT itself a DBIC schema or resultset object,
but merely a wrapper proving methods to access the underlying
schema.
.PP
In addition to this model class, a shortcut class is generated for each 
source in the schema, allowing easy and direct access to a resultset of the 
corresponding type. These generated classes are even thinner than the model 
class, providing no public methods but simply hooking into Catalyst's 
\&\fBmodel()\fR accessor via the 
ACCEPT_CONTEXT mechanism. The complete 
contents of each generated class is roughly equivalent to the following:
.PP
.Vb 5
\&  package MyApp::Model::FilmDB::Actor
\&  sub ACCEPT_CONTEXT {
\&      my ($self, $c) = @_;
\&      $c\->model(\*(AqFilmDB\*(Aq)\->resultset(\*(AqActor\*(Aq);
\&  }
.Ve
.PP
In short, there are three techniques available for obtaining a DBIC 
resultset object:
.PP
.Vb 2
\&  # the long way
\&  my $rs = $c\->model(\*(AqFilmDB\*(Aq)\->schema\->resultset(\*(AqActor\*(Aq);
\&
\&  # using the shortcut method on the model object
\&  my $rs = $c\->model(\*(AqFilmDB\*(Aq)\->resultset(\*(AqActor\*(Aq);
\&
\&  # using the generated class directly
\&  my $rs = $c\->model(\*(AqFilmDB::Actor\*(Aq);
.Ve
.PP
In order to add methods to a DBIC resultset, you cannot simply add them to 
the source (row, table) definition class; you must define a separate custom 
resultset class. This is just a matter of making a
\&\f(CW\*(C`lib/MyApp/Schema/ResultSet/Actor.pm\*(C'\fR class that inherits from
DBIx::Class::ResultSet, if you are using
"load_namespaces" in DBIx::Class::Schema, the default for helper script generated
schemas.
.PP
See "Predefined searches" in DBIx::Class::Manual::Cookbook 
for information on definining your own DBIx::Class::ResultSet classes for
use with "load_classes" in DBIx::Class::Schema, the old default.
.SH "CONFIG PARAMETERS"
.IX Header "CONFIG PARAMETERS"
.SS schema_class
.IX Subsection "schema_class"
This is the classname of your DBIx::Class::Schema Schema.  It needs
to be findable in \f(CW@INC\fR, but it does not need to be inside the 
\&\f(CW\*(C`Catalyst::Model::\*(C'\fR namespace.  This parameter is required.
.SS connect_info
.IX Subsection "connect_info"
This is a hashref or arrayref of connection parameters, which are specific to
your \f(CW\*(C`storage_type\*(C'\fR (see your storage type documentation for more details). If
you only need one parameter (e.g. the DSN), you can just pass a string.
.PP
This is not required if \f(CW\*(C`schema_class\*(C'\fR already has connection information
defined inside itself (which isn't highly recommended, but can be done.)
.PP
For DBIx::Class::Storage::DBI, which is the only supported
\&\f(CW\*(C`storage_type\*(C'\fR in DBIx::Class at the time of this writing, the
parameters are your dsn, username, password, and connect options hashref.
.PP
See "connect_info" in DBIx::Class::Storage::DBI for a detailed explanation
of the arguments supported.
.PP
Examples:
.PP
.Vb 5
\&  connect_info => {
\&    dsn => \*(Aqdbi:Pg:dbname=mypgdb\*(Aq,
\&    user => \*(Aqpostgres\*(Aq,
\&    password => \*(Aq\*(Aq
\&  }
\&
\&  connect_info => {
\&    dsn => \*(Aqdbi:SQLite:dbname=foo.db\*(Aq,
\&    on_connect_do => [
\&      \*(AqPRAGMA synchronous = OFF\*(Aq,
\&    ]
\&  }
\&
\&  connect_info => {
\&    dsn => \*(Aqdbi:Pg:dbname=mypgdb\*(Aq,
\&    user => \*(Aqpostgres\*(Aq,
\&    password => \*(Aq\*(Aq,
\&    pg_enable_utf8 => 1,
\&    on_connect_do => [
\&      \*(Aqsome SQL statement\*(Aq,
\&      \*(Aqanother SQL statement\*(Aq,
\&    ],
\&  }
.Ve
.PP
Or using Config::General:
.PP
.Vb 10
\&    <Model::FilmDB>
\&        schema_class   MyApp::Schema::FilmDB
\&        traits Caching
\&        <connect_info>
\&            dsn   dbi:Pg:dbname=mypgdb
\&            user   postgres
\&            password ""
\&            auto_savepoint 1
\&            quote_names 1
\&            on_connect_do   some SQL statement
\&            on_connect_do   another SQL statement
\&        </connect_info>
\&        user_defined_schema_accessor foo
\&    </Model::FilmDB>
.Ve
.PP
or
.PP
.Vb 4
\&    <Model::FilmDB>
\&        schema_class   MyApp::Schema::FilmDB
\&        connect_info   dbi:SQLite:dbname=foo.db
\&    </Model::FilmDB>
.Ve
.PP
Or using YAML:
.PP
.Vb 11
\&  Model::MyDB:
\&      schema_class: MyDB
\&      traits: Caching
\&      connect_info:
\&          dsn: dbi:Oracle:mydb
\&          user: mtfnpy
\&          password: mypass
\&          LongReadLen: 1000000
\&          LongTruncOk: 1
\&          on_connect_call: \*(Aqdatetime_setup\*(Aq
\&          quote_names: 1
.Ve
.PP
The old arrayref style with hashrefs for DBI then DBIx::Class options is also
supported:
.PP
.Vb 10
\&  connect_info => [
\&    \*(Aqdbi:Pg:dbname=mypgdb\*(Aq,
\&    \*(Aqpostgres\*(Aq,
\&    \*(Aq\*(Aq,
\&    {
\&      pg_enable_utf8 => 1,
\&    },
\&    {
\&      auto_savepoint => 1,
\&      on_connect_do => [
\&        \*(Aqsome SQL statement\*(Aq,
\&        \*(Aqanother SQL statement\*(Aq,
\&      ],
\&    }
\&  ]
.Ve
.SS traits
.IX Subsection "traits"
Array of Traits to apply to the instance. Traits are Moose::Roles.
.PP
They are relative to the \f(CW\*(C`MyApp::TraitFor::Model::DBIC::Schema::\*(C'\fR, then
the \f(CW\*(C`Catalyst::TraitFor::Model::DBIC::Schema::\*(C'\fR namespaces, unless
prefixed with \f(CW\*(C`+\*(C'\fR in which case they are taken to be a fully qualified name.
E.g.:
.PP
.Vb 2
\&    traits Caching
\&    traits +MyApp::TraitFor::Model::Foo
.Ve
.PP
A new instance is created at application time, so any consumed required
attributes, coercions and modifiers will work.
.PP
Traits are applied at "COMPONENT" in Catalyst::Component time using
CatalystX::Component::Traits.
.PP
\&\f(CW\*(C`ref $self\*(C'\fR will be an anon class if any traits are applied, \f(CW\*(C`$self\->_original_class_name\*(C'\fR will be the original class.
.PP
When writing a Trait, interesting points to modify are \f(CW\*(C`BUILD\*(C'\fR, "setup" and
"ACCEPT_CONTEXT".
.PP
Traits that come with the distribution:
.IP Catalyst::TraitFor::Model::DBIC::Schema::Caching 4
.IX Item "Catalyst::TraitFor::Model::DBIC::Schema::Caching"
.PD 0
.IP Catalyst::TraitFor::Model::DBIC::Schema::Replicated 4
.IX Item "Catalyst::TraitFor::Model::DBIC::Schema::Replicated"
.IP Catalyst::TraitFor::Model::DBIC::Schema::SchemaProxy 4
.IX Item "Catalyst::TraitFor::Model::DBIC::Schema::SchemaProxy"
.IP Catalyst::TraitFor::Model::DBIC::Schema::PerRequestSchema 4
.IX Item "Catalyst::TraitFor::Model::DBIC::Schema::PerRequestSchema"
.PD
.SS compose_namespaces
.IX Subsection "compose_namespaces"
This model calls "compose_namespace" in DBIx::Class::Schema by default to
install classes into the model namespaces. You can turn that off by
setting this attribute to false. Default is true.
.SS install_model_shortcuts
.IX Subsection "install_model_shortcuts"
If you don't want shortcut models so you can do e.g. \f(CW\*(C`$c\->model(\*(AqDB::Book\*(Aq)\*(C'\fR set this attribute to false, Default is true.
.SS storage_type
.IX Subsection "storage_type"
Allows the use of a different \f(CW\*(C`storage_type\*(C'\fR than what is set in your
\&\f(CW\*(C`schema_class\*(C'\fR (which in turn defaults to \f(CW\*(C`::DBI\*(C'\fR if not set in current
DBIx::Class).  Completely optional, and probably unnecessary for most
people until other storage backends become available for DBIx::Class.
.SH ATTRIBUTES
.IX Header "ATTRIBUTES"
The keys you pass in the model configuration are available as attributes.
.PP
Other attributes available:
.SS connect_info
.IX Subsection "connect_info"
Your connect_info args normalized to hashref form (with dsn/user/password.) See
"connect_info" in DBIx::Class::Storage::DBI for more info on the hashref form of
"connect_info".
.SS model_name
.IX Subsection "model_name"
The model name Catalyst uses to resolve this model, the part after
\&\f(CW\*(C`::Model::\*(C'\fR or \f(CW\*(C`::M::\*(C'\fR in your class name. E.g. if your class name is
\&\f(CW\*(C`MyApp::Model::DB\*(C'\fR the "model_name" will be \f(CW\*(C`DB\*(C'\fR.
.SS _default_cursor_class
.IX Subsection "_default_cursor_class"
What to reset your "cursor_class" in DBIx::Class::Storage::DBI to if a custom one
doesn't work out. Defaults to DBIx::Class::Storage::DBI::Cursor.
.SH "ATTRIBUTES FROM MooseX::Traits::Pluggable"
.IX Header "ATTRIBUTES FROM MooseX::Traits::Pluggable"
.SS _original_class_name
.IX Subsection "_original_class_name"
The class name of your model before any "traits" are applied. E.g.
\&\f(CW\*(C`MyApp::Model::DB\*(C'\fR.
.SS _traits
.IX Subsection "_traits"
Unresolved arrayref of traits passed in the config.
.SS _resolved_traits
.IX Subsection "_resolved_traits"
Traits you used resolved to full class names.
.SH "CONFIGURING YOUR SCHEMA AND RESULTSETS"
.IX Header "CONFIGURING YOUR SCHEMA AND RESULTSETS"
See the documentation for
Catalyst::TraitFor::Model::DBIC::Schema::SchemaProxy for instructions on how
to pass config values from your Catalyst config to your
DBIx::Class::Schema and/or DBIx::Class::ResultSet classes.
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Instantiates the Model based on the above-documented \->config parameters.
The only required parameter is \f(CW\*(C`schema_class\*(C'\fR.  \f(CW\*(C`connect_info\*(C'\fR is
required in the case that \f(CW\*(C`schema_class\*(C'\fR does not already have connection
information defined for it.
.SS schema
.IX Subsection "schema"
Accessor which returns the connected schema being used by the this model.
There are direct shortcuts on the model class itself for
schema\->resultset, schema\->source, and schema\->class.
.SS composed_schema
.IX Subsection "composed_schema"
Accessor which returns the composed schema, which has no connection info,
which was used in constructing the "schema". Useful for creating
new connections based on the same schema/model.  There are direct shortcuts
from the model object for composed_schema\->clone and composed_schema\->connect
.PP
If "compose_namespaces" is not true, "composed_schema" is equivalent to
\&\f(CW\*(C`$model\->schema_class\->clone\*(C'\fR.
.SS clone
.IX Subsection "clone"
Shortcut for \->composed_schema\->clone
.SS connect
.IX Subsection "connect"
Shortcut for \->composed_schema\->connect
.SS source
.IX Subsection "source"
Shortcut for \->schema\->source
.SS class
.IX Subsection "class"
Shortcut for \->schema\->class
.SS resultset
.IX Subsection "resultset"
Shortcut for \->schema\->resultset
.SS txn_do
.IX Subsection "txn_do"
Shortcut for \->schema\->txn_do
.SS txn_scope_guard
.IX Subsection "txn_scope_guard"
Shortcut for \->schema\->txn_scope_guard
.SS storage
.IX Subsection "storage"
Provides an accessor for the connected schema's storage object.
.PP
See DBIx::Class::Storage and DBIx::Class::Storage::DBI.
.SS setup
.IX Subsection "setup"
Called at \f(CW\*(C`BUILD\*(C'\fR time before configuration, but after "connect_info" is
set. To do something after configuuration use \f(CW\*(C`after BUILD =>\*(C'\fR.
.PP
Receives a hashref of args passed to \f(CW\*(C`BUILD\*(C'\fR.
.SS ACCEPT_CONTEXT
.IX Subsection "ACCEPT_CONTEXT"
Point of extension for doing things at \f(CW\*(C`$c\->model\*(C'\fR time with context,
returns the model instance, see "ACCEPT_CONTEXT" in Catalyst::Manual::Intro for
more information.
.SH ENVIRONMENT
.IX Header "ENVIRONMENT"
.IP CMDS_NO_SOURCES 4
.IX Item "CMDS_NO_SOURCES"
Set this variable if you will be using schemas with no sources (Result classes)
to disable the warning. The warning is there because having no Result classes
is usually a mistake.
.SH "Setting up DBIC authentication"
.IX Header "Setting up DBIC authentication"
You can set this up with 
Catalyst::Authentication::Store::DBIx::Class in MyApp.pm:
.PP
.Vb 1
\&  package MyApp;
\&
\&  use Catalyst qw/... Authentication .../;
\&
\&  ...
\&
\&  _\|_PACKAGE_\|_\->config(\*(AqPlugin::Authentication\*(Aq =>
\&                {
\&                    default_realm => \*(Aqmembers\*(Aq,
\&                    members => {
\&                        credential => {
\&                            class => \*(AqPassword\*(Aq,
\&                            password_field => \*(Aqpassword\*(Aq,
\&                            password_type => \*(Aqhashed\*(Aq
\&                            password_hash_type => \*(AqSHA\-256\*(Aq
\&                        },
\&                        store => {
\&                            class => \*(AqDBIx::Class\*(Aq,
\&                            user_model => \*(AqDB::User\*(Aq,
\&                            role_relation => \*(Aqroles\*(Aq,
\&                            role_field => \*(Aqrolename\*(Aq,
\&                        }
\&                    }
\&                });
.Ve
.SH "METHOD PROXYING"
.IX Header "METHOD PROXYING"
The automatic proxying to the underlying DBIx::Class::Schema has been
removed as of version \f(CW0.34\fR, to enable this feature add \f(CW\*(C`SchemaProxy\*(C'\fR to
"traits".
.PP
See Catalyst::TraitFor::Model::DBIC::Schema::SchemaProxy.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
General Catalyst Stuff:
.PP
Catalyst::Manual, Catalyst::Test, Catalyst::Request,
Catalyst::Response, Catalyst::Helper, Catalyst,
.PP
Stuff related to DBIC and this Model style:
.PP
DBIx::Class, DBIx::Class::Schema,
DBIx::Class::Schema::Loader, Catalyst::Helper::Model::DBIC::Schema,
CatalystX::Component::Traits, MooseX::Traits::Pluggable
.PP
Traits:
.PP
Catalyst::TraitFor::Model::DBIC::Schema::Caching,
Catalyst::TraitFor::Model::DBIC::Schema::Replicated,
Catalyst::TraitFor::Model::DBIC::Schema::SchemaProxy,
Catalyst::TraitFor::Model::DBIC::Schema::PerRequestSchema,
Catalyst::TraitFor::Model::DBIC::Schema::QueryLog
.SH AUTHOR
.IX Header "AUTHOR"
Brandon L Black \f(CW\*(C`blblack at gmail.com\*(C'\fR
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
caelum: Rafael Kitover \f(CW\*(C`rkitover at cpan.org\*(C'\fR
.PP
dandv: Dan Dascalescu \f(CW\*(C`dandv at cpan.org\*(C'\fR
.PP
bluefeet: Aran Deltac \f(CW\*(C`bluefeet@cpan.org\*(C'\fR
.PP
t0m: Tomas Doran \f(CW\*(C`bobtfish@bobtfish.net\*(C'\fR
.PP
osfameron: \f(CW\*(C`osfameron@cpan.org\*(C'\fR
.PP
ozum: Ozum Eldogan \f(CW\*(C`ozum@ozum.net\*(C'\fR
.PP
Pavel I. Shaydo \f(CW\*(C`zwon@trinitum.org\*(C'\fR
.PP
SineSwiper: Brendan Byrd <byrd.b@insightcom.com>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2006 \- 2010
the Catalyst::Model::DBIC::Schema "AUTHOR" and "CONTRIBUTORS"
as listed above.
.SH LICENSE
.IX Header "LICENSE"
This program is free software. You can redistribute it and/or modify it
under the same terms as Perl itself.
