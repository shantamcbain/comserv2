.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Statement::Function 3pm"
.TH SQL::Statement::Function 3pm 2020-10-21 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Statement::Function \- abstract base class for all function executing terms
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&  # this class does not have a common constructor, because all derived classes
\&  # have their special requirements
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
SQL::Statement::Function is an abstract base class providing the interface
for all function executing terms.
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 2
\&  SQL::Statement::Function
\&  ISA SQL::Statement::Term
.Ve
.SH METHODS
.IX Header "METHODS"
.SS DESTROY
.IX Subsection "DESTROY"
Destroys the term and undefines the weak reference to the owner as well
as the reference to the parameter list.
.SH NAME
SQL::Statement::Function::UserFunc \- implements executing a perl subroutine
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 6
\&  # create an user function term with an SQL::Statement object as owner,
\&  # specifying the function name, the subroutine name (full qualified)
\&  # and the parameters to the subroutine
\&  my $term = SQL::Statement::Function::UserFunc\->new( $owner, $name, $sub, \e@params );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
SQL::Statement::Function::UserFunc implements a term which returns the result
of the specified subroutine.
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 2
\&  SQL::Statement::Function
\&  ISA SQL::Statement::Term
.Ve
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Instantiates a new \f(CW\*(C`SQL::Statement::Function::UserFunc\*(C'\fR instance.
.SS value
.IX Subsection "value"
Invokes the given subroutine with the values of the params and return it's
result:
.PP
.Vb 2
\&    my @params = map { $_\->value($eval); } @{ $self\->{PARAMS} };
\&    return $subpkg\->$subname( $self\->{OWNER}, @params );
.Ve
.SH NAME
SQL::Statement::Function::NumericEval \- implements numeric evaluation of a term
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an user function term with an SQL::Statement object as owner,
\&  # specifying the expression to evaluate and the parameters to the subroutine
\&  my $term = SQL::Statement::NumericEval\->new( $owner, $expr, \e@params );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
SQL::Statement::Function::NumericEval implements the numeric evaluation of a
term. All parameters are expected to be numeric.
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Function::NumericEval
\&  ISA SQL::Statement::Function
\&    ISA SQL::Statement::Term
.Ve
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Instantiates a new \f(CW\*(C`SQL::Statement::Function::NumericEval\*(C'\fR instance.
Takes \fR\f(CI$owner\fR\fI\fR, \fI\fR\f(CI$expr\fR\fI\fR and \fI\e@params\fR as arguments (in specified order).
.SS value
.IX Subsection "value"
Returns the result of the evaluated expression.
.SH NAME
SQL::Statement::Function::Trim \- implements the built\-in trim function support
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an trim function term with an SQL::Statement object as owner,
\&  # specifying the spec, char and the parameters to the subroutine
\&  my $term = SQL::Statement::Trim\->new( $owner, $spec, $char, \e@params );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
SQL::Statement::Function::Trim implements string trimming.
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Function::Trim
\&  ISA SQL::Statement::Function
\&    ISA SQL::Statement::Term
.Ve
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Instantiates a new \f(CW\*(C`SQL::Statement::Function::Trim\*(C'\fR instance.
Takes \fR\f(CI$owner\fR\fI\fR, \fI\fR\f(CI$spec\fR\fI\fR, \fI\fR\f(CI$char\fR\fI\fR and \fI\e@params\fR as arguments
(in specified order).
.PP
Meaning of the parameters:
.ie n .IP \fR\fI$spec\fR\fI\fR 4
.el .IP \fR\f(CI$spec\fR\fI\fR 4
.IX Item "$spec"
Can be on of 'LEADING', 'TRAILING' 'BOTH'. Trims the leading chars, trailing
chars or at both ends, respectively.
.Sp
Defaults to 'BOTH'.
.ie n .IP \fR\fI$char\fR\fI\fR 4
.el .IP \fR\f(CI$char\fR\fI\fR 4
.IX Item "$char"
The character to trim \- defaults to \f(CW\*(Aq \*(Aq\fR
.IP \fI\e@params\fR 4
.IX Item "@params"
Expected to be an array with exact 1 element (more are not evaluated).
.SS value
.IX Subsection "value"
Returns the trimmed value of first parameter argument.
.SH NAME
SQL::Statement::Function::SubString \- implements the built\-in sub\-string function support
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 6
\&  # create an substr function term with an SQL::Statement object as owner,
\&  # specifying the start and length of the sub string to extract from the
\&  # first element of \e@params
\&  my $term = SQL::Statement::SubString\->new( $owner, $start, $length, \e@params );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
SQL::Statement::Function::SubString implements a sub-string extraction term.
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Function::SubString
\&  ISA SQL::Statement::Function
\&    ISA SQL::Statement::Term
.Ve
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Instantiates a new \f(CW\*(C`SQL::Statement::Function::SubString\*(C'\fR instance.
Takes \fR\f(CI$owner\fR\fI\fR, \fI\fR\f(CI$start\fR\fI\fR, \fI\fR\f(CI$length\fR\fI\fR and \fI\e@params\fR as arguments
(in specified order).
.PP
Meaning of the parameters:
.ie n .IP \fR\fI$start\fR\fI\fR 4
.el .IP \fR\f(CI$start\fR\fI\fR 4
.IX Item "$start"
Specifies the start position to extract the sub-string. This is expected
to be a SQL::Statement::Term instance. The first character in a string
has the position 1.
.ie n .IP \fR\fI$length\fR\fI\fR 4
.el .IP \fR\f(CI$length\fR\fI\fR 4
.IX Item "$length"
Specifies the length of the extracted sub-string. This is expected
to be a SQL::Statement::Term instance.
.Sp
If omitted, everything to the end of the string is returned.
.IP \fI\e@params\fR 4
.IX Item "@params"
Expected to be an array with exact 1 element (more are not evaluated).
.SS value
.IX Subsection "value"
Returns the extracted sub-string value from first parameter argument.
.SH NAME
SQL::Statement::Function::StrConcat \- implements the built\-in string concatenation
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 5
\&  # create an substr function term with an SQL::Statement object as owner
\&  # and \e@params to concatenate
\&  my $term = SQL::Statement::StrConcat\->new( $owner, \e@params );
\&  # access the result of that operation
\&  $term\->value( $eval );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
SQL::Statement::Function::StrConcat implements a string concatenation term.
.SH INHERITANCE
.IX Header "INHERITANCE"
.Vb 3
\&  SQL::Statement::Function::StrConcat
\&  ISA SQL::Statement::Function
\&    ISA SQL::Statement::Term
.Ve
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Instantiates a new \f(CW\*(C`SQL::Statement::Function::StrConcat\*(C'\fR instance.
.SS value
.IX Subsection "value"
Returns the concatenated string composed of the parameter values.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2009\-2020 by Jens Rehsack: rehsackATcpan.org
.PP
All rights reserved.
.PP
You may distribute this module under the terms of either the GNU
General Public License or the Artistic License, as specified in
the Perl README file.
