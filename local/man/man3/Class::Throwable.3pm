.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Class::Throwable 3pm"
.TH Class::Throwable 3pm 2015-02-04 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Class::Throwable \- A minimal lightweight exception class
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use Class::Throwable;     
\&  
\&  # simple usage
\&  eval {
\&      # code code code,
\&      if ($something_goes_wrong) {
\&          throw Class::Throwable "Something has gone wrong";
\&      }
\&  };
\&  if ($@) {
\&      # we just print out the exception message here
\&      print "There has been an exception: " $@\->getMessage();  
\&      # but if we are debugging we get the whole
\&      # stack trace as well
\&      if (DEBUG) {
\&          print $@\->getStackTraceAsString();
\&      }
\&  }
\&  
\&  # it can be used to catch perl exceptions
\&  # and wrap them in a Class::Throwable exception
\&  eval {
\&      # generate a perl exception
\&      eval "2 / 0";
\&      # then throw our own with the 
\&      # perl exception as a sub\-exception
\&      throw Class::Throwable "Throwing an exception" => $@ if $@;
\&  };    
\&  if ($@) {
\&      # setting the verbosity to 
\&      # 2 gives a full stack trace
\&      # including any sub\-exceptions
\&      # (see below for examples of 
\&      # this output format)
\&      $@\->toString(2);  
\&  }
\&  
\&  # you can also declare inline exceptions
\&  use Class::Throwable qw(My::App::Exception::IllegalOperation);
\&  
\&  # set their global verbosity as well
\&  # with the class method
\&  My::App::Exception::IllegalOperation\->setVerbosity(2);
\&  
\&  eval {
\&      throw My::App::Exception::IllegalOperation "Bad, real bad";
\&  };
\&  
\&  # can also declare subclasses of Class::Throwable 
\&  # in other files, then when you import them, you
\&  # can set their verbosity
\&  use My::Sub::Class::In::A::Separate::File (VERBOSE => 1);
\&  
\&  throw My::Sub::Class::In::A::Separate::File "This exception will use a verbosity of 1";
\&  
\&  # you can even create exceptions, then throw them later
\&  my $e = Class::Throwable\->new("Things have gone bad, but I need to do something first", $@);
\&  
\&  # do something else ...
\&  
\&  # then throw the exception we created earlier
\&  throw $e
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module implements a minimal lightweight exception object. It is meant to be a compromise between more basic solutions like Carp which can only print information and cannot handle exception objects, and more more complex solutions like Exception::Class which can be used to define complex inline exceptions and has a number of module dependencies.
.SS "Inline Exceptions"
.IX Subsection "Inline Exceptions"
You can easily create new exception classes inline by passing them with the \f(CW\*(C`use\*(C'\fR statment like this:
.PP
.Vb 1
\&  use Class::Throwable (\*(AqMy::InlineException\*(Aq, \*(AqMy::Other::InlineException\*(Aq);
.Ve
.PP
This is a quick and easy way to define arbitrary exception classes without the need to manually create separate files or packages for them. However, it should be noted that subclasses of Class::Throwable cannot be used to define inline exceptions. If you attempt to do this, an exception will be thrown.
.SS "Exception Verbosity"
.IX Subsection "Exception Verbosity"
Class::Throwable offers a number of different types of diagnostic outputs to suit your needs. Most of this is controlled through the verbosity levels. If the verbosity level is set to 0 or below, an empty string is returned. If the value is set to 1, then the exception's message is returned. If the value is set to 2 or above, a full stack trace along with full stack traces for all sub-exceptions are returned in the format shown in \f(CW\*(C`stackTraceToString\*(C'\fR. The default verbosity setting is 1.
.PP
There are a number of ways in which you can set the verbosity of the exceptions produced by Class::Throwable. The simplest way is as the argument to the \f(CW\*(C`toString\*(C'\fR method. Using this method will override any other settings you may have, and insure that the output of this method is as you ask it to be.
.PP
.Vb 1
\&  $@\->toString(2);
.Ve
.PP
However, to use this style properly, this requires that you test the value of \f(CW$@\fR to be sure it is a Class::Throwable object. In some cases, this may not be an issue, while in others, it makes more sense to set verbosity on a wider scale.
.PP
For instance, if you define inline exceptions, then the simplest way to set a verbostity level for a particular inline exception is through the class method \f(CW\*(C`setVerbosity\*(C'\fR.
.PP
.Vb 1
\&  use Class::Throwable qw(My::InlineException);
\&  
\&  My::InlineException\->setVerbosity(2);
.Ve
.PP
This means that unless the \f(CW\*(C`toString\*(C'\fR verbosity argument overrides it, all \fIMy::InlineException\fR exceptions will use a verbosity setting of 2. This method means that you can easily \f(CW\*(C`print\*(C'\fR the value of \f(CW$@\fR and then any \fIMy::InlineException\fR exceptions will be automatically stringified with a verbosity level of 2. This can simplify exception catching by reducing the need to inspect the value of \f(CW$@\fR.
.PP
If you defined your exceptions as subclasses of Class::Throwable and stored them in separate files, then another means of setting the verbosity level is to assign it in the \f(CW\*(C`use\*(C'\fR statement.
.PP
.Vb 1
\&  use My::SeparateFileSubClass::Exception (VERBOSE => 2);
.Ve
.PP
This has the same effect as the \f(CW\*(C`setVerbosity\*(C'\fR class method, in fact, there is nothing to stop you from using the \f(CW\*(C`setVerbosity\*(C'\fR class method in this case if you like. This method can also be used on Class::Throwable itself, however, this does not set the verbosity level for all subclasses, only for Class::Throwable exceptions.
.PP
There is one last method which can be used. This method has the widest scope of all the methods. The variable \f(CW$Class::Throwable::DEFAULT_VERBOSITY\fR can be set. Setting this value will take effect if, 1) there is no value passed to the \f(CW\*(C`toString\*(C'\fR method and 2) no verbosity level has been set for the particular class, either through \f(CW\*(C`setVerbosity\*(C'\fR or the \f(CW\*(C`use\*(C'\fR statement.
.SS "Module exception retro-fitting"
.IX Subsection "Module exception retro-fitting"
It is possible to retrofit a module to use Class::Throwable exceptions if you want to. Basically this will allow modules which \f(CW\*(C`die\*(C'\fR with either strings or some other value, to throw Class::Throwable based exceptions. This feature is relatively new and should be considered to be experimental, any feedback on it is greatly appreciated.
.PP
\&\fBNOTE:\fR It is important to do module retrofitting at the earliest possible moment (preferrably before the module you are retrofitting is compiled), as it will override \f(CW\*(C`die\*(C'\fR within a specified package.
.PP
Other than all this, retrofitting is quite simple. Here is a basic example:
.PP
.Vb 1
\&  use Class::Throwable retrofit => \*(AqMy::Class\*(Aq;
.Ve
.PP
Now anytime \f(CW\*(C`die\*(C'\fR is called within \fIMy::Class\fR the calls will get converted to a Class::Throwable instance. You can also control how exceptions are converted like so:
.PP
.Vb 1
\&  use Class::Throwable retrofit => \*(AqMy::Class\*(Aq => sub { My::Exception\->throw(@_) };
.Ve
.PP
Now anytime \f(CW\*(C`die\*(C'\fR is called within \fIMy::Class\fR the calls will get converted to a My::Exception instance instead. Or a slightly more complex examples like this:
.PP
.Vb 5
\&  use Class::Throwable retrofit => (
\&                \*(AqMy::Class\*(Aq => sub { 
\&                    My::IllegalOperation\->throw(@_) if $_[0] =~ /^Illegal Operation/;
\&                    My::Exception\->throw(@_);
\&                });
.Ve
.PP
Now anytime \f(CW\*(C`die\*(C'\fR is called within \fIMy::Class\fR the calls will get converted to a My::Exception instance unless the exception matches the reg-exp, in which case an My::IllegalOperation exception is thrown.
.PP
There are a couple of points to be made regarding this functionality. First, it will add another stack frame to your exceptions (the retrofit routine basically). This is probably avoidable, but as this is still experimental I wanted to keep things somewhat simple. And second, if you supply a custom \f(CW\*(C`die\*(C'\fR handler, you should be sure that it will \f(CW\*(C`die\*(C'\fR somewhere within that routine. If you do not, you may have many un-intended consequences.
.SH METHODS
.IX Header "METHODS"
.SS Constructor
.IX Subsection "Constructor"
.ie n .IP "\fBthrow ($message, \fR\fB$sub_exception\fR\fB)\fR" 4
.el .IP "\fBthrow ($message, \fR\f(CB$sub_exception\fR\fB)\fR" 4
.IX Item "throw ($message, $sub_exception)"
The most common way to construct an exception object is to \f(CW\*(C`throw\*(C'\fR it. This method will construct the exception object, collect all the information from the call stack and then \f(CW\*(C`die\*(C'\fR.
.Sp
The optional \f(CW$message\fR argument can be used to pass custom information along with the exception object. Commonly this will be a string, but this module makes no attempt to enforce that it be anything other than a scalar, so more complex references or objects can be used. If no \f(CW$message\fR is passed in, a default one will be constructed for you.
.Sp
The second optional argument, \f(CW$sub_exception\fR, can be used to retain information about an exception which has been caught but might not be appropriate to be re-thrown and is better wrapped within a new exception object. While this argument will commonly be another Class::Throwable object, that fact is not enforced so you can pass in normal string based perl exceptions as well.
.Sp
If this method is called as an instance method on an exception object pre-built with \f(CW\*(C`new\*(C'\fR, only then is the stack trace information populated and the exception is then passed to \f(CW\*(C`die\*(C'\fR.
.ie n .IP "\fBnew ($message, \fR\fB$sub_exception\fR\fB)\fR" 4
.el .IP "\fBnew ($message, \fR\f(CB$sub_exception\fR\fB)\fR" 4
.IX Item "new ($message, $sub_exception)"
This is an alternate means of creating an exception object, it is much like \f(CW\*(C`throw\*(C'\fR, except that it does not collect stack trace information or \f(CW\*(C`die\*(C'\fR. It stores the \f(CW$message\fR and \f(CW$sub_exception\fR values, and then returns the exception instance, to be possibly thrown later on.
.SS "Class Methods"
.IX Subsection "Class Methods"
.IP "\fBsetVerbosity ($verbosity)\fR" 4
.IX Item "setVerbosity ($verbosity)"
This is a class method, if it is called with an instance, and exception will be thrown. This class method can be used to set the verbosity level for a particular class. See the section "Exception Verbosity" above for more details.
.SS Accessors
.IX Subsection "Accessors"
.IP \fBgetMessage\fR 4
.IX Item "getMessage"
This allows access to the message in the exception, to allow more granular exception reporting.
.IP \fBgetStackTrace\fR 4
.IX Item "getStackTrace"
This returns the raw stack trace information as an array of arrays. There are 10 values returned by \f(CW\*(C`caller\*(C'\fR (\f(CW$package\fR, \f(CW$filename\fR, \f(CW$line\fR, \f(CW$subroutine\fR, \f(CW$hasargs\fR, \f(CW$wantarray\fR, \f(CW$evaltext\fR, \f(CW$is_require\fR, \f(CW$hints\fR, \f(CW$bitmask\fR) we do not bother to capture the last two as they are subject to change and meant for internal use, all others are retained in the order returned by \f(CW\*(C`caller\*(C'\fR.
.IP \fBhasSubException\fR 4
.IX Item "hasSubException"
The returns true (\f(CW1\fR) if this exception has a sub-exception, and false (\f(CW0\fR) otherwise.
.IP \fBgetSubException\fR 4
.IX Item "getSubException"
This allows access to the stored sub-exception.
.SS "Output Methods"
.IX Subsection "Output Methods"
This object overloads the stringification operator, and will call the \f(CW\*(C`toString\*(C'\fR method to perform that stringification.
.IP "\fBtoString ($verbosity)\fR" 4
.IX Item "toString ($verbosity)"
This will print out the exception object's information at a variable level of verbosity which is specified be the optional argument \f(CW$verbosity\fR. See the section "Exception Verbosity" above for more details.
.IP \fBstringValue\fR 4
.IX Item "stringValue"
This will return the normal perl stringified value of the object without going through the \f(CW\*(C`toString\*(C'\fR method.
.IP \fBstackTraceToString\fR 4
.IX Item "stackTraceToString"
This method is used to print the stack trace information, the stack trace is presented in the following format:
.Sp
.Vb 3
\&    |\-\-[ main::foo called in my_script.pl line 12 ]
\&    |\-\-[ main::bar called in my_script.pl line 14 ]
\&    |\-\-[ main::baz called in my_script.pl line 16 ]
.Ve
.SH "EXAMPLE OUTPUT"
.IX Header "EXAMPLE OUTPUT"
Given the following code:
.PP
.Vb 3
\&  {
\&    package Foo;
\&    sub foo { eval { Bar::bar() }; throw Class::Throwable "Foo!!", $@ }
\&    
\&    package Bar;
\&    sub bar { eval { Baz::baz() }; throw Class::Throwable "Bar!!", $@ }
\&    
\&    package Baz;
\&    sub baz { throw Class::Throwable "Baz!!" }
\&  }
\&
\&  eval { Foo::foo() };
\&  print $@\->toString($verbosity) if $@;
.Ve
.PP
If you were to print the exception with verbosity of 0, you would get no output at all. This mode can be used to suppress exception output if needed. If you were to print the exception with verbosity of 1, you would get this output.
.PP
.Vb 1
\&  Class::Throwable : Foo!!
.Ve
.PP
If you were to print the exception with verbosity of 2, you would get this output.
.PP
.Vb 10
\&  Class::Throwable : Foo!!
\&    |\-\-[ Foo::foo called in test.pl line 26 ]
\&    |\-\-[ main::(eval) called in test.pl line 26 ]
\&    + Class::Throwable : Bar!!
\&        |\-\-[ Bar::bar called in test.pl line 19 ]
\&        |\-\-[ Foo::(eval) called in test.pl line 19 ]
\&        |\-\-[ Foo::foo called in test.pl line 26 ]
\&        |\-\-[ main::(eval) called in test.pl line 26 ]
\&        + Class::Throwable : Baz!!
\&            |\-\-[ Baz::baz called in test.pl line 21 ]
\&            |\-\-[ Bar::(eval) called in test.pl line 21 ]
\&            |\-\-[ Bar::bar called in test.pl line 19 ]
\&            |\-\-[ Foo::(eval) called in test.pl line 19 ]
\&            |\-\-[ Foo::foo called in test.pl line 26 ]
\&            |\-\-[ main::(eval) called in test.pl line 26 ]
.Ve
.SH BUGS
.IX Header "BUGS"
None that I am aware of. Of course, if you find a bug, let me know, and I will be sure to fix it. This is based on code which has been heavily used in production sites for over 2 years now without incident.
.SH "CODE COVERAGE"
.IX Header "CODE COVERAGE"
I use \fBDevel::Cover\fR to test the code coverage of my tests, below is the \fBDevel::Cover\fR report on this module test suite.
.PP
.Vb 7
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\& File                           stmt branch   cond    sub    pod   time  total
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\& Class/Throwable.pm            100.0   98.0   63.6  100.0  100.0  100.0   95.7
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
\& Total                         100.0   98.0   63.6  100.0  100.0  100.0   95.7
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There are a number of ways to do exceptions with perl, I was not really satisifed with the way anyone else did them, so I created this module. However, if you find this module unsatisfactory, you may want to check these out.
.IP Throwable 4
.IX Item "Throwable"
Throwable is a role for classes that are meant to be thrown as exceptions to standard program flow.
.IP Exception::Class 4
.IX Item "Exception::Class"
This in one of the more common exception classes out there. It does an excellent job with it's default behavior, and allows a number of complex options which can likely serve any needs you might have. My reasoning for not using this module is that I felt these extra options made things more complex than they needed to be, it also introduced a number of dependencies. I am not saying this module is bloated at all, but that for me it was far more than I have found I needed. If you have heavy duty exception needs, this is your module.
.IP Error 4
.IX Item "Error"
This is the classic perl exception module, complete with a try/catch mechanism. This module has a lot of bad karma associated with it because of the obscure nested closure memory leak that try/catch has. I never really liked the way its exception object Error::Simple did things either.
.IP Exception 4
.IX Item "Exception"
This module I have never really experimented with, so take my opinion with a large grain of salt. My problem with this module was always that it seemed to want to do too much. It attempts to make perl into a language with real exceptions, but messing with \f(CW%SIG\fR handlers and other such things. This can be dangerous territory sometimes, and for me, far more than my needs.
.SH AUTHOR
.IX Header "AUTHOR"
stevan little, <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004 by Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
