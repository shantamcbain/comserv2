.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DateTime::Format::Pg 3pm"
.TH DateTime::Format::Pg 3pm 2021-03-15 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DateTime::Format::Pg \- Parse and format PostgreSQL dates and times
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use DateTime::Format::Pg;
\&
\&  my $dt = DateTime::Format::Pg\->parse_datetime( \*(Aq2003\-01\-16 23:12:01\*(Aq );
\&
\&  # 2003\-01\-16 23:12:01
\&  DateTime::Format::Pg\->format_datetime($dt);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module understands the formats used by PostgreSQL for its DATE, TIME,
TIMESTAMP, and INTERVAL data types.  It can be used to parse these formats in
order to create \f(CW\*(C`DateTime\*(C'\fR or \f(CW\*(C`DateTime::Duration\*(C'\fR objects, and it can take a
\&\f(CW\*(C`DateTime\*(C'\fR or \f(CW\*(C`DateTime::Duration\*(C'\fR object and produce a string representing
it in a format accepted by PostgreSQL.
.SH CONSTRUCTORS
.IX Header "CONSTRUCTORS"
The following methods can be used to create \f(CW\*(C`DateTime::Format::Pg\*(C'\fR objects.
.IP \(bu 4
new( name => value, ... )
.Sp
Creates a new \f(CW\*(C`DateTime::Format::Pg\*(C'\fR instance. This is generally not
required for simple operations. If you wish to use a different parsing
style from the default then it is more comfortable to create an object.
.Sp
.Vb 2
\&  my $parser = DateTime::Format::Pg\->new()
\&  my $copy = $parser\->new( \*(Aqeuropean\*(Aq => 1 );
.Ve
.Sp
This method accepts the following options:
.RS 4
.IP \(bu 8
european
.Sp
If european is set to non-zero, dates are assumed to be in european
dd/mm/yyyy format. The default is to assume US mm/dd/yyyy format
(because this is the default for PostgreSQL).
.Sp
This option only has an effect if PostgreSQL is set to output dates in
the 'PostgreSQL' (DATE only) and 'SQL' (DATE and TIMESTAMP) styles.
.Sp
Note that you don't have to set this option if the PostgreSQL server has
been set to use the 'ISO' format, which is the default.
.IP \(bu 8
server_tz
.Sp
This option can be set to a \f(CW\*(C`DateTime::TimeZone\*(C'\fR object or a string
that contains a time zone name.
.Sp
This value must be set to the same value as the PostgreSQL server's time
zone in order to parse TIMESTAMP WITH TIMEZONE values in the
\&'PostgreSQL', 'SQL', and 'German' formats correctly.
.Sp
Note that you don't have to set this option if the PostgreSQL server has
been set to use the 'ISO' format, which is the default.
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBclone()\fR
.Sp
This method is provided for those who prefer to explicitly clone via a
method called \f(CWclone()\fR.
.Sp
.Vb 1
\&   my $clone = $original\->clone();
.Ve
.Sp
If called as a class method it will die.
.SH METHODS
.IX Header "METHODS"
This class provides the following methods. The parse_datetime, parse_duration,
format_datetime, and format_duration methods are general-purpose methods
provided for compatibility with other \f(CW\*(C`DateTime::Format\*(C'\fR modules.
.PP
The other methods are specific to the corresponding PostgreSQL date/time data
types. The names of these methods are derived from the name of the PostgreSQL
data type.  (Note: Prior to PostgreSQL 7.3, the TIMESTAMP type was equivalent
to the TIMESTAMP WITH TIME ZONE type. This data type corresponds to the
format/parse_timestamp_with_time_zone method but not to the
format/parse_timestamp method.)
.SS "PARSING METHODS"
.IX Subsection "PARSING METHODS"
This class provides the following parsing methods.
.PP
As a general rule, the parsing methods accept input in any format that the
PostgreSQL server can produce. However, if PostgreSQL's DateStyle is set to
\&'SQL' or 'PostgreSQL', dates can only be parsed correctly if the 'european'
option is set correctly (i.e. same as the PostgreSQL server).  The same is true
for time zones and the 'australian_timezones' option in all modes but 'ISO'.
.PP
The default DateStyle, 'ISO', will always produce unambiguous results
and is also parsed most efficiently by this parser class. I strongly
recommend using this setting unless you have a good reason not to.
.IP \(bu 4
parse_datetime($string,...)
.Sp
Given a string containing a date and/or time representation, this method
will return a new \f(CW\*(C`DateTime\*(C'\fR object.
.Sp
If the input string does not contain a date, it is set to 1970\-01\-01.
If the input string does not contain a time, it is set to 00:00:00. 
If the input string does not contain a time zone, it is set to the
floating time zone.
.Sp
If given an improperly formatted string, this method may die.
.IP \(bu 4
parse_timestamptz($string,...)
.IP \(bu 4
parse_timestamp_with_time_zone($string,...)
.Sp
Given a string containing a timestamp (date and time) representation,
this method will return a new \f(CW\*(C`DateTime\*(C'\fR object. This method is
suitable for the TIMESTAMPTZ (or TIMESTAMP WITH TIME ZONE) type.
.Sp
If the input string does not contain a time zone, it is set to the
floating time zone.
.Sp
Please note that PostgreSQL does not actually store a time zone along
with the TIMESTAMP WITH TIME ZONE (or TIMESTAMPTZ) type but will just
return a time stamp converted for the server's local time zone.
.Sp
If given an improperly formatted string, this method may die.
.IP \(bu 4
parse_timestamp($string,...)
.IP \(bu 4
parse_timestamp_without_time_zone($string,...)
.Sp
Similar to the functions above, but always returns a \f(CW\*(C`DateTime\*(C'\fR object
with a floating time zone. This method is suitable for the TIMESTAMP (or
TIMESTAMP WITHOUT TIME ZONE) type.
.Sp
If the server does return a time zone, it is ignored.
.Sp
If given an improperly formatted string, this method may die.
.IP \(bu 4
parse_timetz($string,...)
.IP \(bu 4
parse_time_with_time_zone($string,...)
.Sp
Given a string containing a time representation, this method will return
a new \f(CW\*(C`DateTime\*(C'\fR object. The date is set to 1970\-01\-01. This method is
suitable for the TIMETZ (or TIME WITH TIME ZONE) type.
.Sp
If the input string does not contain a time zone, it is set to the
floating time zone.
.Sp
Please note that PostgreSQL stores a numerical offset with its TIME WITH
TIME ZONE (or TIMETZ) type. It does not store a time zone name (such as
\&'Europe/Rome').
.Sp
If given an improperly formatted string, this method may die.
.IP \(bu 4
parse_time($string,...)
.IP \(bu 4
parse_time_without_time_zone($string,...)
.Sp
Similar to the functions above, but always returns an \f(CW\*(C`DateTime\*(C'\fR object
with a floating time zone. If the server returns a time zone, it is
ignored. This method is suitable for use with the TIME (or TIME WITHOUT
TIME ZONE) type.
.Sp
This ensures that the resulting \f(CW\*(C`DateTime\*(C'\fR object will always have the
time zone expected by your application.
.Sp
If given an improperly formatted string, this method may die.
.IP \(bu 4
parse_date($string,...)
.Sp
Given a string containing a date representation, this method will return
a new \f(CW\*(C`DateTime\*(C'\fR object. The time is set to 00:00:00 (floating time
zone). This method is suitable for the DATE type.
.Sp
If given an improperly formatted string, this method may die.
.IP \(bu 4
parse_duration($string)
.IP \(bu 4
parse_interval($string)
.Sp
Given a string containing a duration (SQL type INTERVAL) representation,
this method will return a new \f(CW\*(C`DateTime::Duration\*(C'\fR object.
.Sp
If given an improperly formatted string, this method may die.
.SS "FORMATTING METHODS"
.IX Subsection "FORMATTING METHODS"
This class provides the following formatting methods.
.PP
The output is always in the format mandated by the SQL standard (derived
from ISO 8601), which is parsed by PostgreSQL unambiguously in all
DateStyle modes.
.IP \(bu 4
format_datetime($datetime,...)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this method returns a string appropriate as
input for all date and date/time types of PostgreSQL. It will contain
date and time.
.Sp
If the time zone of the \f(CW\*(C`DateTime\*(C'\fR part is floating, the resulting
string will contain no time zone, which will result in the server's time
zone being used. Otherwise, the numerical offset of the time zone is
used.
.IP \(bu 4
format_time($datetime,...)
.IP \(bu 4
format_time_without_time_zone($datetime,...)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this method returns a string appropriate as
input for the TIME type (also known as TIME WITHOUT TIME ZONE), which
will contain the local time of the \f(CW\*(C`DateTime\*(C'\fR object and no time zone.
.IP \(bu 4
format_timetz($datetime)
.IP \(bu 4
format_time_with_time_zone($datetime)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this method returns a string appropriate as
input for the TIME WITH TIME ZONE type (also known as TIMETZ), which
will contain the local part of the \f(CW\*(C`DateTime\*(C'\fR object and a numerical
time zone.
.Sp
You should not use the TIME WITH TIME ZONE type to store dates with
floating time zones.  If the time zone of the \f(CW\*(C`DateTime\*(C'\fR part is
floating, the resulting string will contain no time zone, which will
result in the server's time zone being used.
.IP \(bu 4
format_date($datetime)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this method returns a string appropriate as
input for the DATE type, which will contain the date part of the
\&\f(CW\*(C`DateTime\*(C'\fR object.
.IP \(bu 4
format_timestamp($datetime)
.IP \(bu 4
format_timestamp_without_time_zone($datetime)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this method returns a string appropriate as
input for the TIMESTAMP type (also known as TIMESTAMP WITHOUT TIME
ZONE), which will contain the local time of the \f(CW\*(C`DateTime\*(C'\fR object and
no time zone.
.IP \(bu 4
format_timestamptz($datetime)
.IP \(bu 4
format_timestamp_with_time_zone($datetime)
.Sp
Given a \f(CW\*(C`DateTime\*(C'\fR object, this method returns a string appropriate as
input for the TIMESTAMP WITH TIME ZONE type, which will contain the
local part of the \f(CW\*(C`DateTime\*(C'\fR object and a numerical time zone.
.Sp
You should not use the TIMESTAMP WITH TIME ZONE type to store dates with
floating time zones.  If the time zone of the \f(CW\*(C`DateTime\*(C'\fR part is
floating, the resulting string will contain no time zone, which will
result in the server's time zone being used.
.IP \(bu 4
format_duration($du)
.IP \(bu 4
format_interval($du)
.Sp
Given a \f(CW\*(C`DateTime::Duration\*(C'\fR object, this method returns a string appropriate
as input for the INTERVAL type.
.SH LIMITATIONS
.IX Header "LIMITATIONS"
Some output formats of PostgreSQL have limitations that can only be passed on
by this class.
.PP
As a general rules, none of these limitations apply to the 'ISO' output
format.  It is strongly recommended to use this format (and to use
PostgreSQL's to_char function when another output format that's not
supposed to be handled by a parser of this class is desired). 'ISO' is
the default but you are advised to explicitly set it at the beginning of
the session by issuing a SET DATESTYLE TO 'ISO'; command in case the
server administrator changes that setting.
.PP
When formatting DateTime objects, this class always uses a format that's
handled unambiguously by PostgreSQL.
.SS "TIME ZONES"
.IX Subsection "TIME ZONES"
If DateStyle is set to 'PostgreSQL', 'SQL', or 'German', PostgreSQL does
not send numerical time zones for the TIMESTAMPTZ (or TIMESTAMP WITH
TIME ZONE) type. Unfortunately, the time zone names used instead can be
ambiguous: For example, 'EST' can mean \-0500, +1000, or +1100.
.PP
You must set the 'server_tz' variable to a time zone that is identical to that
of the PostgreSQL server. If the server is set to a different time zone (or the
underlying operating system interprets the time zone differently), the parser
will return wrong times.
.PP
You can avoid such problems by setting the server's time zone to UTC
using the SET TIME ZONE 'UTC' command and setting 'server_tz' parameter
to 'UTC' (or by using the ISO output format, of course).
.SS "EUROPEAN DATES"
.IX Subsection "EUROPEAN DATES"
For the SQL (for DATE and TIMSTAMP[TZ]) and the PostgreSQL (for DATE)
output format, the server can send dates in both European-style
\&'dd/mm/yyyy' and in US-style 'mm/dd/yyyy' format. In order to parse
these dates correctly, you have to pass the 'european' option to the
constructor or to the \f(CW\*(C`parse_xxx\*(C'\fR routines.
.PP
This problem does not occur when using the ISO or German output format
(and for PostgreSQL with TIMESTAMP[TZ] as month names are used then).
.SS "INTERVAL ELEMENTS"
.IX Subsection "INTERVAL ELEMENTS"
\&\f(CW\*(C`DateTime::Duration\*(C'\fR stores months, days, minutes and seconds
separately. PostgreSQL only stores months and seconds and disregards the
irregular length of days due to DST switching and the irregular length
of minutes due to leap seconds. Therefore, it is not possible to store
\&\f(CW\*(C`DateTime::Duration\*(C'\fR objects as SQL INTERVALs without the loss of some
information.
.SS "NEGATIVE INTERVALS"
.IX Subsection "NEGATIVE INTERVALS"
In the SQL and German output formats, the server does not send an
indication of the sign with intervals. This means that '1 month ago' and
\&'1 month' are both returned as '1 mon'.
.PP
This problem can only be avoided by using the 'ISO' or 'PostgreSQL'
output format.
.SH SUPPORT
.IX Header "SUPPORT"
Support for this module is provided via the datetime@perl.org email
list.  See http://lists.perl.org/ for more details.
.SH AUTHOR
.IX Header "AUTHOR"
Daisuke Maki <daisuke@endeworks.jp>
.SH "AUTHOR EMERITUS"
.IX Header "AUTHOR EMERITUS"
Claus A. Faerber <perl@faerber.muc.de>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2003 Claus A. Faerber. Copyright (c) 2005\-2007 Daisuke Maki
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.PP
The full text of the license can be found in the LICENSE file included with
this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
datetime@perl.org mailing list
.PP
http://datetime.perl.org/
