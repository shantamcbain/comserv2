.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Package::Variant 3pm"
.TH Package::Variant 3pm 2015-07-25 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Package::Variant \- Parameterizable packages
.SH SYNOPSIS
.IX Header "SYNOPSIS"
Creation of anonymous variants:
.PP
.Vb 8
\&  # declaring a variable Moo role
\&  package My::VariableRole::ObjectAttr;
\&  use strictures 2;
\&  use Package::Variant
\&    # what modules to \*(Aquse\*(Aq
\&    importing => [\*(AqMoo::Role\*(Aq],
\&    # proxied subroutines
\&    subs => [ qw(has around before after with) ];
\&
\&  sub make_variant {
\&    my ($class, $target_package, %arguments) = @_;
\&    # access arguments
\&    my $name = $arguments{name};
\&    # use proxied \*(Aqhas\*(Aq to add an attribute
\&    has $name => (is => \*(Aqlazy\*(Aq);
\&    # install a builder method
\&    install "_build_${name}" => sub {
\&      return $arguments{class}\->new;
\&    };
\&  }
\&
\&  # using the role
\&  package My::Class::WithObjectAttr;
\&  use strictures 2;
\&  use Moo;
\&  use My::VariableRole::ObjectAttr;
\&
\&  with ObjectAttr(name => \*(Aqsome_obj\*(Aq, class => \*(AqSome::Class\*(Aq);
\&
\&  # using our class
\&  my $obj = My::Class::WithObjectAttr\->new;
\&  $obj\->some_obj; # returns a Some::Class instance
.Ve
.PP
And the same thing, only with named variants:
.PP
.Vb 6
\&  # declaring a variable Moo role that can be named
\&  package My::VariableRole::ObjectAttrNamed;
\&  use strictures 2;
\&  use Package::Variant importing => [\*(AqMoo::Role\*(Aq],
\&    subs => [ qw(has around before after with) ];
\&  use Module::Runtime \*(Aqmodule_notional_filename\*(Aq; # only if you need protection
\&
\&  # this method is run at variant creation time to determine its custom
\&  # package name. it can use the arguments or do something entirely else.
\&  sub make_variant_package_name {
\&    my ($class, $package, %arguments) = @_;
\&    $package = "Private::$package"; # you can munge the input here if you like
\&    # only if you *need* protection
\&    die "Won\*(Aqt clobber $package" if $INC{module_notional_filename $package};
\&    return $package;
\&  }
\&
\&  # same as in the example above, except for the argument list. in this example
\&  # $package is the user input, and
\&  # $target_package is the actual package in which the variant gets installed
\&  sub make_variant {
\&    my ($class, $target_package, $package, %arguments) = @_;
\&    my $name = $arguments{name};
\&    has $name => (is => \*(Aqlazy\*(Aq);
\&    install "_build_${name}" => sub {return $arguments{class}\->new};
\&  }
\&
\&  # using the role
\&  package My::Class::WithObjectAttr;
\&  use strictures 2;
\&  use Moo;
\&  use My::VariableRole::ObjectAttrNamed;
\&
\&  # create the role under a specific name
\&  ObjectAttrNamed "My::Role" => (name => \*(Aqsome_obj\*(Aq, class => \*(AqSome::Class\*(Aq);
\&  # and use it
\&  with "Private::My::Role";
\&
\&  # using our class
\&  my $obj = My::Class::WithObjectAttr\->new;
\&  $obj\->some_obj; # returns a Some::Class instance
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module allows you to build a variable package that contains a package
template and can use it to build variant packages at runtime.
.PP
Your variable package will export a subroutine which will build a variant
package, combining its arguments with the template, and return the name of the
new variant package.
.PP
The implementation does not care about what kind of packages it builds, be they
simple function exporters, classes, singletons or something entirely different.
.SS "Declaring a variable package"
.IX Subsection "Declaring a variable package"
There are two important parts to creating a variable package. You first
have to give \f(CW\*(C`Package::Variant\*(C'\fR some basic information about what kind of
variant packages you want to provide, and how. The second part is implementing a
method which builds the components of the variant packages that use the user's
arguments or cannot be provided with a static import.
.PP
\fISetting up the environment for building variants\fR
.IX Subsection "Setting up the environment for building variants"
.PP
When you \f(CW\*(C`use Package::Variant\*(C'\fR, you pass along some arguments that
describe how you intend to build your variants.
.PP
.Vb 3
\&  use Package::Variant
\&    importing => { $package => \e@import_arguments, ... },
\&    subs      => [ @proxied_subroutine_names ];
.Ve
.PP
The "importing" option needs to be a hash or array reference with
package names to be \f(CW\*(C`use\*(C'\fRd as keys, and array references containing the
import arguments as values. These packages will be imported into every new
variant package, to provide static functionality of the variant packages and to
set up every declarative subroutine you require to build variants package
components. The next option will allow you to use these functions. See
"importing" for more options. You can omit empty import argument lists when
passing an array reference.
.PP
The "subs" option is an array reference of subroutine names that are
exported by the packages specified with "importing". These subroutines
will be proxied from your variable package to the variant to be
generated.
.PP
With "importing" initializing your package and "subs" declaring what
subroutines you want to use to build a variant, you can now write a
"make_variant" method building your variants.
.PP
\fIDeclaring a method to produce variants\fR
.IX Subsection "Declaring a method to produce variants"
.PP
Every time a user requests a new variant, a method named "make_variant"
will be called with the name of the target package and the arguments from
the user.
.PP
It can then use the proxied subroutines declared with "subs" to
customize the variant package. An "install" subroutine is exported as well
allowing you to dynamically install methods into the variant package. If these
options aren't flexible enough, you can use the passed name of the variant
package to do any other kind of customizations.
.PP
.Vb 6
\&  sub make_variant {
\&    my ($class, $target, @arguments) = @_;
\&    # ...
\&    # customization goes here
\&    # ...
\&  }
.Ve
.PP
When the method is finished, the user will receive the name of the new variant
package you just set up.
.SS "Using variable packages"
.IX Subsection "Using variable packages"
After your variable package is created
your users can get a variant generator subroutine by simply importing
your package.
.PP
.Vb 3
\&  use My::Variant;
\&  my $new_variant_package = Variant(@variant_arguments);
\&  # the variant package is now fully initialized and used
.Ve
.PP
You can import the subroutine under a different name by specifying an \f(CW\*(C`as\*(C'\fR
argument.
.SS "Dynamic creation of variant packages"
.IX Subsection "Dynamic creation of variant packages"
For regular uses, the normal import provides
more than enough flexibility. However, if you want to create variants of
dynamically determined packages, you can use the "build_variant_of"
method.
.PP
You can use this to create variants of other packages and pass arguments
on to them to allow more modular and extensible variants.
.SH OPTIONS
.IX Header "OPTIONS"
These are the options that can be passed when importing
\&\f(CW\*(C`Package::Variant\*(C'\fR. They describe the environment in which the variants
are created.
.PP
.Vb 3
\&  use Package::Variant
\&    importing => { $package => \e@import_arguments, ... },
\&    subs      => [ @proxied_subroutines ];
.Ve
.SS importing
.IX Subsection "importing"
This option is a hash reference mapping package names to array references
containing import arguments. The packages will be imported with the given
arguments by every variant before the "make_variant" method is asked
to create the package (this is done using Import::Into).
.PP
If import order is important to you, you can also pass the \f(CW\*(C`importing\*(C'\fR
arguments as a flat array reference:
.PP
.Vb 2
\&  use Package::Variant
\&    importing => [ \*(AqPackageA\*(Aq, \*(AqPackageB\*(Aq ];
\&
\&  # same as
\&  use Package::Variant
\&    importing => [ \*(AqPackageA\*(Aq => [], \*(AqPackageB\*(Aq => [] ];
\&
\&  # or
\&  use Package::Variant
\&    importing => { \*(AqPackageA\*(Aq => [], \*(AqPackageB\*(Aq => [] };
.Ve
.PP
The import method will be called even if the list of import arguments is
empty or not specified,
.PP
If you just want to import a single package's default exports, you can
also pass a string instead:
.PP
.Vb 1
\&  use Package::Variant importing => \*(AqPackage\*(Aq;
.Ve
.SS subs
.IX Subsection "subs"
An array reference of strings listing the names of subroutines that should
be proxied. These subroutines are expected to be installed into the new
variant package by the modules imported with "importing". Subroutines
with the same name will be available in your variable package, and will
proxy through to the newly created package when used within
"make_variant".
.SH "VARIABLE PACKAGE METHODS"
.IX Header "VARIABLE PACKAGE METHODS"
These are methods on the variable package you declare when you import
\&\f(CW\*(C`Package::Variant\*(C'\fR.
.SS make_variant
.IX Subsection "make_variant"
.Vb 1
\&  Some::Variant::Package\->make_variant( $target, @arguments );
.Ve
.PP
\&\fBYou need to provide this method.\fR This method will be called for every
new variant of your package. This method should use the subroutines
declared in "subs" to customize the new variant package.
.PP
This is a class method receiving the \f(CW$target\fR package and the
\&\f(CW@arguments\fR defining the requested variant.
.SS make_variant_package_name
.IX Subsection "make_variant_package_name"
.Vb 1
\&  Some::Variant::Package\->make_variant_package_name( @arguments );
.Ve
.PP
\&\fBYou may optionally provide this method.\fR If present, this method will be
used to determine the package name for a particular variant being constructed.
.PP
If you do not implement it, a unique package name something like
.PP
.Vb 1
\&  Some::Variant::Package::_Variant_A003
.Ve
.PP
will be created for you.
.SS import
.IX Subsection "import"
.Vb 2
\&  use Some::Variant::Package;
\&  my $variant_package = Package( @arguments );
.Ve
.PP
This method is provided for you. It will allow a user to \f(CW\*(C`use\*(C'\fR your
package and receive a subroutine taking \f(CW@arguments\fR defining the variant
and returning the name of the newly created variant package.
.PP
The following options can be specified when importing:
.IP \(bu 4
\&\fBas\fR
.Sp
.Vb 2
\&  use Some::Variant::Package as => \*(AqFoo\*(Aq;
\&  my $variant_package = Foo(@arguments);
.Ve
.Sp
Exports the generator subroutine under a different name than the default.
.SS build_variant
.IX Subsection "build_variant"
.Vb 2
\&  use Some::Variant::Package ();
\&  my $variant_package = Some::Variant::Package\->build_variant( @arguments );
.Ve
.PP
This method is provided for you.  It will generate a variant package
and return its name, just like the generator sub provided by
"import".  This allows you to avoid importing anything into the
consuming package.
.ie n .SH """Package::Variant"" METHODS"
.el .SH "\f(CWPackage::Variant\fP METHODS"
.IX Header "Package::Variant METHODS"
These methods are available on \f(CW\*(C`Package::Variant\*(C'\fR itself.
.SS build_variant_of
.IX Subsection "build_variant_of"
.Vb 2
\&  my $variant_package = Package::Variant
\&    \->build_variant_of($variable_package, @arguments);
.Ve
.PP
This is the dynamic method of creating new variants. It takes the
\&\f(CW$variable_package\fR, which is a pre-declared variable package, and a set
of \f(CW@arguments\fR passed to the package to generate a new
\&\f(CW$variant_package\fR, which will be returned.
.SS import
.IX Subsection "import"
.Vb 1
\&  use Package::Variant @options;
.Ve
.PP
Sets up the environment in which you declare the variants of your
packages. See "OPTIONS" for details on the available options and
"EXPORTS" for a list of exported subroutines.
.SH EXPORTS
.IX Header "EXPORTS"
Additionally to the proxies for subroutines provided in "subs", the
following exports will be available in your variable package:
.SS install
.IX Subsection "install"
.Vb 1
\&  install($method_name, $code_reference);
.Ve
.PP
Installs a method with the given \f(CW$method_name\fR into the newly created
variant package. The \f(CW$code_reference\fR will be used as the body for the
method, and if Sub::Name is available the coderef will be named. If you
want to name it something else, then use:
.PP
.Vb 1
\&  install($method_name, $name_to_use, $code_reference);
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
phaylon \- Robert Sedlacek (cpan:PHAYLON) <r.sedlacek@shadowcat.co.uk>
.PP
haarg \- Graham Knop (cpan:HAARG) <haarg@haarg.org>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2010\-2012 the \f(CW\*(C`Package::Variant\*(C'\fR "AUTHOR" and
"CONTRIBUTORS" as listed above.
.SH LICENSE
.IX Header "LICENSE"
This library is free software and may be distributed under the same
terms as perl itself.
