.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Schema::Constraint 3pm"
.TH SQL::Translator::Schema::Constraint 3pm 2024-11-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Translator::Schema::Constraint \- SQL::Translator constraint object
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 6
\&  use SQL::Translator::Schema::Constraint;
\&  my $constraint = SQL::Translator::Schema::Constraint\->new(
\&      name   => \*(Aqfoo\*(Aq,
\&      fields => [ id ],
\&      type   => PRIMARY_KEY,
\&  );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\f(CW\*(C`SQL::Translator::Schema::Constraint\*(C'\fR is the constraint object.
.SH METHODS
.IX Header "METHODS"
.SS new
.IX Subsection "new"
Object constructor.
.PP
.Vb 11
\&  my $schema           =  SQL::Translator::Schema::Constraint\->new(
\&      table            => $table,        # table to which it belongs
\&      type             => \*(Aqforeign_key\*(Aq, # type of table constraint
\&      name             => \*(Aqfk_phone_id\*(Aq, # name of the constraint
\&      fields           => \*(Aqphone_id\*(Aq,    # field in the referring table
\&      reference_fields => \*(Aqphone_id\*(Aq,    # referenced field
\&      reference_table  => \*(Aqphone\*(Aq,       # referenced table
\&      match_type       => \*(Aqfull\*(Aq,        # how to match
\&      on_delete        => \*(Aqcascade\*(Aq,     # what to do on deletes
\&      on_update        => \*(Aq\*(Aq,            # what to do on updates
\&  );
.Ve
.SS deferrable
.IX Subsection "deferrable"
Get or set whether the constraint is deferrable.  If not defined,
then returns "1."  The argument is evaluated by Perl for True or
False, so the following are equivalent:
.PP
.Vb 3
\&  $deferrable = $field\->deferrable(0);
\&  $deferrable = $field\->deferrable(\*(Aq\*(Aq);
\&  $deferrable = $field\->deferrable(\*(Aq0\*(Aq);
.Ve
.SS expression
.IX Subsection "expression"
Gets and set the expression used in a CHECK constraint.
.PP
.Vb 1
\&  my $expression = $constraint\->expression(\*(Aq...\*(Aq);
.Ve
.SS is_valid
.IX Subsection "is_valid"
Determine whether the constraint is valid or not.
.PP
.Vb 1
\&  my $ok = $constraint\->is_valid;
.Ve
.SS fields
.IX Subsection "fields"
Gets and set the fields the constraint is on.  Accepts a string, list or
arrayref; returns an array or array reference.  Will unique the field
names and keep them in order by the first occurrence of a field name.
.PP
The fields are returned as Field objects if they exist or as plain
names if not. (If you just want the names and want to avoid the Field's overload
magic use "field_names").
.PP
Returns undef or an empty list if the constraint has no fields set.
.PP
.Vb 5
\&  $constraint\->fields(\*(Aqid\*(Aq);
\&  $constraint\->fields(\*(Aqid\*(Aq, \*(Aqname\*(Aq);
\&  $constraint\->fields( \*(Aqid, name\*(Aq );
\&  $constraint\->fields( [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ] );
\&  $constraint\->fields( qw[ id name ] );
\&
\&  my @fields = $constraint\->fields;
.Ve
.SS field_names
.IX Subsection "field_names"
Read-only method to return a list or array ref of the field names. Returns undef
or an empty list if the constraint has no fields set. Useful if you want to
avoid the overload magic of the Field objects returned by the fields method.
.PP
.Vb 1
\&  my @names = $constraint\->field_names;
.Ve
.SS match_type
.IX Subsection "match_type"
Get or set the constraint's match_type.  Only valid values are "full"
"partial" and "simple"
.PP
.Vb 1
\&  my $match_type = $constraint\->match_type(\*(AqFULL\*(Aq);
.Ve
.SS name
.IX Subsection "name"
Get or set the constraint's name.
.PP
.Vb 1
\&  my $name = $constraint\->name(\*(Aqfoo\*(Aq);
.Ve
.SS options
.IX Subsection "options"
Gets or adds to the constraints's options (e.g., "INITIALLY IMMEDIATE").
Returns an array or array reference.
.PP
.Vb 2
\&  $constraint\->options(\*(AqNORELY\*(Aq);
\&  my @options = $constraint\->options;
.Ve
.SS on_delete
.IX Subsection "on_delete"
Get or set the constraint's "on delete" action.
.PP
.Vb 1
\&  my $action = $constraint\->on_delete(\*(Aqcascade\*(Aq);
.Ve
.SS on_update
.IX Subsection "on_update"
Get or set the constraint's "on update" action.
.PP
.Vb 1
\&  my $action = $constraint\->on_update(\*(Aqno action\*(Aq);
.Ve
.SS reference_fields
.IX Subsection "reference_fields"
Gets and set the fields in the referred table.  Accepts a string, list or
arrayref; returns an array or array reference.
.PP
.Vb 5
\&  $constraint\->reference_fields(\*(Aqid\*(Aq);
\&  $constraint\->reference_fields(\*(Aqid\*(Aq, \*(Aqname\*(Aq);
\&  $constraint\->reference_fields( \*(Aqid, name\*(Aq );
\&  $constraint\->reference_fields( [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ] );
\&  $constraint\->reference_fields( qw[ id name ] );
\&
\&  my @reference_fields = $constraint\->reference_fields;
.Ve
.SS reference_table
.IX Subsection "reference_table"
Get or set the table referred to by the constraint.
.PP
.Vb 1
\&  my $reference_table = $constraint\->reference_table(\*(Aqfoo\*(Aq);
.Ve
.SS table
.IX Subsection "table"
Get or set the constraint's table object.
.PP
.Vb 1
\&  my $table = $field\->table;
.Ve
.SS type
.IX Subsection "type"
Get or set the constraint's type.
.PP
.Vb 1
\&  my $type = $constraint\->type( PRIMARY_KEY );
.Ve
.SS equals
.IX Subsection "equals"
Determines if this constraint is the same as another
.PP
.Vb 1
\&  my $isIdentical = $constraint1\->equals( $constraint2 );
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
Ken Youens-Clark <kclark@cpan.org>.
