.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Contextual 3pm"
.TH Log::Contextual 3pm 2024-05-29 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Log::Contextual \- Simple logging interface with a contextual log
.SH VERSION
.IX Header "VERSION"
version 0.009001
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 4
\&  use Log::Contextual qw( :log :dlog set_logger with_logger );
\&  use Log::Contextual::SimpleLogger;
\&  use Log::Log4perl \*(Aq:easy\*(Aq;
\&  Log::Log4perl\->easy_init($DEBUG);
\&
\&  my $logger  = Log::Log4perl\->get_logger;
\&
\&  set_logger $logger;
\&
\&  log_debug { \*(Aqprogram started\*(Aq };
\&
\&  sub foo {
\&
\&    my $minilogger = Log::Contextual::SimpleLogger\->new({
\&      levels => [qw( trace debug )]
\&    });
\&
\&    my @args = @_;
\&
\&    with_logger $minilogger => sub {
\&      log_trace { \*(Aqfoo entered\*(Aq };
\&      my ($foo, $bar) = Dlog_trace { "params for foo: $_" } @args;
\&      # ...
\&      slog_trace \*(Aqfoo left\*(Aq;
\&    };
\&  }
\&
\&  foo();
.Ve
.PP
Beginning with version 1.008 Log::Dispatchouli also works out of the box
with \f(CW\*(C`Log::Contextual\*(C'\fR:
.PP
.Vb 7
\&  use Log::Contextual qw( :log :dlog set_logger );
\&  use Log::Dispatchouli;
\&  my $ld = Log::Dispatchouli\->new({
\&    ident     => \*(Aqslrtbrfst\*(Aq,
\&    to_stderr => 1,
\&    debug     => 1,
\&  });
\&
\&  set_logger $ld;
\&
\&  log_debug { \*(Aqprogram started\*(Aq };
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Major benefits:
.IP \(bu 2
Efficient
.Sp
The default logging functions take blocks, so if a log level is disabled, the
block will not run:
.Sp
.Vb 2
\&  # the following won\*(Aqt run if debug is off
\&  log_debug { "the new count in the database is " . $rs\->count };
.Ve
.Sp
Similarly, the \f(CW\*(C`D\*(C'\fR prefixed methods only \f(CW\*(C`Dumper\*(C'\fR the input if the level is
enabled.
.IP \(bu 2
Handy
.Sp
The logging functions return their arguments, so you can stick them in
the middle of expressions:
.Sp
.Vb 1
\&  for (log_debug { "downloading:\en" . join qq(\en), @_ } @urls) { ... }
.Ve
.IP \(bu 2
Generic
.Sp
\&\f(CW\*(C`Log::Contextual\*(C'\fR is an interface for all major loggers.  If you log through
\&\f(CW\*(C`Log::Contextual\*(C'\fR you will be able to swap underlying loggers later.
.IP \(bu 2
Powerful
.Sp
\&\f(CW\*(C`Log::Contextual\*(C'\fR chooses which logger to use based on user defined \f(CW\*(C`CodeRef\*(C'\fRs.
Normally you don't need to know this, but you can take advantage of it when you
need to later.
.IP \(bu 2
Scalable
.Sp
If you just want to add logging to your basic application, start with
Log::Contextual::SimpleLogger and then as your needs grow you can switch to
Log::Dispatchouli or Log::Dispatch or Log::Log4perl or whatever else.
.PP
This module is a simple interface to extensible logging.  It exists to
abstract your logging interface so that logging is as painless as possible,
while still allowing you to switch from one logger to another.
.PP
It is bundled with a really basic logger, Log::Contextual::SimpleLogger,
but in general you should use a real logger instead.  For something
more serious but not overly complicated, try Log::Dispatchouli (see
"SYNOPSIS" for example.)
.SH "A WORK IN PROGRESS"
.IX Header "A WORK IN PROGRESS"
This module is certainly not complete, but we will not break the interface
lightly, so I would say it's safe to use in production code.  The main result
from that at this point is that doing:
.PP
.Vb 1
\&  use Log::Contextual;
.Ve
.PP
will die as we do not yet know what the defaults should be.  If it turns out
that nearly everyone uses the \f(CW\*(C`:log\*(C'\fR tag and \f(CW\*(C`:dlog\*(C'\fR is really rare, we'll
probably make \f(CW\*(C`:log\*(C'\fR the default.  But only time and usage will tell.
.SH "IMPORT OPTIONS"
.IX Header "IMPORT OPTIONS"
See "SETTING DEFAULT IMPORT OPTIONS" for information on setting these project
wide.
.SS \-logger
.IX Subsection "-logger"
When you import this module you may use \f(CW\*(C`\-logger\*(C'\fR as a shortcut for
"set_logger", for example:
.PP
.Vb 3
\&  use Log::Contextual::SimpleLogger;
\&  use Log::Contextual qw( :dlog ),
\&    \-logger => Log::Contextual::SimpleLogger\->new({ levels => [qw( debug )] });
.Ve
.PP
sometimes you might want to have the logger handy for other stuff, in which
case you might try something like the following:
.PP
.Vb 3
\&  my $var_log;
\&  BEGIN { $var_log = VarLogger\->new }
\&  use Log::Contextual qw( :dlog ), \-logger => $var_log;
.Ve
.SS \-levels
.IX Subsection "-levels"
The \f(CW\*(C`\-levels\*(C'\fR import option allows you to define exactly which levels your
logger supports.  So the default,
\&\f(CW\*(C`[qw(debug trace warn info error fatal)]\*(C'\fR, works great for
Log::Log4perl, but it doesn't support the levels for Log::Dispatch.  But
supporting those levels is as easy as doing
.PP
.Vb 2
\&  use Log::Contextual
\&    \-levels => [qw( debug info notice warning error critical alert emergency )];
.Ve
.SS \-package_logger
.IX Subsection "-package_logger"
The \f(CW\*(C`\-package_logger\*(C'\fR import option is similar to the \f(CW\*(C`\-logger\*(C'\fR import option
except \f(CW\*(C`\-package_logger\*(C'\fR sets the logger for the current package.
.PP
Unlike "\-default_logger", \f(CW\*(C`\-package_logger\*(C'\fR cannot be overridden with
"set_logger" or "with_logger".
.PP
.Vb 6
\&  package My::Package;
\&  use Log::Contextual::SimpleLogger;
\&  use Log::Contextual qw( :log ),
\&    \-package_logger => Log::Contextual::WarnLogger\->new({
\&      env_prefix => \*(AqMY_PACKAGE\*(Aq
\&    });
.Ve
.PP
If you are interested in using this package for a module you are putting on
CPAN we recommend Log::Contextual::WarnLogger for your package logger.
.SS \-default_logger
.IX Subsection "-default_logger"
The \f(CW\*(C`\-default_logger\*(C'\fR import option is similar to the \f(CW\*(C`\-logger\*(C'\fR import option
except \f(CW\*(C`\-default_logger\*(C'\fR sets the \fBdefault\fR logger for the current package.
.PP
Basically it sets the logger to be used if \f(CW\*(C`set_logger\*(C'\fR is never called; so
.PP
.Vb 6
\&  package My::Package;
\&  use Log::Contextual::SimpleLogger;
\&  use Log::Contextual qw( :log ),
\&    \-default_logger => Log::Contextual::WarnLogger\->new({
\&      env_prefix => \*(AqMY_PACKAGE\*(Aq
\&    });
.Ve
.SH "SETTING DEFAULT IMPORT OPTIONS"
.IX Header "SETTING DEFAULT IMPORT OPTIONS"
Eventually you will get tired of writing the following in every single one of
your packages:
.PP
.Vb 3
\&  use Log::Log4perl;
\&  use Log::Log4perl \*(Aq:easy\*(Aq;
\&  BEGIN { Log::Log4perl\->easy_init($DEBUG) }
\&
\&  use Log::Contextual \-logger => Log::Log4perl\->get_logger;
.Ve
.PP
You can set any of the import options for your whole project if you define your
own \f(CW\*(C`Log::Contextual\*(C'\fR subclass as follows:
.PP
.Vb 1
\&  package MyApp::Log::Contextual;
\&
\&  use parent \*(AqLog::Contextual\*(Aq;
\&
\&  use Log::Log4perl \*(Aq:easy\*(Aq;
\&  Log::Log4perl\->easy_init($DEBUG)
\&
\&  sub arg_default_logger { $_[1] || Log::Log4perl\->get_logger }
\&  sub arg_levels { [qw(debug trace warn info error fatal custom_level)] }
\&  sub default_import { \*(Aq:log\*(Aq }
\&
\&  # or maybe instead of default_logger
\&  sub arg_package_logger { $_[1] }
\&
\&  # and almost definitely not this, which is only here for completeness
\&  sub arg_logger { $_[1] }
.Ve
.PP
Note the \f(CW\*(C`$_[1] ||\*(C'\fR in \f(CW\*(C`arg_default_logger\*(C'\fR.  All of these methods are
passed the values passed in from the arguments to the subclass, so you can
either throw them away, honor them, die on usage, etc.  To be clear,
if you define your subclass, and someone uses it as follows:
.PP
.Vb 2
\&  use MyApp::Log::Contextual \-default_logger => $foo,
\&                              \-levels => [qw(bar baz biff)];
.Ve
.PP
Your \f(CW\*(C`arg_default_logger\*(C'\fR method will get \f(CW$foo\fR and your \f(CW\*(C`arg_levels\*(C'\fR
will get \f(CW\*(C`[qw(bar baz biff)]\*(C'\fR;
.PP
Additionally, the \f(CW\*(C`default_import\*(C'\fR method is what happens if a user tries to
use your subclass with no arguments.  The default just dies, but if you'd like
to change the default to import a tag merely return the tags you'd like to
import.  So the following will all work:
.PP
.Vb 1
\&  sub default_import { \*(Aq:log\*(Aq }
\&
\&  sub default_import { \*(Aq:dlog\*(Aq }
\&
\&  sub default_import { qw(:dlog :log ) }
.Ve
.PP
See Log::Contextual::Easy::Default for an example of a subclass of
\&\f(CW\*(C`Log::Contextual\*(C'\fR that makes use of default import options.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.SS set_logger
.IX Subsection "set_logger"
.Vb 2
\&  my $logger = WarnLogger\->new;
\&  set_logger $logger;
.Ve
.PP
Arguments: "LOGGER CODEREF"
.PP
\&\f(CW\*(C`set_logger\*(C'\fR will just set the current logger to whatever you pass it.  It
expects a \f(CW\*(C`CodeRef\*(C'\fR, but if you pass it something else it will wrap it in a
\&\f(CW\*(C`CodeRef\*(C'\fR for you.  \f(CW\*(C`set_logger\*(C'\fR is really meant only to be called from a
top-level script.  To avoid foot-shooting the function will warn if you call it
more than once.
.SS with_logger
.IX Subsection "with_logger"
.Vb 8
\&  my $logger = WarnLogger\->new;
\&  with_logger $logger => sub {
\&    if (1 == 0) {
\&      log_fatal { \*(AqNon Logical Universe Detected\*(Aq };
\&    } else {
\&      log_info  { \*(AqAll is good\*(Aq };
\&    }
\&  };
.Ve
.PP
Arguments: "LOGGER CODEREF", \f(CW\*(C`CodeRef $to_execute\*(C'\fR
.PP
\&\f(CW\*(C`with_logger\*(C'\fR sets the logger for the scope of the \f(CW\*(C`CodeRef\*(C'\fR \f(CW$to_execute\fR.
As with "set_logger", \f(CW\*(C`with_logger\*(C'\fR will wrap \f(CW$returning_logger\fR with a
\&\f(CW\*(C`CodeRef\*(C'\fR if needed.
.SS has_logger
.IX Subsection "has_logger"
.Vb 2
\&  my $logger = WarnLogger\->new;
\&  set_logger $logger unless has_logger;
.Ve
.PP
Arguments: none
.PP
\&\f(CW\*(C`has_logger\*(C'\fR will return true if a logger has been set.
.SS log_$level
.IX Subsection "log_$level"
Import Tag: \f(CW\*(C`:log\*(C'\fR
.PP
Arguments: \f(CW\*(C`CodeRef $returning_message, @args\*(C'\fR
.PP
\&\f(CW\*(C`log_$level\*(C'\fR functions all work the same except that a different method
is called on the underlying \f(CW$logger\fR object.  The basic pattern is:
.PP
.Vb 6
\&  sub log_$level (&@) {
\&    if ($logger\->is_$level) {
\&      $logger\->$level(shift\->(@_));
\&    }
\&    @_
\&  }
.Ve
.PP
Note that the function returns its arguments.  This can be used in a number of
ways, but often it's convenient just for partial inspection of passthrough data
.PP
.Vb 4
\&  my @friends = log_trace {
\&    \*(Aqfriends list being generated, data from first friend: \*(Aq .
\&      Dumper($_[0]\->TO_JSON)
\&  } generate_friend_list();
.Ve
.PP
If you want complete inspection of passthrough data, take a look at the
"Dlog_$level" functions.
.PP
Which functions are exported depends on what was passed to "\-levels".  The
default (no \f(CW\*(C`\-levels\*(C'\fR option passed) would export:
.IP log_trace 2
.IX Item "log_trace"
.PD 0
.IP log_debug 2
.IX Item "log_debug"
.IP log_info 2
.IX Item "log_info"
.IP log_warn 2
.IX Item "log_warn"
.IP log_error 2
.IX Item "log_error"
.IP log_fatal 2
.IX Item "log_fatal"
.PD
\&\fBNote:\fR \f(CW\*(C`log_fatal\*(C'\fR does not call \f(CW\*(C`die\*(C'\fR for you, see "EXCEPTIONS AND ERROR HANDLING"
.SS slog_$level
.IX Subsection "slog_$level"
Mostly the same as "log_$level", but expects a string as first argument,
not a block. Arguments are passed through just the same, but since it's just a
string, interpolation of arguments into it must be done manually.
.PP
.Vb 1
\&  my @friends = slog_trace \*(Aqfriends list being generated.\*(Aq, generate_friend_list();
.Ve
.SS logS_$level
.IX Subsection "logS_$level"
Import Tag: \f(CW\*(C`:log\*(C'\fR
.PP
Arguments: \f(CW\*(C`CodeRef $returning_message, Item $arg\*(C'\fR
.PP
This is really just a special case of the "log_$level" functions.  It forces
scalar context when that is what you need.  Other than that it works exactly
same:
.PP
.Vb 3
\&  my $friend = logS_trace {
\&    \*(AqI only have one friend: \*(Aq .  Dumper($_[0]\->TO_JSON)
\&  } friend();
.Ve
.PP
See also: "DlogS_$level".
.SS slogS_$level
.IX Subsection "slogS_$level"
Mostly the same as "logS_$level", but expects a string as first argument,
not a block. Arguments are passed through just the same, but since it's just a
string, interpolation of arguments into it must be done manually.
.PP
.Vb 1
\&  my $friend = slogS_trace \*(AqI only have one friend.\*(Aq, friend();
.Ve
.SS Dlog_$level
.IX Subsection "Dlog_$level"
Import Tag: \f(CW\*(C`:dlog\*(C'\fR
.PP
Arguments: \f(CW\*(C`CodeRef $returning_message, @args\*(C'\fR
.PP
All of the following six functions work the same as their "log_$level"
brethren, except they return what is passed into them and put the stringified
(with Data::Dumper::Concise) version of their args into \f(CW$_\fR.  This means
you can do cool things like the following:
.PP
.Vb 1
\&  my @nicks = Dlog_debug { "names: $_" } map $_\->value, $frew\->names\->all;
.Ve
.PP
and the output might look something like:
.PP
.Vb 5
\&  names: "fREW"
\&  "fRIOUX"
\&  "fROOH"
\&  "fRUE"
\&  "fiSMBoC"
.Ve
.PP
Which functions are exported depends on what was passed to "\-levels".  The
default (no \f(CW\*(C`\-levels\*(C'\fR option passed) would export:
.IP Dlog_trace 2
.IX Item "Dlog_trace"
.PD 0
.IP Dlog_debug 2
.IX Item "Dlog_debug"
.IP Dlog_info 2
.IX Item "Dlog_info"
.IP Dlog_warn 2
.IX Item "Dlog_warn"
.IP Dlog_error 2
.IX Item "Dlog_error"
.IP Dlog_fatal 2
.IX Item "Dlog_fatal"
.PD
\&\fBNote:\fR \f(CW\*(C`Dlog_fatal\*(C'\fR does not call \f(CW\*(C`die\*(C'\fR for you, see "EXCEPTIONS AND ERROR HANDLING"
.SS Dslog_$level
.IX Subsection "Dslog_$level"
Mostly the same as "Dlog_$level", but expects a string as first argument,
not a block. Arguments are passed through just the same, but since it's just a
string, no interpolation point can be used, instead the Dumper output is
appended.
.PP
.Vb 1
\&  my @nicks = Dslog_debug "names: ", map $_\->value, $frew\->names\->all;
.Ve
.SS DlogS_$level
.IX Subsection "DlogS_$level"
Import Tag: \f(CW\*(C`:dlog\*(C'\fR
.PP
Arguments: \f(CW\*(C`CodeRef $returning_message, Item $arg\*(C'\fR
.PP
Like "logS_$level", these functions are a special case of "Dlog_$level".
They only take a single scalar after the \f(CW$returning_message\fR instead of
slurping up (and also setting \f(CW\*(C`wantarray\*(C'\fR) all the \f(CW@args\fR
.PP
.Vb 2
\&  my $pals_rs = DlogS_debug { "pals resultset: $_" }
\&    $schema\->resultset(\*(AqPals\*(Aq)\->search({ perlers => 1 });
.Ve
.SS DslogS_$level
.IX Subsection "DslogS_$level"
Mostly the same as "DlogS_$level", but expects a string as first argument,
not a block. Arguments are passed through just the same, but since it's just a
string, no interpolation point can be used, instead the Dumper output is
appended.
.PP
.Vb 2
\&  my $pals_rs = DslogS_debug "pals resultset: ",
\&    $schema\->resultset(\*(AqPals\*(Aq)\->search({ perlers => 1 });
.Ve
.SH "LOGGER CODEREF"
.IX Header "LOGGER CODEREF"
Anywhere a logger object can be passed, a coderef is accepted.  This is so
that the user can use different logger objects based on runtime information.
The logger coderef is passed the package of the caller, and the caller level the
coderef needs to use if it wants more caller information.  The latter is in
a hashref to allow for more options in the future.
.PP
Here is a basic example of a logger that exploits \f(CW\*(C`caller\*(C'\fR to reproduce the
output of \f(CW\*(C`warn\*(C'\fR with a logger:
.PP
.Vb 12
\&  my @caller_info;
\&  my $var_log = Log::Contextual::SimpleLogger\->new({
\&    levels  => [qw(trace debug info warn error fatal)],
\&    coderef => sub { chomp($_[0]); warn "$_[0] at $caller_info[1] line $caller_info[2].\en" }
\&  });
\&  my $warn_faker = sub {
\&    my ($package, $args) = @_;
\&    @caller_info = caller($args\->{caller_level});
\&    $var_log
\&  };
\&  set_logger($warn_faker);
\&  log_debug { \*(Aqtest\*(Aq };
.Ve
.PP
The following is an example that uses the information passed to the logger
coderef.  It sets the global logger to \f(CW$l3\fR, the logger for the \f(CW\*(C`A1\*(C'\fR
package to \f(CW$l1\fR, except the \f(CW\*(C`lol\*(C'\fR method in \f(CW\*(C`A1\*(C'\fR which uses the \f(CW$l2\fR
logger and lastly the logger for the \f(CW\*(C`A2\*(C'\fR package to \f(CW$l2\fR.
.PP
Note that it increases the caller level as it dispatches based on where
the caller of the log function, not the log function itself.
.PP
.Vb 1
\&  my $complex_dispatcher = do {
\&
\&    my $l1 = ...;
\&    my $l2 = ...;
\&    my $l3 = ...;
\&
\&    my %registry = (
\&      \-logger => $l3,
\&      A1 => {
\&        \-logger => $l1,
\&        lol     => $l2,
\&      },
\&      A2 => { \-logger => $l2 },
\&    );
\&
\&    sub {
\&      my ( $package, $info ) = @_;
\&
\&      my $logger = $registry{\*(Aq\-logger\*(Aq};
\&      if (my $r = $registry{$package}) {
\&        $logger = $r\->{\*(Aq\-logger\*(Aq} if $r\->{\*(Aq\-logger\*(Aq};
\&        my (undef, undef, undef, $sub) = caller($info\->{caller_level} + 1);
\&        $sub =~ s/^\eQ$package\eE:://g;
\&        $logger = $r\->{$sub} if $r\->{$sub};
\&      }
\&      return $logger;
\&    }
\&  };
\&
\&  set_logger $complex_dispatcher;
.Ve
.SH "LOGGER INTERFACE"
.IX Header "LOGGER INTERFACE"
Because this module is ultimately pretty looking glue (glittery?) with the
awesome benefit of the Contextual part, users will often want to make their
favorite logger work with it.  The following are the methods that should be
implemented in the logger:
.PP
.Vb 12
\&  is_trace
\&  is_debug
\&  is_info
\&  is_warn
\&  is_error
\&  is_fatal
\&  trace
\&  debug
\&  info
\&  warn
\&  error
\&  fatal
.Ve
.PP
The first six merely need to return true if that level is enabled.  The latter
six take the results of whatever the user returned from their coderef and log
them.  For a basic example see Log::Contextual::SimpleLogger.
.SH "LOG ROUTING"
.IX Header "LOG ROUTING"
In between the loggers and the log functions is a log router that is responsible for
finding a logger to handle the log event and passing the log information to the
logger. This relationship is described in the documentation for \f(CW\*(C`Log::Contextual::Role::Router\*(C'\fR.
.PP
\&\f(CW\*(C`Log::Contextual\*(C'\fR and packages that extend it will by default share a router singleton that
implements the \fBwith_logger()\fR and \fBset_logger()\fR functions and also respects the \-logger,
\&\-package_logger, and \-default_logger import options with their associated default value
functions. The router singleton is available as the return value of the \fBrouter()\fR function. Users
of Log::Contextual may overload \fBrouter()\fR to return instances of custom log routers that
could for example work with loggers that use a different interface.
.SH "EXCEPTIONS AND ERROR HANDLING"
.IX Header "EXCEPTIONS AND ERROR HANDLING"
\&\f(CW\*(C`Log::Contextual\*(C'\fR, by design, does not \fBintentionally\fR invoke \f(CW\*(C`die\*(C'\fR on your
behalf(*see footnote*) for \f(CW\*(C`log_fatal\*(C'\fR.
.PP
Logging events are characterized as information, not flow control, and
conflating the two results in negative design anti-patterns.
.PP
As such, \f(CW\*(C`log_fatal\*(C'\fR would at be better used to communicate information about a
\&\fIfuture\fR failure, for example:
.PP
.Vb 4
\&  if ( condition ) {
\&    log_fatal { "Bad Condition is true" };
\&    die My::Exception\->new();
\&  }
.Ve
.PP
This has a number of benefits:
.IP \(bu 4
You're more likely to want to use useful Exception Objects and flow control
instead of cheating with log messages.
.IP \(bu 4
You're less likely to run a risk of losing what the actual problem was when some
error occurs in your creation of the Exception Object
.IP \(bu 4
You're less likely to run the risk of losing important log context due to
exceptions occurring mid way through \f(CW\*(C`die\*(C'\fR unwinding and \f(CW\*(C`exit\*(C'\fR global
destruction.
.PP
If you're still too lazy to use exceptions, then you can do what you probably want
as follows:
.PP
.Vb 4
\&  if ( ... ) {
\&    log_fatal { "Bad condition is true" };
\&    die "Bad condtion is true";
\&  }
.Ve
.PP
Or for \f(CW\*(C`:dlog\*(C'\fR style:
.PP
.Vb 7
\&  use Data::Dumper::Consise qw( Dumper );
\&  if ( ... ) {
\&    # Dlog_fatal but not
\&    my $reason = "Bad condtion is true because: " . Dumper($thing);
\&    log_fatal { $reason };
\&    die $reason;
\&  }
.Ve
.SS footnote
.IX Subsection "footnote"
The underlying behaviour of \f(CW\*(C`log_fatal\*(C'\fR is dependent on the backing library.
.PP
All the Loggers shipping with \f(CW\*(C`Log::Contextual\*(C'\fR behave this way, as do many of the supported
loggers, like \f(CW\*(C`Log::Log4perl\*(C'\fR. However, not all loggers work this way, and one must be careful.
.PP
\&\f(CW\*(C`Log::Dispatch\*(C'\fR doesn't support implementing \f(CW\*(C`log_fatal\*(C'\fR at all
.PP
\&\f(CW\*(C`Log::Dispatchouli\*(C'\fR implements \f(CW\*(C`log_fatal\*(C'\fR using \f(CW\*(C`die\*(C'\fR ( via Carp )
.SH DESIGNER
.IX Header "DESIGNER"
mst \- Matt S. Trout <mst@shadowcat.co.uk>
.SH BUGS
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
<https://github.com/haarg/Log\-Contextual/issues>
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
.IP \(bu 4
Christian Walde <walde.christian@gmail.com>
.IP \(bu 4
Dan Book <grinnz@grinnz.com>
.IP \(bu 4
Florian Schlichtin <fsfs@debian.org>
.IP \(bu 4
Graham Knop <haarg@haarg.org>
.IP \(bu 4
Jakob Voss <voss@gbv.de>
.IP \(bu 4
Karen Etheridge <ether@cpan.org>
.IP \(bu 4
Kent Fredric <kentfredric@gmail.com>
.IP \(bu 4
Matt S Trout <mst@shadowcat.co.uk>
.IP \(bu 4
Peter Rabbitson <ribasushi@cpan.org>
.IP \(bu 4
Philippe Bruhat (BooK) <book@cpan.org>
.IP \(bu 4
Tyler Riddle <t.riddle@shadowcat.co.uk>
.IP \(bu 4
Wes Malone <wes@mitsi.com>
.SH AUTHOR
.IX Header "AUTHOR"
Arthur Axel "fREW" Schmidt <frioux+cpan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
