.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Manual::Glossary 3pm"
.TH DBIx::Class::Manual::Glossary 3pm 2018-04-30 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Manual::Glossary \- Clarification of terms used.
.SH INTRODUCTION
.IX Header "INTRODUCTION"
This document lists various terms used in DBIx::Class and attempts to
explain them.
.SH "DBIx::Class TERMS"
.IX Header "DBIx::Class TERMS"
.SS "DB schema"
.IX Subsection "DB schema"
Refers to a single physical schema within an RDBMS. Synonymous with the terms
\&'database', for MySQL; and 'schema', for most other RDBMS(s).
.PP
In other words, it's the 'xyz' _thing_ you're connecting to when using any of
the following DSN(s):
.PP
.Vb 2
\&  dbi:DriverName:xyz@hostname:port
\&  dbi:DriverName:database=xyz;host=hostname;port=port
.Ve
.SS Inflation
.IX Subsection "Inflation"
The act of turning database row data into objects in
language-space. DBIx::Class result classes can be set up to inflate
your data into perl objects which more usefully represent their
contents. For example: DBIx::Class::InflateColumn::DateTime for
datetime or timestamp column data.
.PP
See also DBIx::Class::InflateColumn.
.SS Deflation
.IX Subsection "Deflation"
The opposite of "Inflation". Existing perl objects that represent
column values can be passed to DBIx::Class methods to store into the
database. For example a DateTime object can be automatically
deflated into a datetime string for insertion.
.PP
See DBIx::Class::InflateColumn and other modules in that namespace.
.SS ORM
.IX Subsection "ORM"
Object-relational mapping, or Object-relationship modelling. Either
way it's a method of mapping the contents of database tables (rows),
to objects in programming-language-space. DBIx::Class is an ORM.
.SS Relationship
.IX Subsection "Relationship"
In DBIx::Class a relationship defines the connection between exactly
two tables. The relationship condition lists the columns in each table
that contain the same values. It is used to output an SQL JOIN
condition between the tables.
.SS "Relationship bridge"
.IX Subsection "Relationship bridge"
A relationship bridge, such as \f(CW\*(C`many_to_many\*(C'\fR defines an accessor to
retrieve row contents across multiple relationships.
.PP
The difference between a bridge and a relationship is, that the bridge
cannot be used to \f(CW\*(C`join\*(C'\fR tables in a \f(CW\*(C`search\*(C'\fR, instead its component
relationships must be used.
.SS Schema
.IX Subsection "Schema"
A Schema object represents your entire table collection, plus the
connection to the database. You can create one or more schema objects,
connected to various databases, with various users, using the same set
of table "Result Class" definitions.
.PP
At least one DBIx::Class::Schema class is needed per database.
.SS "Result Class"
.IX Subsection "Result Class"
A Result class defines both a source of data (usually one per table),
and the methods that will be available in the "Result" objects
created using that source.
.PP
One Result class is needed per data source (table, view, query) used
in your application, they should inherit from DBIx::Class::Core.
.PP
See also: DBIx::Class::Manual::ResultClass
.SS ResultSource
.IX Subsection "ResultSource"
ResultSource objects represent the source of your data, these are
sometimes (incorrectly) called table objects.
.PP
ResultSources do not need to be directly created, a ResultSource
instance is created for each "Result Class" in your "Schema", by
the proxied methods \f(CW\*(C`table\*(C'\fR and \f(CW\*(C`add_columns\*(C'\fR.
.PP
See also: "METHODS" in DBIx::Class::ResultSource
.SS ResultSet
.IX Subsection "ResultSet"
This is an object representing a set of conditions to filter data. It
can either be an entire table, or the results of a query. The actual
data is not held in the ResultSet, it is only a description of how to
fetch the data.
.PP
See also: "METHODS" in DBIx::Class::ResultSet
.SS Result
.IX Subsection "Result"
Result objects contain your actual data. They are returned from
ResultSet objects.  These are sometimes (incorrectly) called
row objects, including older versions of the DBIC documentation.
.PP
See also: DBIx::Class::Manual::ResultClass
.SS Row
.IX Subsection "Row"
See Result.
.SS Object
.IX Subsection "Object"
See Result.
.SS Record
.IX Subsection "Record"
See Result.
.SS prefetch
.IX Subsection "prefetch"
Similar to a join, except the related result objects are fetched and
cached for future use, instead of used directly from the ResultSet.  This
allows you to jump to different relationships within a Result without
worrying about generating a ton of extra SELECT statements.
.SH "SQL TERMS"
.IX Header "SQL TERMS"
.SS CRUD
.IX Subsection "CRUD"
Create, Read, Update, Delete.  A general concept of something that can
do all four operations (INSERT, SELECT, UPDATE, DELETE), usually at a
row-level.
.SS Join
.IX Subsection "Join"
This is an SQL keyword, it is used to link multiple tables in one SQL
statement. This enables us to fetch data from more than one table at
once, or filter data based on content in another table, without having
to issue multiple SQL queries.
.SS Normalisation
.IX Subsection "Normalisation"
A normalised database is a sane database. Each table contains only
data belonging to one concept, related tables refer to the key field
or fields of each other. Some links to webpages about normalisation
can be found in the FAQ.
.SS "Related data"
.IX Subsection "Related data"
In SQL, related data actually refers to data that are normalised into
the same table. (Yes. DBIC does mis-use this term.)
.SH "FURTHER QUESTIONS?"
.IX Header "FURTHER QUESTIONS?"
Check the list of additional DBIC resources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This module is free software copyright
by the DBIx::Class (DBIC) authors. You can
redistribute it and/or modify it under the same terms as the
DBIx::Class library.
