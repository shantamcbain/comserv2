.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::SplitStatement 3pm"
.TH SQL::SplitStatement 3pm 2021-06-05 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::SplitStatement \- Split any SQL code into atomic statements
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 10
\&    # Multiple SQL statements in a single string
\&    my $sql_code = <<\*(AqSQL\*(Aq;
\&    CREATE TABLE parent(a, b, c   , d    );
\&    CREATE TABLE child (x, y, "w;", "z;z");
\&    /* C\-style comment; */
\&    CREATE TRIGGER "check;delete;parent;" BEFORE DELETE ON parent WHEN
\&        EXISTS (SELECT 1 FROM child WHERE old.a = x AND old.b = y)
\&    BEGIN
\&        SELECT RAISE(ABORT, \*(Aqconstraint failed;\*(Aq); \-\- Inline SQL comment
\&    END;
\&    \-\- Standalone SQL; comment; with semicolons;
\&    INSERT INTO parent (a, b, c, d) VALUES (\*(Aqpippo;\*(Aq, \*(Aqpluto;\*(Aq, NULL, NULL);
\&    SQL
\&        
\&    use SQL::SplitStatement;
\&        
\&    my $sql_splitter = SQL::SplitStatement\->new;
\&    my @statements = $sql_splitter\->split($sql_code);
\&        
\&    # @statements now is:
\&    #
\&    # (
\&    #     \*(AqCREATE TABLE parent(a, b, c   , d    )\*(Aq,
\&    #     \*(AqCREATE TABLE child (x, y, "w;", "z;z")\*(Aq,
\&    #     \*(AqCREATE TRIGGER "check;delete;parent;" BEFORE DELETE ON parent WHEN
\&    #     EXISTS (SELECT 1 FROM child WHERE old.a = x AND old.b = y)
\&    # BEGIN
\&    #     SELECT RAISE(ABORT, \e\*(Aqconstraint failed;\e\*(Aq);
\&    # END\*(Aq,
\&    #     \*(AqINSERT INTO parent (a, b, c, d) VALUES (\e\*(Aqpippo;\e\*(Aq, \e\*(Aqpluto;\e\*(Aq, NULL, NULL)\*(Aq
\&    # )
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is a simple module which tries to split any SQL code, even including
non-standard extensions (for the details see the "SUPPORTED DBMSs" section
below), into the atomic statements it is composed of.
.PP
The logic used to split the SQL code is more sophisticated than a raw \f(CW\*(C`split\*(C'\fR
on the \f(CW\*(C`;\*(C'\fR (semicolon) character: first, various different statement terminator
\&\fItokens\fR are recognized (see below for the list), then this module is able to
correctly handle the presence of said tokens inside identifiers, values,
comments, \f(CW\*(C`BEGIN ... END\*(C'\fR blocks (even nested), \fIdollar-quoted\fR strings, MySQL
custom \f(CW\*(C`DELIMITER\*(C'\fRs, procedural code etc., as (partially) exemplified in the
"SYNOPSIS" above.
.PP
Consider however that this is by no means a validating parser (technically
speaking, it's just a \fIcontext-sensitive tokenizer\fR). It should rather be seen
as an in-progress \fIheuristic\fR approach, which will gradually improve as test
cases will be reported. This also means that, except for the "LIMITATIONS"
detailed below, there is no known (to the author) SQL code the most current
release of this module can't correctly split.
.PP
The test suite bundled with the distribution (which now includes the popular
\&\fISakila\fR and \fIPagila\fR sample db schemata, as detailed in the "SHOWCASE"
section below) should give you an idea of the capabilities of this module
.PP
If your atomic statements are to be fed to a DBMS, you are encouraged to use
DBIx::MultiStatementDo instead, which uses this module and also (optionally)
offers automatic transactions support, so that you'll have the \fIall-or-nothing\fR
behavior you would probably want.
.SH METHODS
.IX Header "METHODS"
.ie n .SS """new"""
.el .SS \f(CWnew\fP
.IX Subsection "new"
.IP \(bu 4
\&\f(CW\*(C`SQL::SplitStatement\->new( %options )\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`SQL::SplitStatement\->new( \e%options )\*(C'\fR
.PP
It creates and returns a new SQL::SplitStatement object. It accepts its options
either as a hash or a hashref.
.PP
\&\f(CW\*(C`new\*(C'\fR takes the following Boolean options, which for documentation purposes can
be grouped in two sets: "Formatting Options" and "DBMSs Specific Options".
.PP
\fIFormatting Options\fR
.IX Subsection "Formatting Options"
.IP \(bu 4
\&\f(CW\*(C`keep_terminators\*(C'\fR
.Sp
A Boolean option which causes, when set to a false value (which is the default),
the trailing terminator token to be discarded in the returned atomic statements.
When set to a true value, the terminators are kept instead.
.Sp
The possible terminators (which are treated as such depending on the context)
are:
.RS 4
.IP \(bu 4
\&\f(CW\*(C`;\*(C'\fR (the \fIsemicolon\fR character);
.IP \(bu 4
any string defined by the MySQL \f(CW\*(C`DELIMITER\*(C'\fR command;
.IP \(bu 4
an \f(CW\*(C`;\*(C'\fR followed by an \f(CW\*(C`/\*(C'\fR (\fIforward-slash\fR character) on its own
line;
.IP \(bu 4
an \f(CW\*(C`;\*(C'\fR followed by an \f(CW\*(C`.\*(C'\fR (\fIdot\fR character) on its own line,
followed by an \f(CW\*(C`/\*(C'\fR on its own line;
.IP \(bu 4
an \f(CW\*(C`/\*(C'\fR on its own line regardless of the preceding characters
(only if the \f(CW\*(C`slash_terminates\*(C'\fR option, explained below, is set).
.RE
.RS 4
.Sp
The multi-line terminators above are always treated as a single token, that is
they are discarded (or returned) as a whole (regardless of the
\&\f(CW\*(C`slash_terminates\*(C'\fR option value).
.Sp
If your statements are to be fed to a DBMS, you are advised to keep this option
to its default (false) value, since some drivers/DBMSs don't want the terminator
to be present at the end of the (single) statement.
.Sp
(Note that the last, possibly empty, statement of a given SQL text, never has a
trailing terminator. See below for an example.)
.RE
.IP \(bu 4
\&\f(CW\*(C`keep_terminator\*(C'\fR
.Sp
An alias for the the \f(CW\*(C`keep_terminators\*(C'\fR option explained above.
Note that if \f(CW\*(C`keep_terminators\*(C'\fR and \f(CW\*(C`keep_terminator\*(C'\fR are both passed to
\&\f(CW\*(C`new\*(C'\fR, an exception is thrown.
.IP \(bu 4
\&\f(CW\*(C`keep_extra_spaces\*(C'\fR
.Sp
A Boolean option which causes, when set to a false value (which is the default),
the spaces (\f(CW\*(C`\es\*(C'\fR) around the statements to be trimmed.
When set to a true value, these spaces are kept instead.
.Sp
When \f(CW\*(C`keep_terminators\*(C'\fR is set to false as well, the terminator is discarded
first (regardless of the spaces around it) and the trailing spaces are trimmed
then. This ensures that if \f(CW\*(C`keep_extra_spaces\*(C'\fR is set to false, the returned
statements will never have trailing (nor leading) spaces, regardless of the
\&\f(CW\*(C`keep_terminators\*(C'\fR value.
.IP \(bu 4
\&\f(CW\*(C`keep_comments\*(C'\fR
.Sp
A Boolean option which causes, when set to a false value (which is the default),
the comments to be discarded in the returned statements. When set to a true
value, they are kept with the statements instead.
.Sp
Both SQL and multi-line C\-style comments are recognized.
.Sp
When kept, each comment is returned in the same string with the atomic statement
it belongs to. A comment belongs to a statement if it appears, in the original
SQL code, before the end of that statement and after the terminator of the
previous statement (if it exists), as shown in this pseudo-SQL snippet:
.Sp
.Vb 3
\&    /* This comment
\&    will be returned
\&    together with statement1 */
\&    
\&    <statement1>; \-\- This will go with statement2
\&                  \-\- (note the semicolon which closes statement1)
\&    
\&    <statement2>
\&    \-\- This with statement2 as well
.Ve
.IP \(bu 4
\&\f(CW\*(C`keep_empty_statements\*(C'\fR
.Sp
A Boolean option which causes, when set to a false value (which is the default),
the empty statements to be discarded. When set to a true value, the empty
statements are returned instead.
.Sp
A statement is considered empty when it contains no characters other than the
terminator and space characters (\f(CW\*(C`\es\*(C'\fR).
.Sp
A statement composed solely of comments is not recognized as empty and may
therefore be returned even when \f(CW\*(C`keep_empty_statements\*(C'\fR is false. To avoid
this, it is sufficient to leave \f(CW\*(C`keep_comments\*(C'\fR to false as well.
.Sp
Note instead that an empty statement is recognized as such regardless of the
value of the options \f(CW\*(C`keep_terminators\*(C'\fR and \f(CW\*(C`keep_extra_spaces\*(C'\fR.
.PP
These options are basically to be kept to their default (false) values,
especially if the atomic statements are to be given to a DBMS.
.PP
They are intended mainly for \fIcosmetic\fR reasons, or if you want to count by how
many atomic statements, including the empty ones, your original SQL code was
composed of.
.PP
Another situation where they are useful (in the general case necessary, really),
is when you want to retain the ability to verbatim rebuild the original SQL
string from the returned statements:
.PP
.Vb 6
\&    my $verbatim_splitter = SQL::SplitStatement\->new(
\&        keep_terminators      => 1,
\&        keep_extra_spaces     => 1,
\&        keep_comments         => 1,
\&        keep_empty_statements => 1
\&    );
\&    
\&    my @verbatim_statements = $verbatim_splitter\->split($sql_string);
\&    
\&    $sql_string eq join \*(Aq\*(Aq, @verbatim_statements; # Always true, given the constructor above.
.Ve
.PP
Other than this, again, you are recommended to stick with the defaults.
.PP
\fIDBMSs Specific Options\fR
.IX Subsection "DBMSs Specific Options"
.PP
The same syntactic structure can have different semantics across different SQL
dialects, so sometimes it is necessary to help the parser to make the right
decision. This is the function of these options.
.IP \(bu 4
\&\f(CW\*(C`slash_terminates\*(C'\fR
.Sp
A Boolean option which causes, when set to a true value (which is the default),
a \f(CW\*(C`/\*(C'\fR (\fIforward-slash\fR) on its own line, even without a preceding semicolon,
to be admitted as a (possible) terminator.
.Sp
If set to false, a forward-slash on its own line is treated as a statement
terminator only if preceded by a semicolon or by a dot and a semicolon.
.Sp
If you are dealing with Oracle's SQL, you should let this option set, since a
slash (alone, without a preceding semicolon) is sometimes used as a terminator,
as it is permitted by SQL*Plus (on non\-\fIblock\fR statements).
.Sp
With SQL dialects other than Oracle, there is the (theoretical) possibility that
a slash on its own line can pass the additional checks and be considered a
terminator (while it shouldn't). This chance should be really tiny (it has never
been observed in real world code indeed). Though negligible, by setting this
option to false that risk can anyway be ruled out.
.ie n .SS """split"""
.el .SS \f(CWsplit\fP
.IX Subsection "split"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->split( $sql_string )\*(C'\fR
.PP
This is the method which actually splits the SQL code into its atomic
components.
.PP
It returns a list containing the atomic statements, in the same order they
appear in the original SQL code. The atomic statements are returned according to
the options explained above.
.PP
Note that, as mentioned above, an SQL string which terminates with a terminator
token (for example a semicolon), contains a trailing empty statement: this is
correct and it is treated accordingly (if \f(CW\*(C`keep_empty_statements\*(C'\fR is set to a
true value):
.PP
.Vb 3
\&    my $sql_splitter = SQL::SplitStatement\->new(
\&        keep_empty_statements => 1
\&    );
\&    
\&    my @statements = $sql_splitter\->split( \*(AqSELECT 1;\*(Aq );
\&    
\&    print \*(AqThe SQL code contains \*(Aq . scalar(@statements) . \*(Aq statements.\*(Aq;
\&    # The SQL code contains 2 statements.
.Ve
.ie n .SS """split_with_placeholders"""
.el .SS \f(CWsplit_with_placeholders\fP
.IX Subsection "split_with_placeholders"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->split_with_placeholders( $sql_string )\*(C'\fR
.PP
It works exactly as the \f(CW\*(C`split\*(C'\fR method explained above, except that it returns
also a list of integers, each of which is the number of the \fIplaceholders\fR
contained in the corresponding atomic statement.
.PP
More precisely, its return value is a list of two elements, the first of which
is a reference to the list of the atomic statements exactly as returned by the
\&\f(CW\*(C`split\*(C'\fR method, while the second is a reference to the list of the number of
placeholders as explained above.
.PP
Here is an example:
.PP
.Vb 7
\&    # 4 statements (valid SQLite SQL)
\&    my $sql_code = <<\*(AqSQL\*(Aq;
\&    CREATE TABLE state (id, name);
\&    INSERT INTO  state (id, name) VALUES (?, ?);
\&    CREATE TABLE city  (id, name, state_id);
\&    INSERT INTO  city  (id, name, state_id) VALUES (?, ?, ?)
\&    SQL
\&        
\&    my $splitter = SQL::SplitStatement\->new;
\&        
\&    my ( $statements, $placeholders )
\&        = $splitter\->split_with_placeholders( $sql_code );
\&        
\&    # $placeholders now is: [0, 2, 0, 3]
.Ve
.PP
where the returned \f(CW$placeholders\fR list(ref) is to be read as follows: the
first statement contains 0 placeholders, the second 2, the third 0 and the
fourth 3.
.PP
The recognized placeholders are:
.IP \(bu 4
\&\fIquestion mark\fR placeholders, represented by the \f(CW\*(C`?\*(C'\fR character;
.IP \(bu 4
\&\fIdollar sign numbered\fR placeholders, represented by the
\&\f(CW\*(C`$1, $2, ..., $n\*(C'\fR strings;
.IP \(bu 4
\&\fInamed parameters\fR, such as \f(CW\*(C`:foo\*(C'\fR, \f(CW\*(C`:bar\*(C'\fR, \f(CW\*(C`:baz\*(C'\fR etc.
.ie n .SS """keep_terminators"""
.el .SS \f(CWkeep_terminators\fP
.IX Subsection "keep_terminators"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_terminators\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_terminators( $boolean )\*(C'\fR
.Sp
Getter/setter method for the \f(CW\*(C`keep_terminators\*(C'\fR option explained above.
.ie n .SS """keep_terminator"""
.el .SS \f(CWkeep_terminator\fP
.IX Subsection "keep_terminator"
An alias for the \f(CW\*(C`keep_terminators\*(C'\fR method explained above.
.ie n .SS """keep_extra_spaces"""
.el .SS \f(CWkeep_extra_spaces\fP
.IX Subsection "keep_extra_spaces"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_extra_spaces\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_extra_spaces( $boolean )\*(C'\fR
.Sp
Getter/setter method for the \f(CW\*(C`keep_extra_spaces\*(C'\fR option explained above.
.ie n .SS """keep_comments"""
.el .SS \f(CWkeep_comments\fP
.IX Subsection "keep_comments"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_comments\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_comments( $boolean )\*(C'\fR
.Sp
Getter/setter method for the \f(CW\*(C`keep_comments\*(C'\fR option explained above.
.ie n .SS """keep_empty_statements"""
.el .SS \f(CWkeep_empty_statements\fP
.IX Subsection "keep_empty_statements"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_empty_statements\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->keep_empty_statements( $boolean )\*(C'\fR
.Sp
Getter/setter method for the \f(CW\*(C`keep_empty_statements\*(C'\fR option explained above.
.ie n .SS """slash_terminates"""
.el .SS \f(CWslash_terminates\fP
.IX Subsection "slash_terminates"
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->slash_terminates\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`$sql_splitter\->slash_terminates( $boolean )\*(C'\fR
.Sp
Getter/setter method for the \f(CW\*(C`slash_terminates\*(C'\fR option explained above.
.SH "SUPPORTED DBMSs"
.IX Header "SUPPORTED DBMSs"
SQL::SplitStatement aims to cover the widest possible range of DBMSs, SQL
dialects and extensions (even proprietary), in a (nearly) fully transparent way
for the user.
.PP
Currently it has been tested mainly on SQLite, PostgreSQL, MySQL and Oracle.
.SS "Procedural Extensions"
.IX Subsection "Procedural Extensions"
Procedural code is by far the most complex to handle.
.PP
Currently any block of code which start with \f(CW\*(C`FUNCTION\*(C'\fR, \f(CW\*(C`PROCEDURE\*(C'\fR,
\&\f(CW\*(C`DECLARE\*(C'\fR, \f(CW\*(C`CREATE\*(C'\fR or \f(CW\*(C`CALL\*(C'\fR is correctly recognized, as well as
\&\fIanonymous\fR \f(CW\*(C`BEGIN ... END\*(C'\fR blocks, \fIdollar quoted\fR blocks and blocks
delimited by a \f(CW\*(C`DELIMITER\*(C'\fR\-defined \fIcustom terminator\fR, therefore a wide range
of procedural extensions should be handled correctly. However, only PL/SQL,
PL/PgSQL and MySQL code has been tested so far.
.PP
If you need also other procedural languages to be recognized, please let me know
(possibly with some test cases).
.SH LIMITATIONS
.IX Header "LIMITATIONS"
Bound to be plenty, given the heuristic nature of this module (and its ambitious
goals). However, no limitations are currently known.
.PP
Please report any problematic test case.
.SS Non-limitations
.IX Subsection "Non-limitations"
To be split correctly, the given input must, in general, be syntactically valid
SQL. For example, an unbalanced \f(CW\*(C`BEGIN\*(C'\fR or a misspelled keyword could, under
certain circumstances, confuse the parser and make it trip over the next
statement terminator, thus returning non-split statements.
This should not be seen as a limitation though, as the original (invalid) SQL
code would have been unusable anyway (remember that this is NOT a validating
parser!)
.SH SHOWCASE
.IX Header "SHOWCASE"
To test the capabilities of this module, you can run it
(or rather run sql-split) on the files \fIt/data/sakila\-schema.sql\fR and
\&\fIt/data/pagila\-schema.sql\fR included in the distribution, which contain two
quite large and complex \fIreal world\fR db schemata, for MySQL and PostgreSQL
respectively.
.PP
For more information:
.IP \(bu 4
Sakila db: <http://dev.mysql.com/doc/sakila/en/sakila.html>
.IP \(bu 4
Pagila db: <http://pgfoundry.org/projects/dbsamples>
.SH DEPENDENCIES
.IX Header "DEPENDENCIES"
SQL::SplitStatement depends on the following modules:
.IP \(bu 4
Carp
.IP \(bu 4
Class::Accessor::Fast
.IP \(bu 4
List::MoreUtils
.IP \(bu 4
Regexp::Common
.IP \(bu 4
SQL::Tokenizer 0.22 or newer
.SH AUTHOR
.IX Header "AUTHOR"
Emanuele Zeppieri, \f(CW\*(C`<emazep@cpan.org>\*(C'\fR
.SH BUGS
.IX Header "BUGS"
No known bugs.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-sql\-SplitStatement at rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=SQL\-SplitStatement>.
I will be notified, and then you'll automatically be notified of progress
on your bug as I make changes.
.SH SUPPORT
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command:
.PP
.Vb 1
\&    perldoc SQL::SplitStatement
.Ve
.PP
You can also look for information at:
.IP \(bu 4
AnnoCPAN: Annotated CPAN documentation
.Sp
<http://annocpan.org/dist/SQL\-SplitStatement>
.IP \(bu 4
CPAN Ratings
.Sp
<http://cpanratings.perl.org/d/SQL\-SplitStatement>
.IP \(bu 4
On MetaCPAN
.Sp
<https://metacpan.org/pod/SQL::SplitStatement/>
.SH ACKNOWLEDGEMENTS
.IX Header "ACKNOWLEDGEMENTS"
Igor Sutton for his excellent SQL::Tokenizer, which made writing
this module a joke.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP \(bu 4
DBIx::MultiStatementDo
.IP \(bu 4
sql-split
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2010\-2011 Emanuele Zeppieri.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation, or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
