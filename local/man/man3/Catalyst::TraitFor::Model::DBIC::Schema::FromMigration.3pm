.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::TraitFor::Model::DBIC::Schema::FromMigration 3pm"
.TH Catalyst::TraitFor::Model::DBIC::Schema::FromMigration 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::TraitFor::Model::DBIC::Schema::FromMigration \- Use your DB Sandbox to run Catalyst
.SH SYNOPSIS
.IX Header "SYNOPSIS"
Use the trait in your Catalyst configuration:
.PP
.Vb 10
\&    \*(AqModel::Schema\*(Aq => {
\&      traits => [\*(AqFromMigration\*(Aq],
\&      schema_class => \*(AqMusicBase::Schema\*(Aq,
\&      extra_migration_args => {
\&        db_sandbox_class => \*(AqDBIx::Class::Migration::MySQLSandbox\*(Aq},
\&      install_if_needed => {
\&        on_install => sub {
\&          my ($schema, $migration) = @_;
\&          $migration\->populate(\*(Aqall_tables\*(Aq)}},
\&      },
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
If you are in development and using a database sandbox auto created and
managed for you with DBIx::Class::Migration, this is a trait to make
it easy to hook that sandbox up to your Catalyst application.  The
following are roughly the same:
.PP
.Vb 1
\&    package MusicBase::Web::Model::Schema;
\&
\&    use Moose;
\&    extends \*(AqCatalyst::Model::DBIC::Schema\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config
\&    (
\&        schema_class => \*(AqMusicBase::Schema\*(Aq,
\&        connect_info => {
\&          dsn => \*(AqDBI:SQLite:_\|_path_to(share,musicbase\-schema.db)_\|_\*(Aq,
\&          user => \*(Aq\*(Aq,
\&          password => \*(Aq\*(Aq,
\&        },
\&    )
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
And using the trait:
.PP
.Vb 1
\&    package MusicBase::Web::Model::Schema;
\&
\&    use Moose;
\&    extends \*(AqCatalyst::Model::DBIC::Schema\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config
\&    (
\&        traits => [\*(AqFromMigration\*(Aq],
\&        schema_class => \*(AqMusicBase::Schema\*(Aq,
\&        extra_migration_args => \e%args,
\&        install_if_needed => {
\&          default_fixture_sets => [\*(Aqall_tables\*(Aq]},
\&    )
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
The biggest reasons to use this trait would be it makes it harder to connect
the wrong database and it gives you some easy helpers for automatic database
installation and fixture population (as you can see in the above example).
.SH "CONFIG PARAMETERS"
.IX Header "CONFIG PARAMETERS"
This trait uses the following configuration parameters:
.SS extra_migration_args
.IX Subsection "extra_migration_args"
Accepts: Hashref, Optional
.PP
A hashref of init arguments that you'd pass to the \f(CW\*(C`new\*(C'\fR method of
DBIx::Class::Migration.  \f(CW\*(C`schema_class\*(C'\fR is inferred from the existing
config parameter, so you don't need to pass that one.  Other arguments of
use could be \f(CW\*(C`db_sandbox_class\*(C'\fR.
.PP
.Vb 2
\&    extra_migration_args => {
\&      db_sandbox_class => \*(AqDBIx::Class::Migration::MySQLSandbox\*(Aq},
.Ve
.PP
For example would use a MySQL development sandbox instead of the default SQLite.
.SS install_if_needed
.IX Subsection "install_if_needed"
Accepts Bool|HashRef, Optional
.PP
If this is a true value, run the "install_if_needed" in DBIx::Class::Migration
method.  If the value is a Hashref, we will assume it is a hashref of callbacks
as documented, and use it as an argument (after de-reffing it).
.SH METHODS
.IX Header "METHODS"
This role exposes the following public methods
.SS migration
.IX Subsection "migration"
Returns the DBIx::Class::Migration object created to assist setting up
and managing your database.
.SS do_install_if_needed
.IX Subsection "do_install_if_needed"
Installs a database and possibly do some data population, if one does not yet
exist.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst::Model::DBIC::Schema, Catalyst
.SH AUTHOR
.IX Header "AUTHOR"
See DBIx::Class::Migration for author information
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
See DBIx::Class::Migration for copyright and license information
