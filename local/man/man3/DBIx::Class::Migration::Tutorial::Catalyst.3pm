.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Migration::Tutorial::Catalyst 3pm"
.TH DBIx::Class::Migration::Tutorial::Catalyst 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Migration::Tutorial::Catalyst \- Using a web framework
.SH GOAL
.IX Header "GOAL"
By the end of this section, you will learn some strategies for using migrations
with web development and for testing.
.PP
This is not a Catalyst tutorial.  You should be familar with the Catalyst
web development framework, and have read the Catalyst::Manual.  Although
we will build a minimal Catalyst application we are focused on database
integration as well as exploring some strategies for testing and would not
consider this application to represent overall best practices.
.PP
Reviewing the documentation for Catalyst::Test would be valuable, as well as
Catalyst::Plugin::ConfigLoader for a refresher on the idea of localized and
enviroment specific configurations.
.SH "Bootstrap a basic Catalyst application"
.IX Header "Bootstrap a basic Catalyst application"
Update you \f(CW\*(C`dist.ini\*(C'\fR file:
.PP
.Vb 6
\&    name    = DBIx\-Class\-Migration
\&    author  = John Napiorkowski <jjnapiork@cpan.org>
\&    license = Perl_5
\&    copyright_holder = John Napiorkowski
\&    copyright_year   = 2012
\&    abstract = Tutorial Application for DBIx\-Class\-Migration
\&
\&    version = 0.001
\&
\&    [@Basic]
\&    [Prereqs]
\&    Moose = 0
\&    MooseX::MethodAttributes = 0
\&    DBIx::Class = 0
\&    DBIx::Class::Migration = 0
\&    Catalyst = 0
\&    Catalyst::Devel = 0
\&    Catalyst::Plugin::ConfigLoader = 0
\&    Catalyst::Model::DBIC::Schema = 0
\&    Catalyst::Action::RenderView = 0
\&    Catalyst::View::TT = 0
\&    Plack = 0
\&
\&    [Prereqs / TestRequires]
\&    Test::DBIx::Class = 0
\&    Test::Most = 0
.Ve
.PP
You should see we've added two dependencies related to Catalyst.  Now install
them with cpanm:
.PP
.Vb 1
\&    dzil listdeps | cpanm
.Ve
.PP
Next, bootstrap a Catalyst application.  I know you can use the catalyst.pl
commandline tool, but for our simple application let's just create a few files
manually:
.PP
.Vb 10
\&    touch app.psgi
\&    touch lib/MusicBase/Web.pm
\&    mkdir lib/MusicBase/Web
\&    mkdir lib/MusicBase/Web/Controller
\&    mkdir lib/MusicBase/Web/Model
\&    mkdir lib/MusicBase/Web/View
\&    touch lib/MusicBase/Web/Controller/Root.pm
\&    touch lib/MusicBase/Web/Model/Schema.pm
\&    touch lib/MusicBase/Web/View/HTML.pm
\&    mkdir share/etc
\&    touch share/etc/musicbase_web.pl
\&    mkdir share/html
\&    touch share/html/index.tt
.Ve
.PP
If you prefer to use a helper, you can also try
<https://metacpan.org/pod/Dist::Zilla::Plugin::Catalyst::New> it generates
part of the files catalyst.pl creates but is closer to the normal
Dist::Zilla stuff.
.PP
Now open \f(CW\*(C`lib/MusicBase/Web.pm\*(C'\fR and change it to look like this:
.PP
.Vb 1
\&    package MusicBase::Web;
\&
\&    use Moose;
\&    use Catalyst qw/
\&      ConfigLoader
\&    /;
\&
\&    extends \*(AqCatalyst\*(Aq;
\&
\&    our $VERSION = \*(Aq0.01\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->config(
\&      \*(AqPlugin::ConfigLoader\*(Aq => {
\&        file => _\|_PACKAGE_\|_\->path_to(\*(Aqshare\*(Aq, \*(Aqetc\*(Aq),
\&      },
\&    );
\&
\&    _\|_PACKAGE_\|_\->setup;
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
This is a pretty plain and straight Catalyst application class.  The only thing
I've done differently from default is I've placed our configuration files in
\&\f(CW\*(C`share/etc\*(C'\fR, rather than in the application root (the directory that contains
your \f(CW\*(C`dist.ini\*(C'\fR file).  I think this is a bit more forward looking, and since
we already have the \f(CW\*(C`share\*(C'\fR directory, why not use it?
.PP
For your Model, we'll use \f(CW\*(C`Catalyst::Model::DBIC::Schema\*(C'\fR to provide a bit of
thin glue between you Catalyst web application and your MusicBase::Schema:
.PP
\&\f(CW\*(C`lib/MusicBase/Web/Model/Schema.pm\*(C'\fR
.PP
.Vb 1
\&    package MusicBase::Web::Model::Schema;
\&
\&    use Moose;
\&    extends \*(AqCatalyst::Model::DBIC::Schema\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
As is typical for Catalyst models, there's not a lot going on here, just the
minimum useful glue to make Catalyst aware of your Schema.
.PP
Let's add the View now.  Open \f(CW\*(C`lib/MusicBase/Web/View/HTML.pm\*(C'\fR and enter:
.PP
.Vb 2
\&    package MusicBase::Web::View::HTML;
\&    use base  \*(AqCatalyst::View::TT\*(Aq;
\&
\&    1;
.Ve
.PP
We'll need a bit of configuration to finish the job of hooking the two together
so open \f(CW\*(C`share/etc/musicbase_web.pl\*(C'\fR in your text editor and make it look like
this:
.PP
.Vb 10
\&    {
\&      name => \*(AqMusicBase::Web\*(Aq,
\&      default_view => \*(AqHTML\*(Aq,
\&      disable_component_resolution_regex_fallback => 1,
\&      \*(AqController::Root\*(Aq => {
\&        namespace => \*(Aq\*(Aq,
\&      },
\&      \*(AqModel::Schema\*(Aq => {
\&        traits => [\*(AqFromMigration\*(Aq],
\&        schema_class => \*(AqMusicBase::Schema\*(Aq,
\&        install_if_needed => {
\&          default_fixture_sets => [\*(Aqall_tables\*(Aq]},
\&      },
\&      \*(AqView::HTML\*(Aq => {
\&        INCLUDE_PATH => [ \*(Aq_\|_path_to(share,html)_\|_\*(Aq ],
\&        TEMPLATE_EXTENSION => \*(Aq.tt\*(Aq,
\&      },
\&    };
.Ve
.PP
I know many of the \f(CW\*(C`Catalyst\*(C'\fR examples use \f(CW\*(C`Config::General\*(C'\fR or YAML for
configuration information.  I tend to use Perl configuration files because of
the extra flexibility.
.PP
I'm setting a few things here, but for our discussion the most important one is
the \f(CW\*(C`Model::Schema\*(C'\fR section, where I point our model to the SQLite database
we've been using all along.  Since we just want Catalyst to use our database
sandbox, the easiest way to do this is to use the \f(CW\*(C`FromMigration\*(C'\fR trait, which
you get for free when you install DBIx::Class::Migration.  You can review
the documentation at Catalyst::TraitFor::Model::DBIC::Schema::FromMigration.
.PP
The configuration given would use the SQLite sandbox.  What if you wanted to
switch to using the MySQL sandbox instead?  The \f(CW\*(C`Model::Schema\*(C'\fR parameters
would look like so:
.PP
.Vb 8
\&    \*(AqModel::Schema\*(Aq => {
\&      traits => [\*(AqFromMigration\*(Aq],
\&      schema_class => \*(AqMusicBase::Schema\*(Aq,
\&      extra_migration_args => {
\&        db_sandbox_class => \*(AqDBIx::Class::Migration::MySQLSandbox\*(Aq},
\&      install_if_needed => {
\&        default_fixture_sets => [\*(Aqall_tables\*(Aq]},
\&      },
.Ve
.PP
In any case, you hopefully noticed that we also run some setup code to install
the database and populate some fixtures, if they are missing.
.PP
\&\fBNOTE\fR: If you use the \f(CW\*(C`FromMigration\*(C'\fR trait, we will automatically start and
stop the database if needed (and you are using a database like MySQL or Postgresql
that needs starting and stopping).  This startup and teardown can impact the
startup time of you application.
.PP
\&\fBNOTE\fR: If you already had a database setup, and are not using the database
sandbox feature (as you won't when in a production server, or if you are using
some shared hosting setups, for example) you should setup your \f(CW\*(C`connect_info\*(C'\fR
as you normally would in a Catalyst configuration.
.PP
Let's setup a trivial controller that pulls a few rows out of the database
and just outputs this to a web page.
.PP
.Vb 1
\&    package MusicBase::Web::Controller::Root;
\&
\&    use Moose;
\&    use MooseX::MethodAttributes;
\&
\&    extends \*(AqCatalyst::Controller\*(Aq;
\&
\&    sub index :Path :Args(0) {
\&      my ($self, $ctx) = @_;
\&      my @artists = $ctx\->model(\*(AqSchema::Artist\*(Aq)
\&        \->search({},{ result_class =>
\&          \*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq })
\&        \->all;
\&
\&      $ctx\->stash(artists => \e@artists);
\&    }
\&
\&    sub end : ActionClass(\*(AqRenderView\*(Aq) {}
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
Here we want to just get all the Artists and send them to our View.  Since in
MVC it is considered correct to inform a View of a Model in a Read Only manner
(in other words, your View should not be able to modify the Model) I generally
use the DBIx::Class::ResultClass::HashRefInflator result class which will
flatten your results to an array of hashrefs, rather than return a list of
result objects.  Besides making it impossible for your template authors to
accidentally modify the model, you get a nice speed bump since inflating an
array of hashrefs is much faster than creating all those result objects.
.PP
Usually I create a resultset method in my base resultset class, and have all
my custom resultsets inherit from that.  Something like:
.PP
.Vb 2
\&    package MusicBase::Schema::ResultSet;
\&    use base \*(AqDBIx::Class::ResultSet;
\&
\&    sub all_as_array {
\&      shift\->search({},{ result_class =>
\&          \*(AqDBIx::Class::ResultClass::HashRefInflator\*(Aq })
\&      \->all;
\&    }
\&
\&    sub all_as_arrayref { [shift\->all_as_array] }
.Ve
.PP
I would have \f(CW\*(C`MusicBase::Schema::ResultSet::Artist\*(C'\fR inherit from
\&\f(CW\*(C`MusicBase::Schema::ResultSet\*(C'\fR instead of DBIx::Class::ResultSet as it does
now.  Then I could have written:
.PP
.Vb 5
\&    sub index :Path :Args(0) {
\&      my ($self, $ctx) = @_;
\&      $ctx\->stash( artists =>
\&        $ctx\->model(\*(AqSchema::Artist\*(Aq)\->all_as_arrayref );
\&    }
.Ve
.PP
This is a common enough pattern for me that it is worth the trouble to create
the base class.  Additionally, if you have lots of DBIx::Class components to
load it helps to create a central base class, since that speeds things up at
load time.
.PP
And here's the template for the webpage: \f(CW\*(C`share/html/index.tt\*(C'\fR
.PP
.Vb 10
\&    <html>
\&      <head>
\&        <title>Artists</title>
\&        <link rel="stylesheet"
\&          href="http://twitter.github.com/bootstrap/1.4.0/bootstrap.min.css"
\&          type="text/css" rel="Stylesheet">
\&      </head>
\&      <body class="container">
\&        <h1>Artist List</h1>
\&        [% FOR artist IN artists %]
\&          <p>[% artist.name %]</p>
\&        [% END %]
\&      </body>
\&    </html>
.Ve
.PP
We'll use Twitter's Bootstrap CSS to make things look neat. Lastly you need to
edit \f(CW\*(C`app.psgi\*(C'\fR as follows:
.PP
.Vb 2
\&    use MusicBase::Web;
\&    MusicBase::Web\->psgi_app;
.Ve
.PP
So now we can start our Catalyst application!
.PP
.Vb 1
\&    plackup \-Ilib
.Ve
.SH "Integrating DBIx::Class::Migration and Catalyst."
.IX Header "Integrating DBIx::Class::Migration and Catalyst."
There's two main places to where Catalyst and DBIx::Class::Migration
can cooperate: Running migrations and Running Tests.
.SS "Running Migrations"
.IX Subsection "Running Migrations"
Although you can just use dbic-migration directly with you Catalyst
application, since Catalyst already does a great job of managing
configuration, let's learn how to subclass DBIx::Class::Migration::Script
and customize it for your application.  That way you don't need to set \f(CW\*(C`ENV\*(C'\fR
or pass option flags to the \f(CW\*(C`dbic\-migration\*(C'\fR commandline tool (and easily
make a mistake and upgrade the wrong database :) ).
.PP
.Vb 1
\&    touch lib/MusicBase/Schema/MigrationScript.pm
.Ve
.PP
And then open \f(CW\*(C`lib/MusicBase/Schema/MigrationScript.pm\*(C'\fR in your editor and
change it to look like this:
.PP
.Vb 1
\&    package MusicBase::Schema::MigrationScript;
\&
\&    use Moose;
\&    use MusicBase::Web;
\&
\&    extends \*(AqDBIx::Class::Migration::Script\*(Aq;
\&
\&    sub defaults {
\&      schema => MusicBase::Web\->model(\*(AqSchema\*(Aq)\->schema,
\&    }
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
\&    _\|_PACKAGE_\|_\->run_if_script;
.Ve
.PP
Basically you've made a subclass of DBIx::Class::Migration::Script but you
are setting the \f(CW\*(C`schema\*(C'\fR to always be whatever Catalyst thinks it is.  Now
you can use Catalysts built in configuration management to decide what
database you are running migrations on.  For example you can run this straight
out (remember to remove the ENV var DBIC_MIGRATION_SCHEMA_CLASS, if you have it
set now for running the tutorial)
.PP
.Vb 3
\&    $ perl \-Ilib lib/MusicBase/Schema/MigrationScript.pm status
\&    Schema is 3
\&    Deployed database is 3
.Ve
.PP
And you can reset the data from fixtures, dump new ones, etc.  Plus, if you
created an enviroment specific configuration (such as if you have a file
\&\f(CW\*(C`share/etc/musicbase_web_qa.pl\*(C'\fR that points to your QA datase) you can leverage
you Catalyst based configuration to make your life a bit easier.  For
example:
.PP
.Vb 2
\&    CATALYST_CONFIG_LOCAL_SUFFIX=qa perl \-Ilib \e
\&      lib/MusicBase/Schema/MigrationScript.pm status
.Ve
.PP
Would grab the connected schema for your qa enviroment specific configuration
and give you the status on that (assuming you can ping it from your logged
in terminal).  This integration is very useful since you can use whatever your
Catalyst application thinks is the current database as the target of the
migration.  You can use other bits of configuration info as well, such as a
custom \f(CW\*(C`target_dir\*(C'\fR etc.
.PP
\&\fBAlternative\fR: If subclasing DBIx::Class::Migration::Script seems like an
overly heavy handed solution, or running the *.pm file like a script just
weirds you out, you can simply create a script like the following, which would
work identically:
.PP
For example, something in \f(CW\*(C`script/my\-dbic\-migration\*(C'\fR
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use MusicBase::Web;
\&    use DBIx::Class::Migration::Script;
\&
\&    DBIx::Class::Migration::Script
\&      \->run_with_options(
\&        schema => MusicBase::Web\->model(\*(AqSchema\*(Aq)\->schema);
.Ve
.PP
And then use it like:
.PP
.Vb 1
\&    perl \-Ilib script/my\-dbic\-migration status
.Ve
.PP
\&\fBNOTE\fR: In this case you need to invoke the perl interp with \f(CW\*(C`\-Ilib\*(C'\fR so that
we can find \f(CW\*(C`MusicBase::Web\*(C'\fR
.PP
If you have a bunch of files in \f(CW\*(C`/script\*(C'\fR or if you need to be able to run
your custom migration tool after installation, this could be a good option.
.SS "Running Tests"
.IX Subsection "Running Tests"
We've seen how using tools like Test::DBIx::Class together with DBIx::Class::Migration
can really simplify your unit level testing effort.  Using them you don't
need to spend a lot of time setting up dedicated testing databases and
managing configuration sets (that need to change over time).  However if you
want to write tests that check your actual web pages (for example you want to
test things like if a page shows the correct results and if web forms work)
you need to manage that a bit differently.  Here's what I do:
.PP
First, create a enviroment specific configuration for testing:
.PP
.Vb 1
\&    touch share/etc/musicbase_web_test.pl
.Ve
.PP
Then open \f(CW\*(C`share/etc/musicbase_web_test.pl\*(C'\fR and add the following:
.PP
.Vb 11
\&    {
\&      \*(AqModel::Schema\*(Aq => {
\&        traits => [\*(AqFromMigration\*(Aq],
\&        schema_class => \*(AqMusicBase::Schema\*(Aq,
\&        extra_migration_args => {
\&          db_sandbox_builder_class => \*(AqDBIx::Class::Migration::TempDirSandboxBuilder\*(Aq,
\&          db_sandbox_class => \*(AqDBIx::Class::Migration::MySQLSandbox\*(Aq},
\&        install_if_needed => {
\&          default_fixture_sets => [\*(Aqall_tables\*(Aq]},
\&      },
\&    };
.Ve
.PP
So what is going to happen here is if you start the application pointing to
this configuration (with \f(CW\*(C`CATALYST_CONFIG_LOCAL_SUFFIX\*(C'\fR=test) when the application
runs it will automatically create a clean new database and populate it with
the \f(CW\*(C`all_tables\*(C'\fR fixture set.  Just for fun, we will create a test instance
of Mysql.  Please note this will be a temporary sandbox, and will be deleted
when your Catalyst application exits.  It is not the same as the MySQL
sandbox we created in \f(CW\*(C`share/musicbase\-schema/*\*(C'\fR.
.PP
This looks similar to the first configuration file we did, where we use the
\&\f(CW\*(C`FromMigration\*(C'\fR trait to hookup your migration deployments.  However, instead
of running our tests on the database sandbox in \f(CW\*(C`/share\*(C'\fR (which you don't want
to so since that's not going to be a reliable and consistent database for
testing) we use the following bit:
.PP
.Vb 1
\&    db_sandbox_builder_class => \*(AqDBIx::Class::Migration::TempDirSandboxBuilder\*(Aq,
.Ve
.PP
To instruct the sandbox builder to put the sandbox into a temporary directory
instead of \f(CW\*(C`/share\*(C'\fR.  What will happen here is that (similar to the way that
we saw with Test::DBIx::Class) we build up a database from scratch, populate
it with known fixtures, run tests, and then tear it down at the end.  This way
you get clean and repeatable tests.  The downside is that the buildup / teardown
can add time to the tests, athough you should be able to run your test cases
in parallel (using \f(CW\*(C`prove \-j9 ...\*(C'\fR, to run up to nine tests at once) to offset
this issue.
.PP
Let's write a test case:
.PP
.Vb 1
\&    touch t/web.t
.Ve
.PP
And open \f(CW\*(C`t/web.t\*(C'\fR in your editor:
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use Test::Most;
\&    use Catalyst::Test \*(AqMusicBase::Web\*(Aq;
\&
\&    ok my $content  = get(\*(Aq/\*(Aq),
\&      \*(Aqgot some content\*(Aq;
\&
\&    like $content, qr/Michael Jackson/,
\&      \*(AqFound Michael Jackson\*(Aq;
\&
\&    done_testing;
.Ve
.PP
Finally run your test:
.PP
.Vb 1
\&    CATALYST_CONFIG_LOCAL_SUFFIX=test prove \-lvr t/web.t
.Ve
.PP
You know from when we did the original demo data script that "Michael Jackson"
was one of the artist, so we'd expect to find him in the <$content> from the
Root controller (since that's just a list of all the Artist names).  So you'd
probably want a bit more testing on this page, but this should give you the
idea.
.PP
Since the above test builds and breaks down a full MySQL sandbox, it might not
run instantly, just FYI.
.SH SUMMARY
.IX Header "SUMMARY"
That's it for some ideas on using migrations with a web development framework
like Catalyst.  If you are using Catalyst you can take advantage of its
great configuration management tools to make it even easier to manage your
migrations.  You also now have some strategies for making it easy to test.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Proceed to DBIx::Class::Migration::Tutorial::Conclusion
.SH AUTHOR
.IX Header "AUTHOR"
See DBIx::Class::Migration for author information
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
See DBIx::Class::Migration for copyright and license information
