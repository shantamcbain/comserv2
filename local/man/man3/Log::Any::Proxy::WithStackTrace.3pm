.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Any::Proxy::WithStackTrace 3pm"
.TH Log::Any::Proxy::WithStackTrace 3pm 2023-08-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Log::Any::Proxy::WithStackTrace \- Log::Any proxy to upgrade string errors to objects with stack traces
.SH VERSION
.IX Header "VERSION"
version 1.717
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Any qw( $log, proxy_class => \*(AqWithStackTrace\*(Aq );
\&
\&  # Allow stack trace call stack arguments to be logged:
\&  use Log::Any qw( $log, proxy_class => \*(AqWithStackTrace\*(Aq,
\&                         proxy_show_stack_trace_args => 1 );
\&
\&  # Configure some adapter that knows how to:
\&  #  1) handle structured data, and
\&  #  2) handle message objects which have a "stack_trace" method:
\&  Log::Any::Adapter\->set($adapter);
\&
\&  $log\->error("Help!");   # stack trace gets automatically added,
\&                          # starting from this line of code
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Some log adapters, like Log::Any::Adapter::Sentry::Raven, are able to
take advantage of being passed message objects that contain a stack
trace.  However if a stack trace is not available, and fallback logic is
used to generate one, the resulting trace can be confusing if it begins
relative to where the log adapter was called, and not relative to where
the logging method was originally called.
.PP
With this proxy in place, if any logging method is called with a log
message that is a non-reference scalar (i.e. a string), that log message
will be upgraded into a \f(CW\*(C`Log::Any::MessageWithStackTrace\*(C'\fR object with a
\&\f(CW\*(C`stack_trace\*(C'\fR method, and that method will return a trace relative to
where the logging method was called.  A string overload is provided on
the object to return the original log message.
.PP
Additionally, any call stack arguments in the stack trace will be
deleted before logging, to avoid accidentally logging sensitive data.
This happens both for message objects that were auto-generated from
string messages, as well as for message objects that were passed in
directly (if they appear to have a stack trace method).  This default
argument scrubbing behavior can be turned off by specifying a true value
for the \f(CW\*(C`proxy_show_stack_trace_args\*(C'\fR import flag.
.PP
\&\fBImportant:\fR This proxy should be used with a Log::Any::Adapter that
is configured to handle structured data.  Otherwise the object created
here will just get stringified before it can be used to access the stack
trace.
.SH METHODS
.IX Header "METHODS"
.SS maybe_upgrade_with_stack_trace
.IX Subsection "maybe_upgrade_with_stack_trace"
.Vb 1
\&  @args = $self\->maybe_upgrade_with_stack_trace(@args);
.Ve
.PP
This is an internal-use method that will convert a non-reference scalar
message into a \f(CW\*(C`Log::Any::MessageWithStackTrace\*(C'\fR object with a
\&\f(CW\*(C`stack_trace\*(C'\fR method.  A string overload is provided to return the
original message.
.PP
Stack trace args are scrubbed out in case they contain sensitive data,
unless the \f(CW\*(C`proxy_show_stack_trace_args\*(C'\fR option has been set.
.SS maybe_delete_stack_trace_args
.IX Subsection "maybe_delete_stack_trace_args"
.Vb 1
\&  $self\->maybe_delete_stack_trace_args($arg);
.Ve
.PP
This is an internal-use method that, given a single argument that is a
reference, tries to figure out whether the argument is an object with a
stack trace, and if so tries to delete any stack trace args.
.PP
The logic is based on Devel::StackTrace::Extract.
.PP
It specifically looks for objects with a \f(CW\*(C`stack_trace\*(C'\fR method (which
should catch anything that does StackTrace::Auto, including anything
that does Throwable::Error), or a \f(CW\*(C`trace\*(C'\fR method (used by
Exception::Class and Moose::Exception and friends).
.PP
It specifically ignores Mojo::Exception objects, because their stack
traces don't contain any call stack args.
.SS delete_args_from_stack_trace($trace)
.IX Subsection "delete_args_from_stack_trace($trace)"
.Vb 1
\&  $self\->delete_args_from_stack_trace($trace)
.Ve
.PP
To scrub potentially sensitive data from \f(CW\*(C`Devel::StackTrace\*(C'\fR arguments,
this method deletes arguments from all of the \f(CW\*(C`Devel::StackTrace::Frame\*(C'\fR
in the trace.
.SH AUTHORS
.IX Header "AUTHORS"
.IP \(bu 4
Jonathan Swartz <swartz@pobox.com>
.IP \(bu 4
David Golden <dagolden@cpan.org>
.IP \(bu 4
Doug Bell <preaction@cpan.org>
.IP \(bu 4
Daniel Pittman <daniel@rimspace.net>
.IP \(bu 4
Stephen Thirlwall <sdt@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Jonathan Swartz, David Golden, and Doug Bell.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
