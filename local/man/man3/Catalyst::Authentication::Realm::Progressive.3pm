.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Realm::Progressive 3pm"
.TH Catalyst::Authentication::Realm::Progressive 3pm 2024-10-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::Authentication::Realm::Progressive \- Authenticate against multiple realms
.SH SYNOPSIS
.IX Header "SYNOPSIS"
This Realm allows an application to use a single \fBauthenticate()\fR call during
which multiple realms are used and tried incrementally until one performs
a successful authentication is accomplished.
.PP
A simple use case is a Temporary Password that looks and acts exactly as a
regular password. Without changing the authentication code, you can
authenticate against multiple realms.
.PP
Another use might be to support a legacy website authentication system, trying
the current auth system first, and upon failure, attempting authentication against
the legacy system.
.SS EXAMPLE
.IX Subsection "EXAMPLE"
If your application has multiple realms to authenticate, such as a temporary
password realm and a normal realm, you can configure the progressive realm as
the default, and configure it to iteratively call the temporary realm and then
the normal realm.
.PP
.Vb 10
\& _\|_PACKAGE_\|_\->config(
\&    \*(AqPlugin::Authentication\*(Aq => {
\&        default_realm => \*(Aqprogressive\*(Aq,
\&        realms => {
\&            progressive => {
\&                class => \*(AqProgressive\*(Aq,
\&                realms => [ \*(Aqtemp\*(Aq, \*(Aqnormal\*(Aq ],
\&                # Modify the authinfo passed into authenticate by merging
\&                # these hashes into the realm\*(Aqs authenticate call:
\&                authinfo_munge => {
\&                    normal => { \*(Aqtype\*(Aq => \*(Aqnormal\*(Aq },
\&                    temp   => { \*(Aqtype\*(Aq => \*(Aqtemporary\*(Aq },
\&                }
\&            },
\&            normal => {
\&                credential => {
\&                    class => \*(AqPassword\*(Aq,
\&                    password_field => \*(Aqsecret\*(Aq,
\&                    password_type  => \*(Aqhashed\*(Aq,
\&                    password_hash_type => \*(AqSHA\-1\*(Aq,
\&                },
\&                store => {
\&                    class      => \*(AqDBIx::Class\*(Aq,
\&                    user_model => \*(AqSchema::Person::Identity\*(Aq,
\&                    id_field   => \*(Aqid\*(Aq,
\&                }
\&            },
\&            temp => {
\&                credential => {
\&                    class => \*(AqPassword\*(Aq,
\&                    password_field => \*(Aqsecret\*(Aq,
\&                    password_type  => \*(Aqhashed\*(Aq,
\&                    password_hash_type => \*(AqSHA\-1\*(Aq,
\&                },
\&                store => {
\&                    class    => \*(AqDBIx::Class\*(Aq,
\&                    user_model => \*(AqSchema::Person::Identity\*(Aq,
\&                    id_field   => \*(Aqid\*(Aq,
\&                }
\&            },
\&        }
\&    }
\& );
.Ve
.PP
Then, in your controller code, to attempt authentication against both realms
you just have to do a simple authenticate call:
.PP
.Vb 5
\& if ( $c\->authenticate({ id => $username, password => $password }) ) {
\&     if ( $c\->user\->type eq \*(Aqtemporary\*(Aq ) {
\&         # Force user to change password
\&     }
\& }
.Ve
.SH CONFIGURATION
.IX Header "CONFIGURATION"
.IP realms 4
.IX Item "realms"
An array reference consisting of each realm to attempt authentication against,
in the order listed.  If the realm does not exist, calling authenticate will
die.
.IP authinfo_munge 4
.IX Item "authinfo_munge"
A hash reference keyed by realm names, with values being hash references to
merge into the authinfo call that is subsequently passed into the realm's
authenticate method.  This is useful if your store uses the same class for each
realm, separated by some other token (in the EXAMPLE authinfo_mungesection,
the 'realm' is a column on \f(CW\*(C`Schema::Person::Identity\*(C'\fR that will be either
\&'temp' or 'local', to ensure the query to fetch the user finds the right
Identity record for that realm.
.SH METHODS
.IX Header "METHODS"
.ie n .SS "new ($realmname, $config, $app)"
.el .SS "new ($realmname, \f(CW$config\fP, \f(CW$app\fP)"
.IX Subsection "new ($realmname, $config, $app)"
Constructs an instance of this realm.
.SS authenticate
.IX Subsection "authenticate"
This method iteratively calls each realm listed in the \f(CW\*(C`realms\*(C'\fR configuration
key.  It returns after the first successful authentication call is done.
.SH AUTHORS
.IX Header "AUTHORS"
J. Shirley \f(CW\*(C`<jshirley@cpan.org>\*(C'\fR
.PP
Jay Kuri \f(CW\*(C`<jayk@cpan.org>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2008 the aforementioned authors. All rights reserved. This program
is free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
