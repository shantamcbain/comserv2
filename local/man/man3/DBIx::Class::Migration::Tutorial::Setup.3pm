.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Migration::Tutorial::Setup 3pm"
.TH DBIx::Class::Migration::Tutorial::Setup 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Migration::Tutorial::Setup \- Bootstrap your project files
.SH GOAL
.IX Header "GOAL"
By the end of this section, you should be able to bootstrap a standard Perl
project and have a simple DBIx::Class project installed.  You should then
be able to proceed to creating some migrations.
.SH "Bootstrap your Project"
.IX Header "Bootstrap your Project"
We make minimal use of Dist::Zilla to create a basic project skeleton.  I
realize Dist::Zilla is not everyone's favorite tool for this purpose, but I
am choosing it for the purpose of the tutorial because its simple enough for my
basic need.  If you know enough to not like Dist::Zilla then I will assume
you know enough to perform this next task using some other tool.
.SH "Open a shell / terminal"
.IX Header "Open a shell / terminal"
Most Perl projects use commandline tools, rather than a GUI IDE.  You should
open a terminal with a commandline interface of choice, change to a directory
where you like to store project files (such as \f(CW$HOME\fR or \f(CW\*(C`$HOME/Desktop\*(C'\fR)
and proceed.
.SH "Install Dist::Zilla"
.IX Header "Install Dist::Zilla"
.Vb 1
\&    cpanm Dist::Zilla
.Ve
.SH "Create a basic Project Skeleton"
.IX Header "Create a basic Project Skeleton"
.Vb 2
\&    dzil new MusicBase
\&    cd MusicBase
.Ve
.PP
You should now have a directory structure like this:
.PP
.Vb 4
\&    /MusicBase
\&      dist.ini
\&      /lib
\&        MusicBase.pm
.Ve
.PP
We will use the \f(CW\*(C`dist.ini\*(C'\fR file to manage our project dependencies.  Open
\&\f(CW\*(C`dist.ini\*(C'\fR in your editor of choice and alter it to look like this:
.PP
.Vb 6
\&    name    = MusicBase
\&    author  = John Napiorkowski <jjnapiork@cpan.org>
\&    license = Perl_5
\&    copyright_holder = John Napiorkowski
\&    copyright_year   = 2012
\&    abstract = Tutorial Application for DBIx\-Class\-Migration
\&
\&    version = 0.001
\&
\&    [@Basic]
\&    [Prereqs]
\&    DBIx::Class = 0
\&    DBIx::Class::Migration = 0
.Ve
.PP
Set \f(CW\*(C`author\*(C'\fR and \f(CW\*(C`copyright_holder\*(C'\fR as suits you.
.PP
Next open the file \f(CW\*(C`lib/MusicBase.pm\*(C'\fR in your text editor and change it as
follows:
.PP
.Vb 1
\&    package MusicBase;
\&
\&    our $VERSION = \*(Aq0.001\*(Aq;
\&
\&    1;
\&
\&    =head1 NAME
\&
\&    MusicBase \- The DBIx::Class::Migration tutorial application
\&
\&    =head1 AUTHOR
\&
\&    John Napiorkowski L<email:jjnapiork@cpan.org>
\&
\&    =head1 SEE ALSO
\&
\&    L<DBIx::Class::Migration>
\&
\&    =head1 COPYRIGHT & LICENSE
\&
\&    Copyright 2012, John Napiorkowski L<email:jjnapiork@cpan.org>
\&
\&    This library is free software; you can redistribute it and/or modify it under
\&    the same terms as Perl itself.
\&
\&    =cut
.Ve
.PP
As you can see, this is just a stub of POD to help give someone general
context.
.PP
Going forward, when I say 'do something in your project home directory', I mean
inside this new \f(CW\*(C`MusicBase\*(C'\fR directory which you just made.
.PP
Congrats, you have a basic Perl project setup!  If you are using a source
control tool, you should probably commit.
.SH "Install your dependencies"
.IX Header "Install your dependencies"
You listed a few dependencies in the \f(CW\*(C`dist.ini\*(C'\fR file you modified above.  Let's
get those installed now:
.PP
.Vb 1
\&    dzil listdeps | cpanm
.Ve
.PP
Managing your project dependencies via your \f(CW\*(C`dist.ini\*(C'\fR file (or \f(CW\*(C`Makefile.PL\*(C'\fR
if you prefer) is considered a community approved best practice.
.SH "DBIx::Class Application Version 1"
.IX Header "DBIx::Class Application Version 1"
In this section you'll setup a first version of the MusicBase DBIC files.
.PP
The working application we are going to design is called MusicBase which
is an application that tracks what Artists have made what CDs and which
Tracks are part of which CD.  Here's the general model:
.PP
.Vb 4
\&    \-\- An Artist has zero or more Cds.
\&    \-\- Each Cd belongs to a single Artist
\&    \-\- Each Cd has zero or more Tracks (or songs you can listen to)
\&    \-\- A Track can belong to only one Cd.
.Ve
.PP
Additionally you need to store the Artists name, and the titles for both the
Cds and the Tracks.
.PP
You also have some business logic that requires you to return the set of
Artists that have more than one Cd published.  Let's model that!
.PP
From your application home directory (the directory that contains your
\&\f(CW\*(C`dist.ini\*(C'\fR file) perform the following commands:
.PP
.Vb 9
\&    mkdir lib/MusicBase
\&    mkdir lib/MusicBase/Schema
\&    mkdir lib/MusicBase/Schema/Result
\&    mkdir lib/MusicBase/Schema/ResultSet
\&    touch lib/MusicBase/Schema.pm
\&    touch lib/MusicBase/Schema/Result/Artist.pm
\&    touch lib/MusicBase/Schema/Result/Cd.pm
\&    touch lib/MusicBase/Schema/Result/Track.pm
\&    touch lib/MusicBase/Schema/ResultSet/Artist.pm
.Ve
.PP
You'll now have a standard DBIx::Class directory structure that follows
current good practices.  Lets add in some code to our file stubs.
.PP
Change \f(CW\*(C`lib/MusicBase/Schema.pm\*(C'\fR to match the following:
.PP
.Vb 1
\&    package MusicBase::Schema;
\&
\&    use strict;
\&    use warnings;
\&
\&    use base \*(AqDBIx::Class::Schema\*(Aq;
\&
\&    our $VERSION = 1;
\&
\&    _\|_PACKAGE_\|_\->load_namespaces;
\&
\&    1;
.Ve
.PP
Change \f(CW\*(C`lib/MusicBase/Schema/Result/Artist.pm\*(C'\fR
.PP
.Vb 1
\&    package MusicBase::Schema::Result::Artist;
\&
\&    use strict;
\&    use warnings;
\&
\&    use base \*(AqDBIx::Class::Core\*(Aq;
\&
\&    _\|_PACKAGE_\|_\->table(\*(Aqartist\*(Aq);
\&    _\|_PACKAGE_\|_\->add_columns(
\&      \*(Aqartist_id\*(Aq => {
\&        data_type => \*(Aqinteger\*(Aq,
\&      },
\&      \*(Aqname\*(Aq => {
\&        data_type => \*(Aqvarchar\*(Aq,
\&        size => \*(Aq96\*(Aq,
\&      });
\&
\&    _\|_PACKAGE_\|_\->set_primary_key(\*(Aqartist_id\*(Aq);
\&    _\|_PACKAGE_\|_\->has_many(
\&      \*(Aqcd_rs\*(Aq => \*(AqMusicBase::Schema::Result::Cd\*(Aq,
\&      {\*(Aqforeign.artist_fk\*(Aq=>\*(Aqself.artist_id\*(Aq});
\&
\&    1;
.Ve
.PP
Change \f(CW\*(C`lib/MusicBase/Schema/Result/Cd.pm\*(C'\fR
.PP
.Vb 1
\&    package MusicBase::Schema::Result::Cd;
\&
\&    use strict;
\&    use warnings;
\&
\&    use base qw/DBIx::Class::Core/;
\&
\&    _\|_PACKAGE_\|_\->table(\*(Aqcd\*(Aq);
\&    _\|_PACKAGE_\|_\->add_columns(
\&      \*(Aqcd_id\*(Aq => {
\&        data_type => \*(Aqinteger\*(Aq,
\&      },
\&      \*(Aqartist_fk\*(Aq => {
\&        data_type => \*(Aqinteger\*(Aq,
\&      },
\&      \*(Aqtitle\*(Aq => {
\&        data_type => \*(Aqvarchar\*(Aq,
\&        size => \*(Aq96\*(Aq,
\&      });
\&
\&    _\|_PACKAGE_\|_\->set_primary_key(\*(Aqcd_id\*(Aq);
\&
\&    _\|_PACKAGE_\|_\->belongs_to(
\&      \*(Aqartist\*(Aq => \*(AqMusicBase::Schema::Result::Artist\*(Aq,
\&      {\*(Aqforeign.artist_id\*(Aq=>\*(Aqself.artist_fk\*(Aq});
\&
\&    _\|_PACKAGE_\|_\->has_many(
\&      \*(Aqtrack_rs\*(Aq => \*(AqMusicBase::Schema::Result::Track\*(Aq,
\&      {\*(Aqforeign.cd_fk\*(Aq=>\*(Aqself.cd_id\*(Aq});
\&
\&    1;
.Ve
.PP
Change \f(CW\*(C`lib/MusicBase/Schema/Result/Track.pm\*(C'\fR
.PP
.Vb 1
\&    package MusicBase::Schema::Result::Track;
\&
\&    use strict;
\&    use warnings;
\&
\&    use base qw/DBIx::Class::Core/;
\&
\&    _\|_PACKAGE_\|_\->table(\*(Aqtrack\*(Aq);
\&    _\|_PACKAGE_\|_\->add_columns(
\&      \*(Aqtrack_id\*(Aq => {
\&        data_type => \*(Aqinteger\*(Aq,
\&      },
\&      \*(Aqcd_fk\*(Aq => {
\&        data_type => \*(Aqinteger\*(Aq,
\&      },
\&      \*(Aqtitle\*(Aq => {
\&        data_type => \*(Aqvarchar\*(Aq,
\&        size => \*(Aq96\*(Aq,
\&      });
\&
\&    _\|_PACKAGE_\|_\->set_primary_key(\*(Aqtrack_id\*(Aq);
\&    _\|_PACKAGE_\|_\->belongs_to(
\&      \*(Aqcd\*(Aq => "MusicBase::Schema::Result::Cd",
\&      {\*(Aqforeign.cd_id\*(Aq=>\*(Aqself.cd_fk\*(Aq});
\&
\&    1;
.Ve
.PP
Change \f(CW\*(C`lib/MusicBase/Schema/ResultSet/Artist.pm\*(C'\fR
.PP
.Vb 1
\&    package MusicBase::Schema::ResultSet::Artist;
\&
\&    use strict;
\&    use warnings;
\&
\&    use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&
\&    sub has_more_than_one_cds {
\&      my $me = (my $self = shift)\->current_source_alias;
\&      $self\->search(
\&        {},
\&        {
\&          join=>[\*(Aqcd_rs\*(Aq],
\&          \*(Aq+select\*(Aq=> [ { count => \*(Aqcd_rs.cd_id\*(Aq, \-as => \*(Aqcd_count\*(Aq} ],
\&          \*(Aq+as\*(Aq=> [\*(Aqcd_count\*(Aq],
\&          group_by=>["$me.artist_id"],
\&          having => { cd_count => \e\*(Aq> 1\*(Aq }
\&        }
\&      );
\&    }
\&
\&    1;
.Ve
.PP
That completes creating your basic DBIx::Class structure.
.SH "Basic Test Case"
.IX Header "Basic Test Case"
You should create a basic test case just to make sure you didn't make any
serious errors or forgot something while creating the files.
.PP
.Vb 2
\&    mkdir t
\&    touch t/use.t
.Ve
.PP
Change \f(CW\*(C`t/use.t\*(C'\fR as follows
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use Test::Most tests=>1;
\&
\&    BEGIN {
\&      use_ok \*(AqMusicBase::Schema\*(Aq;
\&    }
.Ve
.PP
Then run your test case.
.PP
.Vb 1
\&    prove \-lv t/use.t
.Ve
.PP
You should expect the one test to pass.  If it fails, please review your
classes since you probably introduced a typo or syntax error.
.PP
If your tests pass, that's great you've completed the first part of the
tutorial!
.SH SUMMARY
.IX Header "SUMMARY"
You did a lot of cut and paste this step, I promise things will be more
interesting later on.  However, you did all the main grunt work that it takes
to get going on a well formed Perl project.  At this point you have a DBIC
application that you'd actually be able to use.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Proceed to DBIx::Class::Migration::Tutorial::FirstMigration.
.SH AUTHOR
.IX Header "AUTHOR"
See DBIx::Class::Migration for author information
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
See DBIx::Class::Migration for copyright and license information
