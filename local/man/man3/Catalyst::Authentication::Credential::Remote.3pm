.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Credential::Remote 3pm"
.TH Catalyst::Authentication::Credential::Remote 3pm 2024-10-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::Authentication::Credential::Remote \- Let the webserver (e.g. Apache)
authenticate Catalyst application users
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&    # in your MyApp.pm
\&    _\|_PACKAGE_\|_\->config(
\&
\&        \*(AqPlugin::Authentication\*(Aq => {
\&            default_realm => \*(Aqremoterealm\*(Aq,
\&            realms => {
\&                remoterealm => {
\&                    credential => {
\&                        class        => \*(AqRemote\*(Aq,
\&                        allow_regexp => \*(Aq^(user.*|admin|guest)$\*(Aq,
\&                        deny_regexp  => \*(Aqtest\*(Aq,
\&                    },
\&                    store => {
\&                        class => \*(AqNull\*(Aq,
\&                        # if you want to have some additional user attributes
\&                        # like user roles, user full name etc. you can specify
\&                        # here the store where you keep this data
\&                    }
\&                },
\&            },
\&        },
\&        
\&    );
\&    
\&    # in your Controller/Root.pm you can implement "auto\-login" in this way
\&    sub begin : Private {
\&        my ( $self, $c ) = @_;        
\&        unless ($c\->user_exists) {
\&            # authenticate() for this module does not need any user info
\&            # as the username is taken from $c\->req\->remote_user and
\&            # password is not needed     
\&            unless ($c\->authenticate( {} )) {
\&              # return 403 forbidden or kick out the user in other way
\&            };
\&        }   
\&    }
\&
\&    # or you can implement in any controller an ordinary login action like this
\&    sub login : Global {
\&        my ( $self, $c ) = @_;
\&        $c\->authenticate( {} );
\&    }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module allows you to authenticate the users of your Catalyst application
on underlaying webserver. The complete list of authentication method available 
via this module depends just on what your webserver (e.g. Apache, IIS, Lighttpd)
is able to handle.
.PP
Besides the common methods like HTTP Basic and Digest authentication you can
also use sophisticated ones like so called "integrated authentication" via
NTLM or Kerberos (popular in corporate intranet applications running in Windows
Active Directory environment) or even the SSL authentication when users 
authenticate themself using their client SSL certificates.
.PP
The main idea of this module is based on a fact that webserver passes the name
of authenticated user into Catalyst application as REMOTE_USER variable (or in 
case of SSL client authentication in other variables like SSL_CLIENT_S_DN on
Apache + mod_ssl) \- from this point referenced as WEBUSER. 
This module simply takes this value \- perfoms some optional checks (see
below) \- and if everything is OK the WEBUSER is declared as authenticated on 
Catalyst level. In fact this module does not perform any check for password or 
other credential; it simply believes the webserver that user was properly 
authenticated.
.SH CONFIG
.IX Header "CONFIG"
.SS class
.IX Subsection "class"
This config item is \fBREQUIRED\fR.
.PP
\&\fBclass\fR is part of the core Catalyst::Plugin::Authentication module, it 
contains the class name of the store to be used.
.PP
The classname used for Credential. This is part of Catalyst::Plugin::Authentication
and is the method by which Catalyst::Authentication::Credential::Remote is
loaded as the credential validator. For this module to be used, this must be set
to 'Remote'.
.SS source
.IX Subsection "source"
This config item is \fBOPTIONAL\fR \- default is REMOTE_USER.
.PP
\&\fBsource\fR contains a name of a variable passed from webserver that contains the 
user identification.
.PP
Supported values: REMOTE_USER, SSL_CLIENT_*, CERT_*, AUTH_USER
.PP
\&\fBBEWARE:\fR Support for using different variables than REMOTE_USER does not work 
properly with Catalyst 5.8004 and before (if you want details see source code).
.PP
Note1: Apache + mod_ssl uses SSL_CLIENT_S_DN, SSL_CLIENT_S_DN_* etc. (has to be 
enabled by 'SSLOption +StdEnvVars') or you can also let Apache make a copy of 
this value into REMOTE_USER (Apache option 'SSLUserName SSL_CLIENT_S_DN').
.PP
Note2: Microsoft IIS uses CERT_SUBJECT, CERT_SERIALNUMBER etc. for storing info
about client authenticated via SSL certificate. AUTH_USER on IIS seems to have
the same value as REMOTE_USER (but there might be some differences I am not
aware of).
.SS deny_regexp
.IX Subsection "deny_regexp"
This config item is \fBOPTIONAL\fR \- no default value.
.PP
\&\fBdeny_regexp\fR contains a regular expression used for check against WEBUSER 
(see details below)
.SS allow_regexp
.IX Subsection "allow_regexp"
This config item is \fBOPTIONAL\fR \- no default value.
.PP
\&\fBdeny_regexp\fR contains a regular expression used for check against WEBUSER.
.PP
Allow/deny checking of WEBUSER values goes in this way:
.PP
1) If \fBdeny_regexp\fR is defined and WEBUSER matches deny_regexp then 
authentication FAILS otherwise continues with next step. If deny_regexp is not 
defined or is an empty string we skip this step.
.PP
2) If \fBallow_regexp\fR is defined and WEBUSER matches allow_regexp then 
authentication PASSES otherwise FAILS. If allow_regexp is not 
defined or is an empty string we skip this step.
.PP
The order deny-allow is fixed.
.SS cutname_regexp
.IX Subsection "cutname_regexp"
This config item is \fBOPTIONAL\fR \- no default value.
.PP
If param \fBcutname_regexp\fR is specified we try to cut the final usename passed to
Catalyst application as a substring from WEBUSER. This is useful for 
example in case of SSL authentication when WEBUSER looks like this 
\&'CN=john, OU=Unit Name, O=Company, C=CZ' \- from this format we can simply cut
pure usename by cutname_regexp set to 'CN=(.*), OU=Unit Name, O=Company, C=CZ'.
.PP
Substring is always taken as '$1' regexp substring. If WEBUSER does not
match cutname_regexp at all or if '$1' regexp substring is empty we pass the
original WEBUSER value (without cutting) to Catalyst application.
.SS username_field
.IX Subsection "username_field"
This config item is \fBOPTIONAL\fR \- default is \fIusername\fR
.PP
The key name in the authinfo hash that the user's username is mapped into.
This is useful for using a store which requires a specific unusual field name
for the username.  The username is additionally mapped onto the \fIid\fR key.
.SH METHODS
.IX Header "METHODS"
.ie n .SS "new ( $config, $app, $realm )"
.el .SS "new ( \f(CW$config\fP, \f(CW$app\fP, \f(CW$realm\fP )"
.IX Subsection "new ( $config, $app, $realm )"
Instantiate a new Catalyst::Authentication::Credential::Remote object using the
configuration hash provided in \f(CW$config\fR. In case of invalid value of any 
configuration parameter (e.g. invalid regular expression) throws an exception.
.ie n .SS "authenticate ( $realm, $authinfo )"
.el .SS "authenticate ( \f(CW$realm\fP, \f(CW$authinfo\fP )"
.IX Subsection "authenticate ( $realm, $authinfo )"
Takes the username form WEBUSER set by webserver, performs additional 
checks using optional allow_regexp/deny_regexp configuration params, optionaly 
takes substring from WEBUSER and the sets the resulting value as
a Catalyst username.
.SH COMPATIBILITY
.IX Header "COMPATIBILITY"
It is \fBstrongly recommended\fR to use this module with Catalyst 5.80005 and above
as previous versions have some bugs related to \f(CW$c\fR\->engine\->env and do not 
support \f(CW$c\fR\->req\->remote_user.
.PP
This module tries some workarounds when it detects an older version and should
work as well.
.SH "USING WITH A REVERSE PROXY"
.IX Header "USING WITH A REVERSE PROXY"
If you are using a reverse proxy, then the WEBUSER will not be
directly accessible by the Catalyst server.  To use remote
authentication, you will have to modify the web server to set a header
containing the WEBUSER.  You would then need to modify the PSGI
configuration to map the header back to the WEBUSER variable.
.PP
For example, in Apache you would add the configuration
.PP
.Vb 5
\&  RequestHeader unset X\-Forwarded\-User
\&  RewriteEngine On
\&  RewriteCond %{LA\-U:REMOTE_USER} (.+)
\&  RewriteRule . \- [E=RU:%1]
\&  RequestHeader set X\-Forwarded\-User %{RU}e
.Ve
.PP
You then need to create a Plack::Middleware module to map the
header back to the WEBUSER:
.PP
.Vb 1
\&  package Plack::Middleware::MyRemote;
\&
\&  use parent qw( Plack::Middleware );
\&
\&  use Plack::Util;
\&
\&  sub call {
\&      my ($self, $env) = @_;
\&
\&      my $user = $env\->{HTTP_X_FORWARDED_USER} // "";
\&
\&      $env\->{REMOTE_USER} = $user
\&        if ($user && ($user ne \*(Aq(null)\*(Aq));
\&
\&      my $res = $self\->app\->($env);
\&
\&      return $res;
\&  }
\&
\&  1;
.Ve
.PP
Finally, you need to modify \fImyapp.psgi\fR to use the custom middleware:
.PP
.Vb 2
\&  use strict;
\&  use warnings;
\&
\&  use MyApp;
\&
\&  use Plack::Builder;
\&
\&  my $app = Drain\->apply_default_middlewares(Drain\->psgi_app);
\&
\&  builder {
\&     enable "Plack::Middleware::MyRemote";
\&     $app;
\&  };
.Ve
