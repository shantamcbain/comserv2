.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Realm 3pm"
.TH Catalyst::Authentication::Realm 3pm 2024-10-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::Authentication::Realm \- Base class for realm objects.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
.SH CONFIGURATION
.IX Header "CONFIGURATION"
.IP class 4
.IX Item "class"
By default this class is used by
Catalyst::Plugin::Authentication for all
realms. The class parameter allows you to choose a different class to use for
this realm. Creating a new Realm class can allow for authentication methods
that fall outside the normal credential/store methodology.
.IP auto_create_user 4
.IX Item "auto_create_user"
Set this to true if you wish this realm to auto-create user accounts when the
user doesn't exist (most useful for remote authentication schemes).
.IP auto_update_user 4
.IX Item "auto_update_user"
Set this to true if you wish this realm to auto-update user accounts after
authentication (most useful for remote authentication schemes).
.IP use_session 4
.IX Item "use_session"
Sets session usage for this particular realm \- overriding the global use_sesion setting.
.SH METHODS
.IX Header "METHODS"
.ie n .SS "new( $realmname, $config, $app )"
.el .SS "new( \f(CW$realmname\fP, \f(CW$config\fP, \f(CW$app\fP )"
.IX Subsection "new( $realmname, $config, $app )"
Instantiantes this realm, plus the specified store and credential classes.
.SS "store( )"
.IX Subsection "store( )"
Returns an instance of the store object for this realm.
.SS "credential( )"
.IX Subsection "credential( )"
Returns an instance of the credential object for this realm.
.ie n .SS "find_user( $authinfo, $c )"
.el .SS "find_user( \f(CW$authinfo\fP, \f(CW$c\fP )"
.IX Subsection "find_user( $authinfo, $c )"
Retrieves the user given the authentication information provided.  This
is most often called from the credential.  The default realm class simply
delegates this call the store object.  If enabled, auto-creation and
auto-updating of users is also handled here.
.ie n .SS "authenticate( $c, $authinfo)"
.el .SS "authenticate( \f(CW$c\fP, \f(CW$authinfo\fP)"
.IX Subsection "authenticate( $c, $authinfo)"
Performs the authentication process for the current realm.  The default
realm class simply delegates this to the credential and sets
the authenticated user on success.  Returns the authenticated user object;
.SH "USER PERSISTENCE"
.IX Header "USER PERSISTENCE"
The Realm class allows complete control over the persistance of users
between requests.  By default the realm attempts to use the Catalyst
session system to accomplish this.  By overriding the methods below
in a custom Realm class, however, you can handle user persistance in
any way you see fit.
.ie n .SS "persist_user($c, $user)"
.el .SS "persist_user($c, \f(CW$user\fP)"
.IX Subsection "persist_user($c, $user)"
persist_user is the entry point for saving user information between requests
in most cases this will utilize the session.  By default this uses the
catalyst session system to store the user by calling for_session on the
active store.  The user object must be a subclass of
Catalyst::Authentication::User.  If you have updated the user object, you
must call persist_user again to ensure that the persisted user object reflects
your updates.
.SS remove_persisted_user($c)
.IX Subsection "remove_persisted_user($c)"
Removes any persisted user data.  By default, removes the user from the session.
.ie n .SS "user_is_restorable( $c )"
.el .SS "user_is_restorable( \f(CW$c\fP )"
.IX Subsection "user_is_restorable( $c )"
Returns whether there is a persisted user that may be restored.  Returns
a token used to restore the user.  With the default session persistance
it returns the raw frozen user information.
.SS "restore_user($c, [$frozen_user])"
.IX Subsection "restore_user($c, [$frozen_user])"
Restores the user from the given frozen_user parameter, or if not provided,
using the response from \f(CW$self\fR\->\fBuser_is_restorable()\fR;  Uses \f(CW$self\fR\->\fBfrom_session()\fR
to decode the frozen user.
.SS failed_user_restore($c)
.IX Subsection "failed_user_restore($c)"
If there is a session to restore, but the restore fails for any reason then this method
is called. This method supplied just removes the persisted user, but can be overridden
if required to have more complex logic (e.g. finding a the user by their 'old' username).
.ie n .SS "from_session($c, $frozenuser )"
.el .SS "from_session($c, \f(CW$frozenuser\fP )"
.IX Subsection "from_session($c, $frozenuser )"
Decodes the frozenuser information provided and returns an instantiated
user object.  By default, this call is delegated to \f(CW$store\fR\->\fBfrom_session()\fR.
.ie n .SS "save_user_in_session($c, $user)"
.el .SS "save_user_in_session($c, \f(CW$user\fP)"
.IX Subsection "save_user_in_session($c, $user)"
DEPRECATED.  Use persist_user instead.  (this simply calls persist_user)
