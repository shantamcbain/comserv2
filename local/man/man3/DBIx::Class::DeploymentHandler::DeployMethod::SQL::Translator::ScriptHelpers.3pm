.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers 3pm"
.TH DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers 3pm 2024-07-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers \- CodeRef Transforms for common use\-cases in DBICDH Migrations
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\& use DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers
\&   \*(Aqschema_from_schema_loader\*(Aq;
\&
\&   schema_from_schema_loader({ naming => \*(Aqv4\*(Aq }, sub {
\&      my ($schema, $version_set) = @_;
\&
\&      ...
\&   });
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This package is a set of coderef transforms for common use-cases in migrations.
The subroutines are simply helpers for creating coderefs that will work for
"PERL SCRIPTS" in DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator,
yet have some argument other than the current schema that you as a user might
prefer.
.SH "EXPORTED SUBROUTINES"
.IX Header "EXPORTED SUBROUTINES"
.SS dbh($coderef)
.IX Subsection "dbh($coderef)"
.Vb 2
\& dbh(sub {
\&   my ($dbh, $version_set) = @_;
\&
\&   ...
\& });
.Ve
.PP
For those times when you almost exclusively need access to "the bare metal".
Simply gives you the correct database handle and the expected version set.
.ie n .SS "schema_from_schema_loader($sl_opts, $coderef)"
.el .SS "schema_from_schema_loader($sl_opts, \f(CW$coderef\fP)"
.IX Subsection "schema_from_schema_loader($sl_opts, $coderef)"
.Vb 2
\& schema_from_schema_loader({ naming => \*(Aqv4\*(Aq }, sub {
\&   my ($schema, $version_set) = @_;
\&
\&   ...
\& });
.Ve
.PP
Any time you write a perl migration script that uses a DBIx::Class::Schema
you should probably use this.  Otherwise you'll run into problems if you remove
a column from your schema yet still populate to it in an older population
script.
.PP
Note that \f(CW$sl_opts\fR requires that you specify something for the \f(CW\*(C`naming\*(C'\fR
option.
.SH "CUSTOM SCRIPT HELPERS"
.IX Header "CUSTOM SCRIPT HELPERS"
If you find that in your scripts you need to always pass the same arguments to
your script helpers, you may want to define a custom set of script helpers.  I
am not sure that there is a better way than just using Perl and other modules
that are already installed when you install DBIx::Class::DeploymentHandler.
.PP
The following is a pattern that will get you started; if anyone has ideas on
how to make this even easier let me know.
.PP
.Vb 1
\& package MyApp::DBICDH::ScriptHelpers;
\&
\& use strict;
\& use warnings;
\&
\& use DBIx::Class::DeploymentHandler::DeployMethod::SQL::Translator::ScriptHelpers
\&    dbh => { \-as => \*(Aq_old_dbh\*(Aq },
\&    schema_from_schema_loader => { \-as => \*(Aq_old_sfsl\*(Aq };
\&
\& use Sub::Exporter::Progressive \-setup => {
\&    exports => [qw(dbh schema_from_schema_loader)],
\& };
\&
\& sub dbh {
\&    my $coderef = shift;
\&
\&    _old_dbh(sub {
\&       my ($dbh) = @_;
\&       $dbh\->do(q(SET search_path TO \*(Aqmyapp_db\*(Aq));
\&
\&       $coderef\->(@_);
\&    });
\& }
\&
\& sub schema_from_schema_loader {
\&    my ($config, $coderef) = @_;
\&
\&    $config\->{naming} ||= \*(Aqv7\*(Aq;
\&
\&    _old_sfsl(sub {
\&       my ($schema) = @_;
\&       $schema\->storage\->dbh\->do(q(SET search_path TO \*(Aqmyapp_db\*(Aq));
\&
\&       $coderef\->(@_);
\&    });
\&
\& }
.Ve
.PP
The above will default the naming to \f(CW\*(C`v7\*(C'\fR when using
\&\f(CW\*(C`schema_from_schema_loader\*(C'\fR.  And in both cases it will set the schema for
PostgreSQL. Of course if you do that you will not be able to switch to MySQL or
something else, so I recommended looking into my DBIx::Introspector to only
do that for the database in question.
.SH AUTHOR
.IX Header "AUTHOR"
Arthur Axel "fREW" Schmidt <frioux+cpan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
