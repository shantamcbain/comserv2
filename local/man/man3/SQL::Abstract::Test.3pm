.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Abstract::Test 3pm"
.TH SQL::Abstract::Test 3pm 2021-01-21 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Abstract::Test \- Helper function for testing SQL::Abstract
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 6
\&  use SQL::Abstract;
\&  use Test::More;
\&  use SQL::Abstract::Test import => [qw/
\&    is_same_sql_bind is_same_sql is_same_bind
\&    eq_sql_bind eq_sql eq_bind
\&  /];
\&
\&  my ($sql, @bind) = SQL::Abstract\->new\->select(%args);
\&
\&  is_same_sql_bind($given_sql,    \e@given_bind,
\&                   $expected_sql, \e@expected_bind, $test_msg);
\&
\&  is_same_sql($given_sql, $expected_sql, $test_msg);
\&  is_same_bind(\e@given_bind, \e@expected_bind, $test_msg);
\&
\&  my $is_same = eq_sql_bind($given_sql,    \e@given_bind,
\&                            $expected_sql, \e@expected_bind);
\&
\&  my $sql_same = eq_sql($given_sql, $expected_sql);
\&  my $bind_same = eq_bind(\e@given_bind, \e@expected_bind);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module is only intended for authors of tests on
SQL::Abstract and related modules;
it exports functions for comparing two SQL statements
and their bound values.
.PP
The SQL comparison is performed on \fIabstract syntax\fR,
ignoring differences in spaces or in levels of parentheses.
Therefore the tests will pass as long as the semantics
is preserved, even if the surface syntax has changed.
.PP
\&\fBDisclaimer\fR : the semantic equivalence handling is pretty limited.
A lot of effort goes into distinguishing significant from
non-significant parenthesis, including AND/OR operator associativity.
Currently this module does not support commutativity and more
intelligent transformations like De Morgan's laws
 <http://en.wikipedia.org/wiki/De_Morgan's_laws>, etc.
.PP
For a good overview of what this test framework is currently capable of refer
to \f(CW\*(C`t/10test.t\*(C'\fR
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.SS is_same_sql_bind
.IX Subsection "is_same_sql_bind"
.Vb 5
\&  is_same_sql_bind(
\&    $given_sql, \e@given_bind,
\&    $expected_sql, \e@expected_bind,
\&    $test_msg
\&  );
\&
\&  is_same_sql_bind(
\&    \e[$given_sql, @given_bind],
\&    \e[$expected_sql, @expected_bind],
\&    $test_msg
\&  );
\&
\&  is_same_sql_bind(
\&    $dbic_rs\->as_query
\&    $expected_sql, \e@expected_bind,
\&    $test_msg
\&  );
.Ve
.PP
Compares given and expected pairs of \f(CW\*(C`($sql, \e@bind)\*(C'\fR by unpacking \f(CW@_\fR
as shown in the examples above and passing the arguments to "eq_sql" and
"eq_bind". Calls "ok" in Test::Builder with the combined result, with
\&\f(CW$test_msg\fR as message.
If the test fails, a detailed diagnostic is printed.
.SS is_same_sql
.IX Subsection "is_same_sql"
.Vb 5
\&  is_same_sql(
\&    $given_sql,
\&    $expected_sql,
\&    $test_msg
\&  );
.Ve
.PP
Compares given and expected SQL statements via "eq_sql", and calls
"ok" in Test::Builder on the result, with \f(CW$test_msg\fR as message.
If the test fails, a detailed diagnostic is printed.
.SS is_same_bind
.IX Subsection "is_same_bind"
.Vb 5
\&  is_same_bind(
\&    \e@given_bind,
\&    \e@expected_bind,
\&    $test_msg
\&  );
.Ve
.PP
Compares given and expected bind values via "eq_bind", and calls
"ok" in Test::Builder on the result, with \f(CW$test_msg\fR as message.
If the test fails, a detailed diagnostic is printed.
.SS eq_sql_bind
.IX Subsection "eq_sql_bind"
.Vb 4
\&  my $is_same = eq_sql_bind(
\&    $given_sql, \e@given_bind,
\&    $expected_sql, \e@expected_bind,
\&  );
\&
\&  my $is_same = eq_sql_bind(
\&    \e[$given_sql, @given_bind],
\&    \e[$expected_sql, @expected_bind],
\&  );
\&
\&  my $is_same = eq_sql_bind(
\&    $dbic_rs\->as_query
\&    $expected_sql, \e@expected_bind,
\&  );
.Ve
.PP
Unpacks \f(CW@_\fR depending on the given arguments and calls "eq_sql" and
"eq_bind", returning their combined result.
.SS eq_sql
.IX Subsection "eq_sql"
.Vb 1
\&  my $is_same = eq_sql($given_sql, $expected_sql);
.Ve
.PP
Compares the abstract syntax of two SQL statements. Similar to "is_same_sql",
but it just returns a boolean value and does not print diagnostics or talk to
Test::Builder. If the result is false, the global variable "$sql_differ"
will contain the SQL portion where a difference was encountered; this is useful
for printing diagnostics.
.SS eq_bind
.IX Subsection "eq_bind"
.Vb 1
\&  my $is_same = eq_sql(\e@given_bind, \e@expected_bind);
.Ve
.PP
Compares two lists of bind values, taking into account the fact that some of
the values may be arrayrefs (see "bindtype" in SQL::Abstract). Similar to
"is_same_bind", but it just returns a boolean value and does not print
diagnostics or talk to Test::Builder.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS $case_sensitive
.el .SS \f(CW$case_sensitive\fP
.IX Subsection "$case_sensitive"
If true, SQL comparisons will be case-sensitive. Default is false;
.ie n .SS $parenthesis_significant
.el .SS \f(CW$parenthesis_significant\fP
.IX Subsection "$parenthesis_significant"
If true, SQL comparison will preserve and report difference in nested
parenthesis. Useful while testing \f(CW\*(C`IN (( x ))\*(C'\fR vs \f(CW\*(C`IN ( x )\*(C'\fR.
Defaults to false;
.ie n .SS $order_by_asc_significant
.el .SS \f(CW$order_by_asc_significant\fP
.IX Subsection "$order_by_asc_significant"
If true SQL comparison will consider \f(CW\*(C`ORDER BY foo ASC\*(C'\fR and
\&\f(CW\*(C`ORDER BY foo\*(C'\fR to be different. Default is false;
.ie n .SS $sql_differ
.el .SS \f(CW$sql_differ\fP
.IX Subsection "$sql_differ"
When "eq_sql" returns false, the global variable
\&\f(CW$sql_differ\fR contains the SQL portion
where a difference was encountered.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Abstract, Test::More, Test::Builder.
.SH AUTHORS
.IX Header "AUTHORS"
Laurent Dami <laurent.dami AT etat  geneve  ch>
.PP
Norbert Buchmuller <norbi@nix.hu>
.PP
Peter Rabbitson <ribasushi@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008 by Laurent Dami.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
