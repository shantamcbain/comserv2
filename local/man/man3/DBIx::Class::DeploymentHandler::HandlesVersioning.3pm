.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::DeploymentHandler::HandlesVersioning 3pm"
.TH DBIx::Class::DeploymentHandler::HandlesVersioning 3pm 2024-07-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::DeploymentHandler::HandlesVersioning \- Interface for version methods
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Typically a VersionHandler will take a \f(CW\*(C`to_version\*(C'\fR and yield an iterator of
version sets.
.PP
Typically a call to a VersionHandler's "next_version_set" with a \f(CW\*(C`db_version\*(C'\fR
of 1 and a \f(CW\*(C`to_version\*(C'\fR of 5 will iterate over something like the following:
.PP
.Vb 5
\& [1, 2]
\& [2, 3]
\& [3, 4]
\& [4, 5]
\& undef
.Ve
.PP
or maybe just
.PP
.Vb 2
\& [1, 5]
\& undef
.Ve
.PP
Really how the version sets are arranged is up to the
VersionHandler being used.
.PP
In some cases users will not want versions to have inherent "previous
versions," which is why the version set is an \f(CW\*(C`ArrayRef\*(C'\fR.  In those cases the
user should opt to returning merely the version that the database is being
upgraded to in each step.
.PP
One idea that has been suggested to me has been to have a form of dependency
management of the database "versions."  In this case the versions are actually
more like features that may or may not be applied.  For example, one might
start with version 1 and have a feature (version) \f(CW\*(C`users\*(C'\fR.
.PP
Each feature might require that the database be upgraded to another version
first.  If one were to implement a system like this, here is how the
VersionHandler's "next_version_set" might look.
.PP
.Vb 5
\& to_version = "users", db_version = 1
\& [3]
\& [5]
\& ["users"]
\& undef
.Ve
.PP
So what just happened there is that \f(CW\*(C`users\*(C'\fR depends on version 5, which depends
on version 3, which depends on version 1, which is already installed.  To be
clear, the reason we use single versions instead of version pairs is because
there is no inherent order for this type of database upgraded.
.SS Downgrades
.IX Subsection "Downgrades"
For the typical case downgrades should be easy for users to perform and
understand.  That means that with the first two examples given above we can use
the "previous_version_set" iterator to yield the following:
.PP
.Vb 6
\& db_version = 5, to_version=1
\& [5, 4]
\& [4, 3]
\& [3, 2]
\& [2, 1]
\& undef
.Ve
.PP
or maybe just
.PP
.Vb 2
\& [5, 1]
\& undef
.Ve
.PP
Note that we do not swap the version number order.  This allows us to remain
consistent in our version set abstraction, since a version set really just
describes a version change, and not necessarily a defined progression.
.SH "VERSION SET"
.IX Header "VERSION SET"
A version set could be defined as:
.PP
.Vb 2
\& subtype \*(AqVersion\*(Aq, as \*(AqStr\*(Aq;
\& subtype \*(AqVersionSet\*(Aq, as \*(AqArrayRef[Str]\*(Aq;
.Ve
.PP
A version set should uniquely identify a migration.
.SH "KNOWN IMPLEMENTATIONS"
.IX Header "KNOWN IMPLEMENTATIONS"
.IP \(bu 4
DBIx::Class::DeploymentHandler::VersionHandler::Monotonic
.IP \(bu 4
DBIx::Class::DeploymentHandler::VersionHandler::DatabaseToSchemaVersions
.IP \(bu 4
DBIx::Class::DeploymentHandler::VersionHandler::ExplicitVersions
.SH METHODS
.IX Header "METHODS"
.SS next_version_set
.IX Subsection "next_version_set"
.Vb 5
\& print \*(Aqversions to install: \*(Aq;
\& while (my $vs = $dh\->next_version_set) {
\&   print join q(, ), @{$vs}
\& }
\& print qq(\en);
.Ve
.PP
Return a version set describing each version that needs to be
installed to upgrade to \f(CW\*(C`$dh\->to_version\*(C'\fR.
.SS previous_version_set
.IX Subsection "previous_version_set"
.Vb 5
\& print \*(Aqversions to uninstall: \*(Aq;
\& while (my $vs = $dh\->previous_version_set) {
\&   print join q(, ), @{$vs}
\& }
\& print qq(\en);
.Ve
.PP
Return a version set describing each version that needs to be
"installed" to downgrade to \f(CW\*(C`$dh\->to_version\*(C'\fR.
.SH AUTHOR
.IX Header "AUTHOR"
Arthur Axel "fREW" Schmidt <frioux+cpan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
