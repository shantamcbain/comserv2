.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "HTTP::Parser::XS 3pm"
.TH HTTP::Parser::XS 3pm 2014-12-15 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
HTTP::Parser::XS \- a fast, primitive HTTP request parser
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&  use HTTP::Parser::XS qw(parse_http_request);
\&
\&  # for HTTP servers
\&  my $ret = parse_http_request(
\&      "GET / HTTP/1.0\er\enHost: ...\er\en\er\en",
\&      \e%env,
\&  );
\&  if ($ret == \-2) {
\&      # request is incomplete
\&      ...
\&  } elsif ($ret == \-1) {
\&      # request is broken
\&      ...
\&  } else {
\&      # $ret includes the size of the request, %env now contains a PSGI
\&      # request, if it is a POST / PUT request, read request content by
\&      # yourself
\&      ...
\&  }
\&
\&
\&  # for HTTP clients
\&  use HTTP::Parser::XS qw(parse_http_response HEADERS_AS_ARRAYREF);
\&  my %special_headers = (
\&    \*(Aqcontent\-length\*(Aq => undef,
\&  );
\&  my($ret, $minor_version, $status, $message, $headers)
\&    = parse_http_response($response, HEADERS_AS_ARRAYREF, \e%special_headers);
\&
\&  if($ret == \-1) }
\&    # response is incomplete
\&  }
\&  elsif($ret == \-2) {
\&    # response is broken
\&  }
\&  else {
\&    # $ret is the length of the headers, starting the content body
\&
\&    # the other values are the response messages. For example:
\&    # $status  = 200
\&    # $message = "OK"
\&    # $headers = [ \*(Aqcontent\-type\*(Aq => \*(Aqtext/html\*(Aq, ... ]
\&
\&    # and $special_headers{\*(Aqcontent\-length\*(Aq} will be filled in
\&  }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
HTTP::Parser::XS is a fast, primitive HTTP request/response parser.
.PP
The request parser can be used either for writing a synchronous HTTP server or a event-driven server.
.PP
The response parser can be used for writing HTTP clients.
.PP
Note that even if this distribution name ends \f(CW\*(C`::XS\*(C'\fR, \fBpure Perl\fR
implementation is supported, so you can use this module on compiler-less
environments.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.IP "parse_http_request($request_string, \e%env)" 4
.IX Item "parse_http_request($request_string, %env)"
Tries to parse given request string, and if successful, inserts variables into \f(CW%env\fR.  For the name of the variables inserted, please refer to the PSGI specification.  The return values are:
.RS 4
.IP >=0 8
.IX Item ">=0"
length of the request (request line and the request headers), in bytes
.IP \-1 8
.IX Item "-1"
given request is corrupt
.IP \-2 8
.IX Item "-2"
given request is incomplete
.RE
.RS 4
.Sp
Note that the semantics of PATH_INFO is somewhat different from Apache.  First, HTTP::Parser::XS does not validate the variable; it does not raise an error even if PATH_INFO does not start with "/".  Second, the variable is conformant to RFC 3875 (and PSGI / Plack) in the fact that "//" and ".." appearing in PATH_INFO are preserved whereas Apache transcodes them.
.RE
.ie n .IP "parse_http_response($response_string, $header_format, \e%special_headers)" 4
.el .IP "parse_http_response($response_string, \f(CW$header_format\fR, \e%special_headers)" 4
.IX Item "parse_http_response($response_string, $header_format, %special_headers)"
Tries to parse given response string. \fR\f(CI$header_format\fR\fI\fR must be
\&\f(CW\*(C`HEADERS_AS_ARRAYREF\*(C'\fR, \f(CW\*(C`HEADERS_AS_HASHREF\*(C'\fR, or \f(CW\*(C`HEADERS_NONE\*(C'\fR,
which are exportable constants.
.Sp
The optional \fR\f(CI%special_headers\fR\fI\fR is for headers you specifically require.
You can set any HTTP response header names, which must be lower-cased,
and their default values, and then the values are filled in by
\&\f(CWparse_http_response()\fR.
For example, if you want the \f(CW\*(C`Cointent\-Length\*(C'\fR field, set its name with
default values like \f(CW\*(C`%h = (\*(Aqcontent\-length\*(Aq => undef)\*(C'\fR and pass it as
\&\fI\fR\f(CI%special_headers\fR\fI\fR. After parsing, \f(CW$h{\*(Aqcontent\-length\*(Aq}\fR is set
if the response has the \f(CW\*(C`Content\-Length\*(C'\fR field, otherwise it's not touched.
.Sp
The return values are:
.RS 4
.ie n .IP $ret 8
.el .IP \f(CW$ret\fR 8
.IX Item "$ret"
The parsering status, which is the same as \f(CWparse_http_response()\fR. i.e.
the length of the response headers in bytes, \f(CW\-1\fR for incomplete headers,
or \f(CW\-2\fR for errors.
.Sp
If the given response string is broken or imcomplete, \f(CWparse_http_response()\fR
returns only this value.
.ie n .IP $minor_version 8
.el .IP \f(CW$minor_version\fR 8
.IX Item "$minor_version"
The minor version of the given response.
i.e. \f(CW1\fR for HTTP/1.1, \f(CW0\fR for HTTP/1.0.
.ie n .IP $status 8
.el .IP \f(CW$status\fR 8
.IX Item "$status"
The HTTP status of the given response. e.g. \f(CW200\fR for success.
.ie n .IP $message 8
.el .IP \f(CW$message\fR 8
.IX Item "$message"
The HTTP status message. e.g. \f(CW\*(C`OK\*(C'\fR for success.
.ie n .IP $headers 8
.el .IP \f(CW$headers\fR 8
.IX Item "$headers"
The HTTP headers for the given response. It is an ARRAY reference
if \fR\f(CI$header_format\fR\fI\fR is \f(CW\*(C`HEADERS_AS_ARRAYREF\*(C'\fR, a HASH reference on
\&\f(CW\*(C`HEADERS_AS_HASHREF\*(C'\fR, an \f(CW\*(C`undef\*(C'\fR on \f(CW\*(C`HEADERS_NONE\*(C'\fR.
.Sp
The names of the headers are normalized to lower-cased.
.RE
.RS 4
.RE
.SH LIMITATIONS
.IX Header "LIMITATIONS"
Both \f(CWparse_http_request()\fR and \f(CWparse_http_response()\fR in XS
implementation have some size limitations.
.SS "The number of headers"
.IX Subsection "The number of headers"
The number of headers is limited to \f(CW128\fR. If it exceeds, both parsing
routines report parsing errors, i.e. return \f(CW\-1\fR for \f(CW$ret\fR.
.SS "The size of header names"
.IX Subsection "The size of header names"
The size of header names is limited to \f(CW1024\fR, but the parsers do not the
same action.
.PP
\&\f(CWparse_http_request()\fR returns \f(CW\-1\fR if too-long header names exist.
.PP
\&\f(CWparse_http_request()\fR simply ignores too-long header names.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2009\- Kazuho Oku
.SH AUTHORS
.IX Header "AUTHORS"
.IP \(bu 4
Kazuho Oku <https://metacpan.org/author/KAZUHO>
.IP \(bu 4
gfx <https://metacpan.org/author/GFUJI>
.IP \(bu 4
mala <https://metacpan.org/author/MALA>
.IP \(bu 4
tokuhirom <https://metacpan.org/author/TOKUHIROM>
.SH "THANKS TO"
.IX Header "THANKS TO"
.IP \(bu 4
nothingmuch <https://metacpan.org/author/NUFFIN>
.IP \(bu 4
charsbar <https://metacpan.org/author/CHARSBAR>
.IP \(bu 4
DOLMEN <https://metacpan.org/author/DOLMEN>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP \(bu 4
<http://github.com/kazuho/picohttpparser>
.IP \(bu 4
HTTP::Parser
.IP \(bu 4
HTTP::HeaderParser::XS
.IP \(bu 4
Plack
.IP \(bu 4
PSGI
.SH LICENSE
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
