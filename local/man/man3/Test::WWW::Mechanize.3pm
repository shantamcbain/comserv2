.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Mechanize 3pm"
.TH Mechanize 3pm 2022-12-05 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test::WWW::Mechanize \- Testing\-specific WWW::Mechanize subclass
.SH VERSION
.IX Header "VERSION"
Version 1.60
.SH SYNOPSIS
.IX Header "SYNOPSIS"
Test::WWW::Mechanize is a subclass of WWW::Mechanize that incorporates
features for web application testing.  For example:
.PP
.Vb 2
\&    use Test::More tests => 5;
\&    use Test::WWW::Mechanize;
\&
\&    my $mech = Test::WWW::Mechanize\->new;
\&    $mech\->get_ok( $page );
\&    $mech\->base_is( \*(Aqhttp://petdance.com/\*(Aq, \*(AqProper <BASE HREF>\*(Aq );
\&    $mech\->title_is( \*(AqInvoice Status\*(Aq, "Make sure we\*(Aqre on the invoice page" );
\&    $mech\->text_contains( \*(AqAndy Lester\*(Aq, \*(AqMy name somewhere\*(Aq );
\&    $mech\->content_like( qr/(cpan|perl)\e.org/, \*(AqLink to perl.org or CPAN\*(Aq );
.Ve
.PP
This is equivalent to:
.PP
.Vb 2
\&    use Test::More tests => 5;
\&    use WWW::Mechanize;
\&
\&    my $mech = WWW::Mechanize\->new;
\&    $mech\->get( $page );
\&    ok( $mech\->success );
\&    is( $mech\->base, \*(Aqhttp://petdance.com\*(Aq, \*(AqProper <BASE HREF>\*(Aq );
\&    is( $mech\->title, \*(AqInvoice Status\*(Aq, "Make sure we\*(Aqre on the invoice page" );
\&    ok( index( $mech\->content( format => \*(Aqtext\*(Aq ), \*(AqAndy Lester\*(Aq ) >= 0, \*(AqMy name somewhere\*(Aq );
\&    like( $mech\->content, qr/(cpan|perl)\e.org/, \*(AqLink to perl.org or CPAN\*(Aq );
.Ve
.PP
but has nicer diagnostics if they fail.
.PP
Default descriptions will be supplied for most methods if you omit them. e.g.
.PP
.Vb 6
\&    my $mech = Test::WWW::Mechanize\->new;
\&    $mech\->get_ok( \*(Aqhttp://petdance.com/\*(Aq );
\&    $mech\->base_is( \*(Aqhttp://petdance.com/\*(Aq );
\&    $mech\->title_is( \*(AqInvoice Status\*(Aq );
\&    $mech\->content_contains( \*(AqAndy Lester\*(Aq );
\&    $mech\->content_like( qr/(cpan|perl)\e.org/ );
.Ve
.PP
results in
.PP
.Vb 5
\&    ok \- Got \*(Aqhttp://petdance.com/\*(Aq ok
\&    ok \- Base is \*(Aqhttp://petdance.com/\*(Aq
\&    ok \- Title is \*(AqInvoice Status\*(Aq
\&    ok \- Text contains \*(AqAndy Lester\*(Aq
\&    ok \- Content is like \*(Aq(?\-xism:(cpan|perl)\e.org)\*(Aq
.Ve
.SH CONSTRUCTOR
.IX Header "CONSTRUCTOR"
.ie n .SS "new( %args )"
.el .SS "new( \f(CW%args\fP )"
.IX Subsection "new( %args )"
Behaves like, and calls, WWW::Mechanize's \f(CW\*(C`new\*(C'\fR method.  Any parms
passed in get passed to WWW::Mechanize's constructor.
.PP
You can pass in \f(CW\*(C`autolint => 1\*(C'\fR to make Test::WWW::Mechanize
automatically run HTML::Lint after any of the following methods are
called. You can also pass in an HTML::Lint object like this:
.PP
.Vb 2
\&    my $lint = HTML::Lint\->new( only_types => HTML::Lint::Error::STRUCTURE );
\&    my $mech = Test::WWW::Mechanize\->new( autolint => $lint );
.Ve
.PP
The same is also possible with \f(CW\*(C`autotidy => 1\*(C'\fR to use HTML::Tidy5.
.IP \(bu 4
\&\fBget_ok()\fR
.IP \(bu 4
\&\fBpost_ok()\fR
.IP \(bu 4
\&\fBsubmit_form_ok()\fR
.IP \(bu 4
\&\fBfollow_link_ok()\fR
.IP \(bu 4
\&\fBclick_ok()\fR
.PP
This means you no longer have to do the following:
.PP
.Vb 3
\&    my $mech = Test::WWW::Mechanize\->new();
\&    $mech\->get_ok( $url, \*(AqFetch the intro page\*(Aq );
\&    $mech\->html_lint_ok( \*(AqIntro page looks OK\*(Aq );
.Ve
.PP
and can simply do
.PP
.Vb 2
\&    my $mech = Test::WWW::Mechanize\->new( autolint => 1 );
\&    $mech\->get_ok( $url, \*(AqFetch the intro page\*(Aq );
.Ve
.PP
The \f(CW\*(C`$mech\->get_ok()\*(C'\fR only counts as one test in the test count.  Both the
main IO operation and the linting must pass for the entire test to pass.
.PP
You can control autolint and autotidy on the fly with the \f(CW\*(C`autolint\*(C'\fR
and \f(CW\*(C`autotidy\*(C'\fR methods.
.SH "METHODS: HTTP VERBS"
.IX Header "METHODS: HTTP VERBS"
.ie n .SS "$mech\->get_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->get_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->get_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fBget()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW*_ok()\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of "GET \f(CW$url\fR" is used if none if provided.
.ie n .SS "$mech\->head_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->head_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->head_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fBhead()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW*_ok()\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of "HEAD \f(CW$url\fR" is used if none if provided.
.ie n .SS "$mech\->post_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->post_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->post_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fBpost()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW*_ok()\fR functions, it returns true if the test passed,
or false if not.
.PP
\&\fBNOTE\fR Due to compatibility reasons it is not possible to pass
additional LWP_options beyond form data via this method (such as
Content or Content-Type).  It is recommend that you use WWW::Mechanize's
\&\fBpost()\fR directly for instances where more granular control of the post
is needed.
.PP
A default description of "POST to \f(CW$url\fR" is used if none if provided.
.ie n .SS "$mech\->put_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->put_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->put_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fBput()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW*_ok()\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of "PUT to \f(CW$url\fR" is used if none if provided.
.ie n .SS "$mech\->delete_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->delete_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->delete_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fBdelete()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW*_ok()\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of "DELETE to \f(CW$url\fR" is used if none if provided.
.ie n .SS "$mech\->submit_form_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->submit_form_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->submit_form_ok( %parms [, $desc] )"
Makes a \f(CWsubmit_form()\fR call and executes tests on the results.
The form must be found, and then submitted successfully.  Otherwise,
this test fails.
.PP
\&\fR\f(CI%parms\fR\fI\fR is a hashref containing the parms to pass to \f(CWsubmit_form()\fR.
Note that the parms to \f(CWsubmit_form()\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 7
\&    $mech\->submit_form_ok( {
\&            form_number => 3,
\&            fields      => {
\&                answer => 42
\&            },
\&        }, \*(Aqnow we just need the question\*(Aq
\&    );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fBsubmit_form()\fR
is not available.
.ie n .SS "$mech\->follow_link_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->follow_link_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->follow_link_ok( %parms [, $desc] )"
Makes a \f(CWfollow_link()\fR call and executes tests on the results.
The link must be found, and then followed successfully.  Otherwise,
this test fails.
.PP
\&\fR\f(CI%parms\fR\fI\fR is a hashref containing the parms to pass to \f(CWfollow_link()\fR.
Note that the parms to \f(CWfollow_link()\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $mech\->follow_link_ok( {n=>3}, \*(Aqlooking for 3rd link\*(Aq );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns a true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fBfollow_link()\fR
is not available.
.ie n .SS "$mech\->click_ok( $button[, $desc] )"
.el .SS "\f(CW$mech\fP\->click_ok( \f(CW$button\fP[, \f(CW$desc\fP] )"
.IX Subsection "$mech->click_ok( $button[, $desc] )"
.ie n .SS "$mech\->click_ok( \e@button\-and\-coordinates [, $desc ] )"
.el .SS "\f(CW$mech\fP\->click_ok( \e@button\-and\-coordinates [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->click_ok( @button-and-coordinates [, $desc ] )"
Clicks the button named by \f(CW$button\fR.  An optional \f(CW$desc\fR can be
given for the test.
.PP
.Vb 1
\&    $mech\->click_ok( \*(Aqcontinue\*(Aq, \*(AqClicking the "Continue" button\*(Aq );
.Ve
.PP
Alternatively the first argument can be an arrayref with three elements:
The name of the button and the X and Y coordinates of the button.
.PP
.Vb 1
\&    $mech\->click_ok( [ \*(Aqcontinue\*(Aq, 12, 47 ], \*(AqClicking the "Continue" button\*(Aq );
.Ve
.SH "METHODS: HEADER CHECKING"
.IX Header "METHODS: HEADER CHECKING"
.ie n .SS "$mech\->header_exists_ok( $header [, $desc ] )"
.el .SS "\f(CW$mech\fP\->header_exists_ok( \f(CW$header\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->header_exists_ok( $header [, $desc ] )"
Assures that a given response header exists. The actual value of the
response header is not checked, only that the header exists.
.ie n .SS "$mech\->lacks_header_ok( $header [, $desc ] )"
.el .SS "\f(CW$mech\fP\->lacks_header_ok( \f(CW$header\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->lacks_header_ok( $header [, $desc ] )"
Assures that a given response header does NOT exist.
.ie n .SS "$mech\->header_is( $header, $value [, $desc ] )"
.el .SS "\f(CW$mech\fP\->header_is( \f(CW$header\fP, \f(CW$value\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->header_is( $header, $value [, $desc ] )"
Assures that a given response header exists and has the given value.
.ie n .SS "$mech\->header_like( $header, $value [, $desc ] )"
.el .SS "\f(CW$mech\fP\->header_like( \f(CW$header\fP, \f(CW$value\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->header_like( $header, $value [, $desc ] )"
Assures that a given response header exists and has the given value.
.SH "METHODS: CONTENT CHECKING"
.IX Header "METHODS: CONTENT CHECKING"
.ie n .SS "$mech\->html_lint_ok( [$desc] )"
.el .SS "\f(CW$mech\fP\->html_lint_ok( [$desc] )"
.IX Subsection "$mech->html_lint_ok( [$desc] )"
Checks the validity of the HTML on the current page using the HTML::Lint
module.  If the page is not HTML, then it fails.  The URI is automatically
appended to the \fR\f(CI$desc\fR\fI\fR.
.PP
Note that HTML::Lint must be installed for this to work.  Otherwise,
it will blow up.
.ie n .SS "$mech\->html_tidy_ok( [$desc] )"
.el .SS "\f(CW$mech\fP\->html_tidy_ok( [$desc] )"
.IX Subsection "$mech->html_tidy_ok( [$desc] )"
Checks the validity of the HTML on the current page using the HTML::Tidy
module.  If the page is not HTML, then it fails.  The URI is automatically
appended to the \fR\f(CI$desc\fR\fI\fR.
.PP
Note that HTML::tidy must be installed for this to work.  Otherwise,
it will blow up.
.ie n .SS $mech\->\fBcontent_for_tidy()\fP
.el .SS \f(CW$mech\fP\->\fBcontent_for_tidy()\fP
.IX Subsection "$mech->content_for_tidy()"
This method is called by \f(CWhtml_tidy_ok()\fR to get the content that should
be validated by HTML::Tidy5. By default, this is just \f(CWcontent()\fR,
but subclasses can override it to modify the content before validation.
.PP
This method should not change any state in the Mech object.  Specifically,
it should not actually modify any of the actual content.
.ie n .SS "$mech\->title_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_is( $str [, $desc ] )"
Tells if the title of the page is the given string.
.PP
.Vb 1
\&    $mech\->title_is( \*(AqInvoice Summary\*(Aq );
.Ve
.ie n .SS "$mech\->title_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_like( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_like( qr/Invoices for (.+)/ );
.Ve
.ie n .SS "$mech\->title_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_unlike( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_unlike( qr/Invoices for (.+)/ );
.Ve
.ie n .SS "$mech\->base_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_is( $str [, $desc ] )"
Tells if the base of the page is the given string.
.PP
.Vb 1
\&    $mech\->base_is( \*(Aqhttp://example.com/\*(Aq );
.Ve
.ie n .SS "$mech\->base_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_like( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_like( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->base_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_unlike( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_unlike( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->content_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_is( $str [, $desc ] )"
Tells if the content of the page matches the given string
.ie n .SS "$mech\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_contains( $str [, $desc ] )"
Tells if the content of the page contains \fR\f(CI$str\fR\fI\fR.
.ie n .SS "$mech\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_lacks( $str [, $desc ] )"
Tells if the content of the page lacks \fR\f(CI$str\fR\fI\fR.
.ie n .SS "$mech\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_like( $regex [, $desc ] )"
Tells if the content of the page matches \fR\f(CI$regex\fR\fI\fR.
.ie n .SS "$mech\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_unlike( $regex [, $desc ] )"
Tells if the content of the page does NOT match \fR\f(CI$regex\fR\fI\fR.
.ie n .SS "$mech\->text_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_contains( $str [, $desc ] )"
Tells if the text form of the page's content contains \fR\f(CI$str\fR\fI\fR.
.PP
When your page contains HTML which is difficult, unimportant, or
unlikely to match over time as designers alter markup, use
\&\f(CW\*(C`text_contains\*(C'\fR instead of \f(CW\*(C`content_contains\*(C'\fR.
.PP
.Vb 3
\& # <b>Hi, <i><a href="some/path">User</a></i>!</b>
\& $mech\->content_contains(\*(AqHi, User\*(Aq); # Fails.
\& $mech\->text_contains(\*(AqHi, User\*(Aq); # Passes.
.Ve
.PP
Text is determined by calling \f(CW\*(C`$mech\->text()\*(C'\fR.
See "content" in WWW::Mechanize.
.ie n .SS "$mech\->text_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_lacks( $str [, $desc ] )"
Tells if the text of the page lacks \fR\f(CI$str\fR\fI\fR.
.ie n .SS "$mech\->text_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_like( $regex [, $desc ] )"
Tells if the text form of the page's content matches \fR\f(CI$regex\fR\fI\fR.
.ie n .SS "$mech\->text_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->text_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->text_unlike( $regex [, $desc ] )"
Tells if the text format of the page's content does NOT match \fR\f(CI$regex\fR\fI\fR.
.ie n .SS "$mech\->has_tag( $tag, $text [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag( \f(CW$tag\fP, \f(CW$text\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag( $tag, $text [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->has_tag_like( $tag, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag_like( \f(CW$tag\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag_like( $tag, $regex [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->page_links_ok( [ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_ok( [ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_ok( [ $desc ] )"
Follow all links on the current page and test for HTTP status 200
.PP
.Vb 1
\&    $mech\->page_links_ok(\*(AqCheck all links\*(Aq);
.Ve
.ie n .SS "$mech\->page_links_content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_like( $regex [, $desc ] )"
Follow all links on the current page and test their contents for \fR\f(CI$regex\fR\fI\fR.
.PP
.Vb 2
\&    $mech\->page_links_content_like( qr/foo/,
\&      \*(AqCheck all links contain "foo"\*(Aq );
.Ve
.ie n .SS "$mech\->page_links_content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_unlike( $regex [, $desc ] )"
Follow all links on the current page and test their contents do not
contain the specified regex.
.PP
.Vb 2
\&    $mech\->page_links_content_unlike(qr/Restricted/,
\&      \*(AqCheck all links do not contain Restricted\*(Aq);
.Ve
.ie n .SS "$mech\->links_ok( $links [, $desc ] )"
.el .SS "\f(CW$mech\fP\->links_ok( \f(CW$links\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->links_ok( $links [, $desc ] )"
Follow specified links on the current page and test for HTTP status
200.  The links may be specified as a reference to an array containing
WWW::Mechanize::Link objects, an array of URLs, or a scalar URL
name.
.PP
.Vb 2
\&    my @links = $mech\->find_all_links( url_regex => qr/cnn\e.com$/ );
\&    $mech\->links_ok( \e@links, \*(AqCheck all links for cnn.com\*(Aq );
\&
\&    my @links = qw( index.html search.html about.html );
\&    $mech\->links_ok( \e@links, \*(AqCheck main links\*(Aq );
\&
\&    $mech\->links_ok( \*(Aqindex.html\*(Aq, \*(AqCheck link to index\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_is( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_is( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_is( $links, $status [, $desc ] )"
Follow specified links on the current page and test for HTTP status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_is( \e@links, 403,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_isnt( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_isnt( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_isnt( $links, $status [, $desc ] )"
Follow specified links on the current page and test for HTTP status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_isnt( \e@links, 404,
\&      \*(AqCheck all links are not 404\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_like( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_like( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_like( $links, $regex [, $desc ] )"
Follow specified links on the current page and test the resulting
content of each against \fR\f(CI$regex\fR\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an
array of URLs, or a scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&        \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_unlike( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_unlike( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_unlike( $links, $regex [, $desc ] )"
Follow specified links on the current page and test that the resulting
content of each does not match \fR\f(CI$regex\fR\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an array
of URLs, or a scalar URL name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_unlike( \e@links, qr/Restricted/,
\&      \*(AqNo restricted links\*(Aq );
.Ve
.SH "METHODS: SCRAPING"
.IX Header "METHODS: SCRAPING"
.ie n .SS "$mech\->scrape_text_by_attr( $attr, $attr_value [, $html ] )"
.el .SS "\f(CW$mech\fP\->scrape_text_by_attr( \f(CW$attr\fP, \f(CW$attr_value\fP [, \f(CW$html\fP ] )"
.IX Subsection "$mech->scrape_text_by_attr( $attr, $attr_value [, $html ] )"
.ie n .SS "$mech\->scrape_text_by_attr( $attr, $attr_regex [, $html ] )"
.el .SS "\f(CW$mech\fP\->scrape_text_by_attr( \f(CW$attr\fP, \f(CW$attr_regex\fP [, \f(CW$html\fP ] )"
.IX Subsection "$mech->scrape_text_by_attr( $attr, $attr_regex [, $html ] )"
Returns a list of strings, each string the text surrounded by an
element with attribute \fR\f(CI$attr\fR\fI\fR of value \fI\fR\f(CI$value\fR\fI\fR.  You can also pass in
a regular expression.  If nothing is found the return is an empty list.
In scalar context the return is the first string found.
.PP
If passed, \fR\f(CI$html\fR\fI\fR is scraped instead of the current page's content.
.ie n .SS "$mech\->scrape_text_by_id( $id [, $html ] )"
.el .SS "\f(CW$mech\fP\->scrape_text_by_id( \f(CW$id\fP [, \f(CW$html\fP ] )"
.IX Subsection "$mech->scrape_text_by_id( $id [, $html ] )"
Finds all elements with the given ID attribute and pulls out the text that that element encloses.
.PP
In list context, returns a list of all strings found. In scalar context, returns the first one found.
.PP
If \f(CW$html\fR is not provided then the current content is used.
.ie n .SS "$mech\->scraped_id_is( $id, $expected [, $msg] )"
.el .SS "\f(CW$mech\fP\->scraped_id_is( \f(CW$id\fP, \f(CW$expected\fP [, \f(CW$msg\fP] )"
.IX Subsection "$mech->scraped_id_is( $id, $expected [, $msg] )"
Scrapes the current page for given ID and tests that it matches the expected value.
.ie n .SS "$mech\->scraped_id_like( $id, $expected_regex [, $msg] )"
.el .SS "\f(CW$mech\fP\->scraped_id_like( \f(CW$id\fP, \f(CW$expected_regex\fP [, \f(CW$msg\fP] )"
.IX Subsection "$mech->scraped_id_like( $id, $expected_regex [, $msg] )"
Scrapes the current page for given id and tests that it matches the expected regex.
.ie n .SS "$mech\->id_exists( $id )"
.el .SS "\f(CW$mech\fP\->id_exists( \f(CW$id\fP )"
.IX Subsection "$mech->id_exists( $id )"
Returns TRUE/FALSE if the given ID exists in the given HTML, or if none
is provided, then the current page.
.PP
The Mech object caches the IDs so that it doesn't bother reparsing every
time it's asked about an ID.
.ie n .SS "$agent\->id_exists_ok( $id [, $msg] )"
.el .SS "\f(CW$agent\fP\->id_exists_ok( \f(CW$id\fP [, \f(CW$msg\fP] )"
.IX Subsection "$agent->id_exists_ok( $id [, $msg] )"
Verifies there is an HTML element with ID \f(CW$id\fR in the page.
.ie n .SS "$agent\->ids_exist_ok( \e@ids [, $msg] )"
.el .SS "\f(CW$agent\fP\->ids_exist_ok( \e@ids [, \f(CW$msg\fP] )"
.IX Subsection "$agent->ids_exist_ok( @ids [, $msg] )"
Verifies an HTML element exists with each ID in \f(CW\*(C`\e@ids\*(C'\fR.
.ie n .SS "$agent\->lacks_id_ok( $id [, $msg] )"
.el .SS "\f(CW$agent\fP\->lacks_id_ok( \f(CW$id\fP [, \f(CW$msg\fP] )"
.IX Subsection "$agent->lacks_id_ok( $id [, $msg] )"
Verifies there is NOT an HTML element with ID \f(CW$id\fR in the page.
.ie n .SS "$agent\->lacks_ids_ok( \e@ids [, $msg] )"
.el .SS "\f(CW$agent\fP\->lacks_ids_ok( \e@ids [, \f(CW$msg\fP] )"
.IX Subsection "$agent->lacks_ids_ok( @ids [, $msg] )"
Verifies there are no HTML elements with any of the ids given in \f(CW\*(C`\e@ids\*(C'\fR.
.ie n .SS "$mech\->button_exists( $button )"
.el .SS "\f(CW$mech\fP\->button_exists( \f(CW$button\fP )"
.IX Subsection "$mech->button_exists( $button )"
Returns a boolean saying whether a submit button with the name \f(CW$button\fR exists. Does not
do a test. For that you want \f(CW\*(C`button_exists_ok\*(C'\fR or \f(CW\*(C`lacks_button_ok\*(C'\fR.
.ie n .SS "$mech\->button_exists_ok( $button [, $msg] )"
.el .SS "\f(CW$mech\fP\->button_exists_ok( \f(CW$button\fP [, \f(CW$msg\fP] )"
.IX Subsection "$mech->button_exists_ok( $button [, $msg] )"
Asserts that the button exists on the page.
.ie n .SS "$mech\->lacks_button_ok( $button [, $msg] )"
.el .SS "\f(CW$mech\fP\->lacks_button_ok( \f(CW$button\fP [, \f(CW$msg\fP] )"
.IX Subsection "$mech->lacks_button_ok( $button [, $msg] )"
Asserts that no button named \f(CW$button\fR exists on the page.
.SH "METHODS: MISCELLANEOUS"
.IX Header "METHODS: MISCELLANEOUS"
.ie n .SS "$mech\->autolint( [$status] )"
.el .SS "\f(CW$mech\fP\->autolint( [$status] )"
.IX Subsection "$mech->autolint( [$status] )"
Without an argument, this method returns a true or false value indicating
whether autolint is active.
.PP
When passed an argument, autolint is turned on or off depending on whether
the argument is true or false, and the previous autolint status is returned.
As with the autolint option of \f(CW\*(C`new\*(C'\fR, \f(CW$status\fR can be an
HTML::Lint object.
.PP
If autolint is currently using an HTML::Lint object you provided,
the return is that object, so you can change and exactly restore
autolint status:
.PP
.Vb 3
\&    my $old_status = $mech\->autolint( 0 );
\&    ... operations that should not be linted ...
\&    $mech\->autolint( $old_status );
.Ve
.ie n .SS "$mech\->autotidy( [$status] )"
.el .SS "\f(CW$mech\fP\->autotidy( [$status] )"
.IX Subsection "$mech->autotidy( [$status] )"
Without an argument, this method returns a true or false value indicating
whether autotidy is active.
.PP
When passed an argument, autotidy is turned on or off depending on whether
the argument is true or false, and the previous autotidy status is returned.
As with the autotidy option of \f(CW\*(C`new\*(C'\fR, \f(CW$status\fR can be an
HTML::Tidy5 object.
.PP
If autotidy is currently using an HTML::Tidy5 object you provided,
the return is that object, so you can change and exactly restore
autotidy status:
.PP
.Vb 3
\&    my $old_status = $mech\->autotidy( 0 );
\&    ... operations that should not be tidied ...
\&    $mech\->autotidy( $old_status );
.Ve
.ie n .SS "$mech\->grep_inputs( \e%properties )"
.el .SS "\f(CW$mech\fP\->grep_inputs( \e%properties )"
.IX Subsection "$mech->grep_inputs( %properties )"
Returns a list of all the input controls in the
current form whose properties match all of the regexes in \f(CW$properties\fR.
The controls returned are all descended from HTML::Form::Input.
.PP
If \f(CW$properties\fR is undef or empty then all inputs will be
returned.
.PP
If there is no current page, there is no form on the current
page, or there are no submit controls in the current form
then the return will be an empty list.
.PP
.Vb 7
\&    # Get all text controls whose names begin with "customer".
\&    my @customer_text_inputs =
\&        $mech\->grep_inputs( {
\&            type => qr/^(text|textarea)$/,
\&            name => qr/^customer/
\&        }
\&    );
.Ve
.ie n .SS "$mech\->grep_submits( \e%properties )"
.el .SS "\f(CW$mech\fP\->grep_submits( \e%properties )"
.IX Subsection "$mech->grep_submits( %properties )"
\&\fBgrep_submits()\fR does the same thing as \fBgrep_inputs()\fR except that
it only returns controls that are submit controls, ignoring
other types of input controls like text and checkboxes.
.ie n .SS "$mech\->stuff_inputs( [\e%options] )"
.el .SS "\f(CW$mech\fP\->stuff_inputs( [\e%options] )"
.IX Subsection "$mech->stuff_inputs( [%options] )"
Finds all free-text input fields (text, textarea, and password) in the
current form and fills them to their maximum length in hopes of finding
application code that can't handle it.  Fields with no maximum length
and all textarea fields are set to 66000 bytes, which will often be
enough to overflow the data's eventual receptacle.
.PP
There is no return value.
.PP
If there is no current form then nothing is done.
.PP
The hashref \f(CW$options\fR can contain the following keys:
.IP \(bu 4
ignore
.Sp
hash value is arrayref of field names to not touch, e.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        ignore => [qw( specialfield1 specialfield2 )],
\&    } );
.Ve
.IP \(bu 4
fill
.Sp
hash value is default string to use when stuffing fields.  Copies
of the string are repeated up to the max length of each field.  E.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        fill => \*(Aq@\*(Aq  # stuff all fields with something easy to recognize
\&    } );
.Ve
.IP \(bu 4
specs
.Sp
hash value is arrayref of hashrefs with which you can pass detailed
instructions about how to stuff a given field.  E.g.:
.Sp
.Vb 8
\&    $mech\->stuff_inputs( {
\&        specs=>{
\&            # Some fields are datatype\-constrained.  It\*(Aqs most common to
\&            # want the field stuffed with valid data.
\&            widget_quantity => { fill=>\*(Aq9\*(Aq },
\&            notes => { maxlength=>2000 },
\&        }
\&    } );
.Ve
.Sp
The specs allowed are \fIfill\fR (use this fill for the field rather than
the default) and \fImaxlength\fR (use this as the field's maxlength instead
of any maxlength specified in the HTML).
.ie n .SS $mech\->\fBfollowable_links()\fP
.el .SS \f(CW$mech\fP\->\fBfollowable_links()\fP
.IX Subsection "$mech->followable_links()"
Returns a list of links that Mech can follow.  This is only http and
https links.
.ie n .SS "$mech\->lacks_uncapped_inputs( [$comment] )"
.el .SS "\f(CW$mech\fP\->lacks_uncapped_inputs( [$comment] )"
.IX Subsection "$mech->lacks_uncapped_inputs( [$comment] )"
Executes a test to make sure that the current form content has no
text input fields that lack the \f(CW\*(C`maxlength\*(C'\fR attribute, and that each
\&\f(CW\*(C`maxlength\*(C'\fR value is a positive integer.  The test fails if the current
form has such a field, and succeeds otherwise.
.PP
Checks that all text input fields in the current form specify a maximum
input length.  Fields for which the concept of input length is irrelevant,
and controls that HTML does not allow to be capped (e.g. textarea)
are ignored.
.PP
The return is true if the test succeeded, false otherwise.
.ie n .SS "$mech\->check_all_images_ok( [%criterium ], [$comment] )"
.el .SS "\f(CW$mech\fP\->check_all_images_ok( [%criterium ], [$comment] )"
.IX Subsection "$mech->check_all_images_ok( [%criterium ], [$comment] )"
Executes a test to make sure all images in the page can be downloaded. It
does this by running \f(CW\*(C`HEAD\*(C'\fR requests on them. The current page content stays the same.
.PP
The test fails if any image cannot be found, but reports all of the ones that were not found.
.PP
For a definition of \fIall images\fR, see \f(CW\*(C`images\*(C'\fRin WWW::Mechanize.
.PP
The optional \f(CW%criterium\fR argument can be passed in before the \f(CW$comment\fR and will be used to define
which images should be considered. This is useful to filter out specific paths.
.PP
.Vb 6
\&    $mech\->check_all_images_ok( url_regex => qr{^/}, \*(AqAll absolute images should exist\*(Aq);
\&    $mech\->check_all_images_ok( url_regex => qr{\e.(?:gif|jpg)$}, \*(AqAll gif and jpg images should exist\*(Aq);
\&    $mech\->check_all_images_ok(
\&        url_regex => qr{^((?!\eQhttps://googleads.g.doubleclick.net/\eE).)*$},
\&        \*(AqAll images should exist, but Ignore the ones from Doubleclick\*(Aq
\&    );
.Ve
.PP
For a full list of possible arguments see \f(CW\*(C`find_all_images\*(C'\fRin WWW::Mechanize.
.PP
The return is true if the test succeeded, false otherwise.
.SH TODO
.IX Header "TODO"
Other ideas for features are at https://github.com/petdance/test\-www\-mechanize
.SH AUTHOR
.IX Header "AUTHOR"
Andy Lester, \f(CW\*(C`<andy at petdance.com>\*(C'\fR
.SH BUGS
.IX Header "BUGS"
Please report any bugs or feature requests to
<https://github.com/petdance/test\-www\-mechanize>.
.SH SUPPORT
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Test::WWW::Mechanize
.Ve
.PP
You can also look for information at:
.IP \(bu 4
Bug tracker
.Sp
<https://github.com/petdance/test\-www\-mechanize>
.IP \(bu 4
CPAN Ratings
.Sp
<http://cpanratings.perl.org/d/Test\-WWW\-Mechanize>
.IP \(bu 4
Search CPAN
.Sp
<http://search.cpan.org/dist/Test\-WWW\-Mechanize>
.SH ACKNOWLEDGEMENTS
.IX Header "ACKNOWLEDGEMENTS"
Thanks to
Julien Fiegehenn,
\&\f(CW@marderh\fR,
Eric A. Zarko,
\&\f(CW@moznion\fR,
Robert Stone,
\&\f(CW@tynovsky\fR,
Jerry Gay,
Jonathan "Duke" Leto,
Philip G. Potter,
Niko Tyni,
Greg Sheard,
Michael Schwern,
Mark Blackman,
Mike O'Regan,
Shawn Sorichetti,
Chris Dolan,
Matt Trout,
MATSUNO Tokuhiro,
and Pete Krawczyk for patches.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2004\-2022 Andy Lester.
.PP
This library is free software; you can redistribute it and/or modify it
under the terms of the Artistic License version 2.0.
