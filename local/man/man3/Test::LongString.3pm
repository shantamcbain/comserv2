.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::LongString 3pm"
.TH Test::LongString 3pm 2014-11-06 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Test::LongString \- tests strings for equality, with more helpful failures
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 3
\&    use Test::More tests => 1;
\&    use Test::LongString;
\&    like_string( $html, qr/(perl|cpan)\e.org/ );
\&
\&    #     Failed test (html\-test.t at line 12)
\&    #          got: "<!DOCTYPE HTML PUBLIC "\-//W3C//DTD HTML 4.01 Trans"...
\&    #       length: 58930
\&    #     doesn\*(Aqt match \*(Aq(?\-xism:(perl|cpan)\e.org)\*(Aq
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module provides some drop-in replacements for the string
comparison functions of Test::More, but which are more suitable
when you test against long strings.  If you've ever had to search
for text in a multi-line string like an HTML document, or find
specific items in binary data, this is the module for you.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.ie n .SS "is_string( $string, $expected [, $label ] )"
.el .SS "is_string( \f(CW$string\fP, \f(CW$expected\fP [, \f(CW$label\fP ] )"
.IX Subsection "is_string( $string, $expected [, $label ] )"
\&\f(CWis_string()\fR is equivalent to \f(CWTest::More::is()\fR, but with more
helpful diagnostics in case of failure.
.IP \(bu 4
It doesn't print the entire strings in the failure message.
.IP \(bu 4
It reports the lengths of the strings that have been compared.
.IP \(bu 4
It reports the length of the common prefix of the strings.
.IP \(bu 4
It reports the line and column the strings started to differ on.
.IP \(bu 4
In the diagnostics, non-ASCII characters are escaped as \f(CW\*(C`\ex{xx}\*(C'\fR.
.PP
For example:
.PP
.Vb 1
\&    is_string( $soliloquy, $juliet );
\&
\&    #     Failed test (soliloquy.t at line 15)
\&    #          got: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #       length: 1490
\&    #     expected: "O Romeo, Romeo,\ex{0a}wherefore art thou Romeo?\ex{0a}Deny thy"...
\&    #       length: 154
\&    #     strings begin to differ at char 1 (line 1 column 1)
.Ve
.ie n .SS "is_string_nows( $string, $expected [, $label ] )"
.el .SS "is_string_nows( \f(CW$string\fP, \f(CW$expected\fP [, \f(CW$label\fP ] )"
.IX Subsection "is_string_nows( $string, $expected [, $label ] )"
Like \f(CWis_string()\fR, but removes whitespace (in the \f(CW\*(C`\es\*(C'\fR sense) from the
arguments before comparing them.
.ie n .SS "like_string( $string, qr/regex/ [, $label ] )"
.el .SS "like_string( \f(CW$string\fP, qr/regex/ [, \f(CW$label\fP ] )"
.IX Subsection "like_string( $string, qr/regex/ [, $label ] )"
.ie n .SS "unlike_string( $string, qr/regex/ [, $label ] )"
.el .SS "unlike_string( \f(CW$string\fP, qr/regex/ [, \f(CW$label\fP ] )"
.IX Subsection "unlike_string( $string, qr/regex/ [, $label ] )"
\&\f(CWlike_string()\fR and \f(CWunlike_string()\fR are replacements for
\&\f(CWTest::More:like()\fR and \f(CWunlike()\fR that only print the beginning
of the received string in the output.  Unfortunately, they can't
print out the position where the regex failed to match.
.PP
.Vb 1
\&    like_string( $soliloquy, qr/Romeo|Juliet|Mercutio|Tybalt/ );
\&
\&    #     Failed test (soliloquy.t at line 15)
\&    #          got: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #       length: 1490
\&    #     doesn\*(Aqt match \*(Aq(?\-xism:Romeo|Juliet|Mercutio|Tybalt)\*(Aq
.Ve
.ie n .SS "contains_string( $string, $substring [, $label ] )"
.el .SS "contains_string( \f(CW$string\fP, \f(CW$substring\fP [, \f(CW$label\fP ] )"
.IX Subsection "contains_string( $string, $substring [, $label ] )"
\&\f(CWcontains_string()\fR searches for \fR\f(CI$substring\fR\fI\fR in \fI\fR\f(CI$string\fR\fI\fR.  It's
the same as \f(CWlike_string()\fR, except that it's not a regular
expression search.
.PP
.Vb 1
\&    contains_string( $soliloquy, "Romeo" );
\&
\&    #     Failed test (soliloquy.t at line 10)
\&    #         searched: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #   and can\*(Aqt find: "Romeo"
.Ve
.PP
As of version 0.12, \f(CWcontains_string()\fR will also report the Longest Common
SubString (LCSS) found in \fR\f(CI$string\fR\fI\fR and, if the LCSS is short enough, the
surroundings will also be shown under \fILCSS Context\fR. This should help debug
tests for really long strings like HTML output, so you'll get something like:
.PP
.Vb 6
\&   contains_string( $html, \*(Aq<div id="MainContent">\*(Aq );
\&   #   Failed test at t/foo.t line 10.
\&   #     searched: "<!DOCTYPE html PUBLIC "\-//W3C//DTD XHTML 1.0 Stric"...
\&   #   can\*(Aqt find: "<div id="MainContent">"
\&   #         LCSS: "ainContent""
\&   # LCSS context: "dolor sit amet</span>\ex{0a}<div id="mainContent" class="
.Ve
.PP
You can turn off LCSS reporting by setting \f(CW$Test::LongString::LCSS\fR to 0,
or by specifying an argument to \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Test::LongString lcss => 0;
.Ve
.ie n .SS "lacks_string( $string, $substring [, $label ] )"
.el .SS "lacks_string( \f(CW$string\fP, \f(CW$substring\fP [, \f(CW$label\fP ] )"
.IX Subsection "lacks_string( $string, $substring [, $label ] )"
\&\f(CWlacks_string()\fR makes sure that \fR\f(CI$substring\fR\fI\fR does NOT exist in
\&\fI\fR\f(CI$string\fR\fI\fR.  It's the same as \f(CWlike_string()\fR, except that it's not a
regular expression search.
.PP
.Vb 1
\&    lacks_string( $soliloquy, "slings" );
\&
\&    #     Failed test (soliloquy.t at line 10)
\&    #         searched: "To be, or not to be: that is the question:\ex{0a}Whether"...
\&    #        and found: "slings"
\&    #      at position: 147 (line 3 column 4)
.Ve
.SH "CONTROLLING OUTPUT"
.IX Header "CONTROLLING OUTPUT"
By default, only the first 50 characters of the compared strings
are shown in the failure message.  This value is in
\&\f(CW$Test::LongString::Max\fR, and can be set at run-time.
.PP
You can also set it by specifying an argument to \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Test::LongString max => 100;
.Ve
.PP
When the compared strings begin to differ after a large prefix,
Test::LongString will not print them from the beginning, but will start at the
middle, more precisely at \f(CW$Test::LongString::Context\fR characters before the
first difference. By default this value is 10 characters. If you want
Test::LongString to always print the beginning of compared strings no matter
where they differ, undefine \f(CW$Test::LongString::Context\fR.
.PP
When computing line numbers this module uses "\en" to count line endings. This
may not be appropriate for strings on your platform, and can be overridden
by setting the \f(CW$Test::LongString::EOL\fR variable to a suitable regular
expression (either a reference to a regular expression or a string that
can be interpolated into a regular expression.)
.PP
You can also set it by specifying an argument to \f(CW\*(C`use\*(C'\fR:
.PP
.Vb 1
\&    use Test::LongString eol => "\ex{0a}\ex{0c}";
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
Written by Rafael Garcia-Suarez. Thanks to Mark Fowler (and to Joss Whedon) for
the inspirational Acme::Test::Buffy. Thanks to Andy Lester for lots of patches.
.PP
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.PP
A git repository for this module is available at
.PP
.Vb 1
\&    git://github.com/rgs/Test\-LongString.git
.Ve
.PP
and the project page at
.PP
.Vb 1
\&    http://github.com/rgs/Test\-LongString
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Builder, Test::Builder::Tester, Test::More.
