.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Diff 3pm"
.TH SQL::Translator::Diff 3pm 2024-10-08 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Translator::Diff \- determine differences between two schemas
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Takes two input SQL::Translator::Schemas (or SQL files) and produces ALTER
statements to make them the same
.SH SNYOPSIS
.IX Header "SNYOPSIS"
Simplest usage:
.PP
.Vb 2
\& use SQL::Translator::Diff;
\& my $sql = SQL::Translator::Diff::schema_diff($source_schema, \*(AqMySQL\*(Aq, $target_schema, \*(AqMySQL\*(Aq, $options_hash)
.Ve
.PP
OO usage:
.PP
.Vb 7
\& use SQL::Translator::Diff;
\& my $diff = SQL::Translator::Diff\->new({
\&   output_db     => \*(AqMySQL\*(Aq,
\&   source_schema => $source_schema,
\&   target_schema => $target_schema,
\&   %$options_hash,
\& })\->compute_differences\->produce_diff_sql;
.Ve
.SH OPTIONS
.IX Header "OPTIONS"
.IP \fBignore_index_names\fR 4
.IX Item "ignore_index_names"
Match indexes based on types and fields, ignoring name.
.IP \fBignore_constraint_names\fR 4
.IX Item "ignore_constraint_names"
Match constrains based on types, fields and tables, ignoring name.
.IP \fBoutput_db\fR 4
.IX Item "output_db"
Which producer to use to produce the output.
.IP \fBcase_insensitive\fR 4
.IX Item "case_insensitive"
Ignore case of table, field, index and constraint names when comparing
.IP \fBno_batch_alters\fR 4
.IX Item "no_batch_alters"
Produce each alter as a distinct \f(CW\*(C`ALTER TABLE\*(C'\fR statement even if the producer
supports the ability to do all alters for a table as one statement.
.IP \fBignore_missing_methods\fR 4
.IX Item "ignore_missing_methods"
If the diff would need a method that is missing from the producer, just emit a
comment showing the method is missing, rather than dieing with an error
.IP \fBsqlt_args\fR 4
.IX Item "sqlt_args"
Hash of extra arguments passed to "new" in SQL::Translator and the below
"PRODUCER FUNCTIONS".
.SH "PRODUCER FUNCTIONS"
.IX Header "PRODUCER FUNCTIONS"
The following producer functions should be implemented for completeness. If
any of them are needed for a given diff, but not found, an error will be
thrown.
.IP \(bu 4
\&\f(CW\*(C`alter_create_constraint($con, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`alter_drop_constraint($con, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`alter_create_index($idx, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`alter_drop_index($idx, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`add_field($fld, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`alter_field($old_fld, $new_fld, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`rename_field($old_fld, $new_fld, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`drop_field($fld, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`alter_table($table, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`drop_table($table, $args)\*(C'\fR
.IP \(bu 4
\&\f(CW\*(C`rename_table($old_table, $new_table, $args)\*(C'\fR (optional)
.IP \(bu 4
\&\f(CW\*(C`batch_alter_table($table, $hash, $args)\*(C'\fR (optional)
.Sp
If the producer supports \f(CW\*(C`batch_alter_table\*(C'\fR, it will be called with the
table to alter and a hash, the keys of which will be the method names listed
above; values will be arrays of fields or constraints to operate on. In the
case of the field functions that take two arguments this will appear as an
array reference.
.Sp
I.e. the hash might look something like the following:
.Sp
.Vb 5
\& {
\&   alter_create_constraint => [ $constraint1, $constraint2 ],
\&   add_field   => [ $field ],
\&   alter_field => [ [$old_field, $new_field] ]
\& }
.Ve
.IP \(bu 4
\&\f(CWpreprocess_schema($schema)\fR (optional)
.Sp
\&\f(CW\*(C`preprocess_schema\*(C'\fR is called by the Diff code to allow the producer to
normalize any data it needs to first. For example, the MySQL producer uses
this method to ensure that FK constraint names are unique.
.Sp
Basicaly any changes that need to be made to produce the SQL file for the
schema should be done here, so that a diff between a parsed SQL file and (say)
a parsed DBIx::Class::Schema object will be sane.
.Sp
(As an aside, DBIx::Class, for instance, uses the presence of a
\&\f(CW\*(C`preprocess_schema\*(C'\fR function on the producer to know that it can diff between
the previous SQL file and its own internal representation. Without this method
on th producer it will diff the two SQL files which is slower, but known to
work better on old-style producers.)
.SH AUTHOR
.IX Header "AUTHOR"
Original Author(s) unknown.
.PP
Refactor/re\-write and more comprehensive tests by Ash Berlin \f(CW\*(C`ash@cpan.org\*(C'\fR.
.PP
Redevelopment sponsored by Takkle Inc.
