.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Migration::Tutorial::AddMySQL 3pm"
.TH DBIx::Class::Migration::Tutorial::AddMySQL 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Migration::Tutorial::AddMySQL \- Add MySQL migration
.SH GOAL
.IX Header "GOAL"
So far in the tutorial we've been building migrations for SQLite.  This is a
good database for initial prototyping  and local development, but at some
point you'll need a more production oriented database.  By the end of this
tutorial you should have the basics of adding support for MySQL to your 
migrations.  We'll add MySQL migrations for version 3.
.SH "Add Version 3 Migrations for Mysql"
.IX Header "Add Version 3 Migrations for Mysql"
Since we build out migrations from the current Schema, you can only prepare
files for version 3 (at this point in the tutorial you should be at version
3).
.PP
Let's check our status
.PP
.Vb 3
\&    $ dbic\-migration \-Ilib status
\&    Schema is 3
\&    Deployed database is 3
.Ve
.PP
If you've been following along with the tutorial, you should see something like
the above.  Now, lets prepare migration files for MySQL:
.PP
.Vb 1
\&    $ dbic\-migration \-Ilib prepare \-\-database MySQL \-\-force_overwrite
\&
\&    Overwriting existing DDL\-YML file \- .../share/migrations/_source/deploy/3/001\-auto.yml
\&    Overwriting existing DDL file \- .../share/migrations/MySQL/deploy/3/001\-auto.sql
\&    Overwriting existing DDL\-YML file \- ../share/migrations/_source/deploy/3/001\-auto\-_\|_VERSION.yml
\&    Overwriting existing DDL file \- .../share/migrations/MySQL/deploy/3/001\-auto\-_\|_VERSION.sql
\&
\&    Your Database version must be lower than than your schema version
\&      in order to prepare upgrades / downgrades
\&    Copying Fixture Confs from .../share/fixtures/2/conf to .../share/fixtures/3/conf
.Ve
.PP
You need to \f(CW\*(C`force_overwrite\*(C'\fR since DBIx::Class::DeploymentHandler needs to
update some system managed files (nothing you've customized).  Additionally,
don't worry about the message, "Copying Fixture Confs from..." since we won't
ever overwrite your customized fixtures.
.PP
You'll also notice that we can't build version 2 to 3 upgrades for MySQL, since
we don't have a version 2 of the database for MySQL.  We'll skip working on 
upgrade files for MySQL since they won't essentially be at all different from
the work you've don't already of SQLite.  If you needed to rebuild all the 
versions, you actually can install down to Version 1 and build each step for
MySQL (an exercise I'll leave to your practice session!)
.PP
Let's see what's been added to \f(CW\*(C`share\*(C'\fR:
.PP
.Vb 7
\&    /share
\&      /migrations
\&      /MySQL
\&        /deploy
\&          /3
\&            001\-auto\-_VERSION.sql
\&            001\-auto.sql
.Ve
.PP
So this should start to look familiar to you.  Basically we just have a full
DDL to deploy our MySQL database.
.SH "How to install the version 3 MySQL"
.IX Header "How to install the version 3 MySQL"
So far you've only done \f(CW\*(C`install\*(C'\fR and \f(CW\*(C`upgrade\*(C'\fR to the default SQlite database
(under \f(CW\*(C`share\*(C'\fR).  If you want to run those commands against MySQL, obviously 
you'll need a running MySQL instance.  We can build a MySQL sandbox for you in
the \f(CW\*(C`target_dir\*(C'\fR, similarly to how we did for Sqlite.  To do this you need to
set the \f(CW\*(C`sandbox_class\*(C'\fR flag.  Also, you should add Test::mysqld to your
\&\f(CW\*(C`dist.ini\*(C'\fR file, and get that installed (you'll need to install MySQL on your
development computer, but it doesn't need to be running, just 'findable' in
your \f(CW$PATH\fR:
.PP
\&\f(CW\*(C`dist.ini\*(C'\fR
.PP
.Vb 6
\&    name    = DBIx\-Class\-Migration
\&    author  = John Napiorkowski <jjnapiork@cpan.org>
\&    license = Perl_5
\&    copyright_holder = John Napiorkowski
\&    copyright_year   = 2012
\&    abstract = Tutorial Application for DBIx\-Class\-Migration
\&
\&    version = 0.001
\&
\&    [@Basic]
\&    [Prereqs]
\&    DBIx::Class = 0
\&    DBIx::Class::Migration = 0
\&    DBD::mysql = 0
\&    Test::mysqld = 0
\&
\&
\&    [Prereqs / TestRequires]
\&    Test::Most = 0
\&    Test::DBIx::Class = 0
.Ve
.PP
and install:
.PP
.Vb 1
\&     dzil listdeps | cpanm
.Ve
.PP
If you have any trouble, you'll need to resolve that before moving on with the
tutorial.  In my experience, DBD::mysql installs easily if you make sure
\&\f(CW$PATH\fR can find the Mysql \f(CW\*(C`bin\*(C'\fR area (\f(CW\*(C`mysql_config\*(C'\fR, etc).
.PP
Assuming you get MySQL properly installed, lets build a sandbox:
.PP
.Vb 3
\&    $dbic\-migration \-Ilib \-\-sb MySQLSandbox status
\&    Schema is 3
\&    Database is not currently installed
.Ve
.PP
Just like with the \f(CW\*(C`schema_class\*(C'\fR flag, you can set an \f(CW%ENV\fR variable to set
your sandbox type for the shell:
.PP
.Vb 2
\&    ## example
\&    export DBIC_MIGRATION_SANDBOX_CLASS=MySQLSandbox
.Ve
.PP
We won't do this, since we'd like to continue controlling if we are using the
default sqlite sandbox or our new mysql sandbox.
.PP
Once you run that command you'll see a new directory in your \f(CW\*(C`target_dir\*(C'\fR,
which in this tutorial is under \f(CW\*(C`share\*(C'\fR:
.PP
.Vb 5
\&    /share
\&        /fixtures
\&        /migrations
\&        /musicbase\-schema
\&        musicbase\-schema.db
.Ve
.PP
that new \f(CW\*(C`share/musicbase\-schema\*(C'\fR directory contains the actual mysql sandbox
files.  You should probably set your repository to ignore this directory, since
it is unlikely you want those shared with other developers.
.PP
BTW, if you peek inside \f(CW\*(C`share/musicbase\-schema/bin\*(C'\fR you'll spot a couple of
helper scripts:
.PP
.Vb 4
\&    /bin
\&      start
\&      stop
\&      use
.Ve
.PP
\&\f(CW\*(C`start\*(C'\fR and \f(CW\*(C`stop\*(C'\fR starts and stops the sandbox (by default we stop the sandbox
when your migration command exits).  You'll use this if you want to \f(CW\*(C`use\*(C'\fR the 
sandbox (opens a mysql shell) or if you want to let you application use the sandbox
(for example later on if you are using Catalyst you'd want to start the sandbox
so that you can expose to to your web application).
.PP
You'd install the database and fixtures like so:
.PP
.Vb 2
\&    dbic\-migration \-Ilib \-\-sb MySQLSandbox install
\&    dbic\-migration \-Ilib \-\-sb MySQLSandbox populate
.Ve
.PP
That would give you:
.PP
.Vb 2
\&    Reading configurations from ../share/fixtures/3/conf
\&    Restored set all_tables to database
.Ve
.PP
Now you database is ready to use!
.PP
.Vb 3
\&    $ dbic\-migration \-Ilib \-\-sb MySQLSandbox status
\&    Schema is 3
\&    Database is 3
.Ve
.SH SUMMARY
.IX Header "SUMMARY"
Like the section on Testing, this one was pretty short.  At this point you should
have a good idea of the effort it would require to use your migrations against
databases other than the default SQlite.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Proceed to DBIx::Class::Migration::Tutorial::Catalyst
.SH AUTHOR
.IX Header "AUTHOR"
See DBIx::Class::Migration for author information
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
See DBIx::Class::Migration for copyright and license information
