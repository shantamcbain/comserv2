.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Migration::Script 3pm"
.TH DBIx::Class::Migration::Script 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Migration::Script \- Tools to manage database Migrations
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 4
\&    dbic\-migration status \e
\&      \-\-lib="lib" \e
\&      \-\-schema_class=\*(AqMyApp::Schema\*(Aq \e
\&      \-\-dsn=\*(AqDBI:SQLite:myapp.db\*(Aq
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is a class which provides an interface mapping between the commandline
script dbic-migration and the back end code that does the heavy lifting,
DBIx::Class::Migration.  This class has very little of it's own
functionality, since it basically acts as processing glue between that
commandline application and the code which does all the work.
.PP
You should look at DBIx::Class::Migration and the tutorial over at
DBIx::Class::Migration::Tutorial to get started.  This is basically
API level docs and a command summary which is likely to be useful as a
reference when you are familiar with the system.
.SH ATTRIBUTES
.IX Header "ATTRIBUTES"
This class defines the following attributes.
.SS migration
.IX Subsection "migration"
This contains an instance of DBIx::Class::Migration which is constructed
from various attributes described futher in these docs.
.PP
This is basically a delegate for all the commands you perform with this
interface.
.SS includes
.IX Subsection "includes"
Accepts ArrayRef. Not required.
.PP
Similar to the commandline switch \f(CW\*(C`I\*(C'\fR for the \f(CW\*(C`perl\*(C'\fR interpreter.  It adds
to \f(CW@INC\fR for when we want to search for modules to load.  This is primarily
useful for specifying a path to find a "schema_class".
.PP
We make no attempt to check the validity of any paths specified.  Buyer beware.
.SS schema_class
.IX Subsection "schema_class"
Accepts Str.  Required.
.PP
This is the schema we use as the basic for creating, managing and running your
deployments.  This should be the full package namespace defining your subclass
of DBIx::Class::Schema.  For example \f(CW\*(C`MyApp::Schema\*(C'\fR.
.PP
Uses MooX::Attribute::ENV to let you populate values from \f(CW%ENV\fR.  Uses key
DBIC_MIGRATION_SCHEMA_CLASS
.PP
If the "schema_class" cannot be loaded, a hard exception will be thrown.
.SS target_dir
.IX Subsection "target_dir"
Accepts Str.  Required.
.PP
This is the directory we store our migration and fixture files.  Inside this
directory we will create a \f(CW\*(C`fixtures\*(C'\fR and \f(CW\*(C`migrations\*(C'\fR sub-directory.
.PP
Although you can specify the directory, if you leave it undefined, we will use
File::ShareDir::ProjectDistDir to locate the \f(CW\*(C`share\*(C'\fR directory for your
project and place the files there.  This is the recommended approach, and is
considered a community practice in regards to where to store your distribution
non code files.  Please see File::ShareDir::ProjectDistDir as well as
File::ShareDir for more information.
.PP
Uses MooX::Attribute::ENV to let you populate values from \f(CW%ENV\fR.  Uses key
DBIC_MIGRATION_TARGET_DIR
.SS sandbox_dir
.IX Subsection "sandbox_dir"
Accepts Str.  Optional
.PP
Used if you wish to build the sandbox (if you are building one) in a location that
is not the 'target_dir'.  For example you might do this to make it easier to not
accidentally check the sandbox into the repository or if you are reusing it across
several projects.
.SS username
.IX Subsection "username"
Accepts Str.  Not Required
.PP
This should be the username for the database we connect to for deploying
ddl, ddl changes and fixtures.
.PP
Uses MooX::Attribute::ENV to let you populate values from \f(CW%ENV\fR.  Uses key
DBIC_MIGRATION_USERNAME
.SS password
.IX Subsection "password"
Accepts Str.  Not Required
.PP
This should be the password for the database we connect to for deploying
ddl, ddl changes and fixtures.
.PP
Uses MooX::Attribute::ENV to let you populate values from \f(CW%ENV\fR.  Uses key
DBIC_MIGRATION_PASSWORD
.SS dsn
.IX Subsection "dsn"
Accepts Str.  Not Required
.PP
This is the DSN for the database you are going to be targeting for deploying
or altering ddl, and installing or generating fixtures.
.PP
This should be a DSN suitable for "connect" in DBIx::Class::Schema, something
in the form of \f(CW\*(C`DBI:SQLite:myapp\-schema.db\*(C'\fR.
.PP
Please take care where you point this (like production :) )
.PP
If you don't provide a value, we will automatically create a SQLite based
database connection with the following DSN:
.PP
.Vb 1
\&    DBD:SQLite:[path to target_dir]/[db_file_name].db
.Ve
.PP
Where c<[path to target_dir]> is "target_dir" and [db_file_name] is a converted
version of "schema_class".  For example if you set schema_class to:
.PP
.Vb 1
\&    MyApp::Schema
.Ve
.PP
Then [db_file_name] would be \f(CW\*(C`myapp\-schema\*(C'\fR.
.PP
Please remember that you can generate deployment files for database types
other than the one you've defined in "dsn", however since different databases
enforce constraints differently it would not be impossible to generate fixtures
that can be loaded by one database but not another.  Therefore I recommend
always generated fixtures from a database that is consistent across enviroments.
.PP
Uses MooX::Attribute::ENV to let you populate values from \f(CW%ENV\fR.  Uses key
DBIC_MIGRATION_DSN
.SS force_overwrite
.IX Subsection "force_overwrite"
Accepts Bool.  Not Required.  Defaults to False.
.PP
Used when building "migration" to en / disable  the DBIx::Class::DeploymentHandler
option \f(CW\*(C`force_overwrite\*(C'\fR.  This is used when generating DDL and related
files for a given version of your "_schema" to decide if it is ok to overwrite
deployment files.  You might need this if you deploy a version of the database
during development and then need to make more changes or fixes for that version.
.SS to_version
.IX Subsection "to_version"
Accepts Int.  Not Required.
.PP
Used to establish a target version when running an install.  You can use this
to force install a version of the database other then your current "_schema"
version.  You might want this when you need to force install a lower version as
part of your development process for changing the database.
.PP
If you leave this undefined, no default value is built, however
DBIx::Class::DeploymentHandler will assume you want whatever is the value of
your \f(CW$schema\fR\->version.
.SS databases
.IX Subsection "databases"
Accepts ArrayRef.  Not Required.
.PP
Used when building "migration" to define the target databases we are building
migration files for.  You can name any of the databases currently supported by
SQL::Translator.  If you leave this undefined we will derive a value based on the value
of "dsn".  For example, if your "dsn" is "DBI:SQLite:test.db", we will set
the value of "databases" to \f(CW\*(C`[\*(AqSQLite\*(Aq]\*(C'\fR.
.SS sql_translator_args
.IX Subsection "sql_translator_args"
Accepts HashRef.  Not Required.
.PP
Used when building "migration" to set the DBIx::Class::DeploymentHandler
option \f(CW\*(C`sql_translator_args\*(C'\fR. This can be used to specify options for
SQL::Translator, for example:
.PP
.Vb 1
\&    producer_args => { postgres_version => \*(Aq9.1\*(Aq }
.Ve
.PP
to define the database version for SQL producer. Defaults to setting
\&\f(CW\*(C`quote_identifiers\*(C'\fR to a true value, which despite being documented as
the default, is not the case in practice.
.SS fixture_sets
.IX Subsection "fixture_sets"
Accepts ArrayRef.  Not Required. Defaults to ['all_tables'].
.PP
This defines a list of fixture sets that we use for dumping or populating
fixtures.  Defaults to the \f(CW\*(C`[\*(Aqall_tables\*(Aq]\*(C'\fR set, which is the one set we build
automatically for each version of the database we prepare deployments for.
.SS sandbox_class
.IX Subsection "sandbox_class"
Accepts String.  Not required.  Defaults to 'SqliteSandbox'
.PP
If you don't have a database already running, we will automatically create a
database 'sandbox' in your "target_dir" that is suitable for development and
rapid prototyping.  This is intended for developers and intended to make life
more simple, particularly for beginners who might not have all the knowledged
needed to setup a database for development purposes.
.PP
By default this sandbox is a file based DBD::Sqlite database, which is an
easy option since changes are good this is already installed on your development
computer (and if not it is trivial to install).
.PP
You can change this to either 'PostgresqlSandbox' or 'MySQLSandbox', which will
create a sandbox using either DBIx::Class::Migration::MySQLSandbox or 
DBIx::Class::Migration::PostgresqlSandbox (which in term require the separate
installation of either Test::mysqld or Test::Postgresql58).  If you are
using one of those open source databases in production, its probably a good
idea to use them in development as well, since there are enough small
differences between them that could make your code break if you used sqlite for
development and postgresql in production.  However this requires a bit more
setup effort, so when you are starting off just sticking to the default sqlite
is probably the easiest thing to do.
.PP
You should review the documenation at DBIx::Class::Migration::MySQLSandbox or 
DBIx::Class::Migration::PostgresqlSandbox because those delegates also build
some helper scripts, intended to help you use a sandbox.
.PP
Uses MooX::Attribute::ENV to let you populate values from \f(CW%ENV\fR.  Uses key
DBIC_MIGRATION_SANDBOX_CLASS
.PP
If you need to create your own custom database sandboxes, please see:
DBIx::Class::Migration::Sandbox which is the role your sandbox factory needs
to complete.  You can signify your custom sandbox by using the full package name
with a '+' prepended.  For example:
.PP
.Vb 1
\&    sandbox_class => \*(Aq+MyApp::Schema::CustomSandbox\*(Aq
.Ve
.PP
You should probably look at the existing sandbox code for thoughts on what a
good sandbox would do.
.SS migration_class
.IX Subsection "migration_class"
Accepts String.  Not Required (Defaults: DBIx::Class::Migration)
.PP
Should point to the class that does what DBIx::Class::Migration does.  This
is exposed here for those who need to subclass DBIx::Class::Migration.  We
don't expose this attribute to the commandline, so if you are smart enough to
do the subclassing (and sure you need to do that), I will assume you will also
either subclass DBIx::Class::Migration:Script or override then default
value using some standard technique.
.SS dbic_fixture_class
.IX Subsection "dbic_fixture_class"
Accepts: Str, Not Required.
.PP
You can use this if you need to make a custom subclass of DBIx::Class::Fixtures.
.SS dbic_fixtures_extra_args
.IX Subsection "dbic_fixtures_extra_args"
Accepts: HashRef, Not Required.
.PP
If provided will add some additional arguments when creating an instance of
"dbic_fixture_class".  You should take a look at the documentation for
DBIx::Class::Fixtures to understand what additional arguments may be of use.
.SS dbi_connect_attrs
.IX Subsection "dbi_connect_attrs"
Accepts: HashRef, Not Required.
.PP
If you are specifying a DSN, you might need to provide some additional args
to DBI (see "connect_info" in DBIx::Class::Storage::DBI for more).
.SS dbic_connect_attrs
.IX Subsection "dbic_connect_attrs"
Accepts: HashRef, Not Required.
.PP
If you are specifying a DSN, you might need to provide some additional args
to DBIx::Class (see "connect_info" in DBIx::Class::Storage::DBI for more).
.PP
You can also see "DBIx::Class\-specific\-connection\-attributes" in DBIx::Class::Storage::DBI
for more information on what this can do for you.  Chances are good if you
need this you will also want to subclass DBIx::Class::Migration::Script as
well.
.PP
Common uses for this is to run SQL on startup and set Postgresql search paths.
.SS extra_schemaloader_args
.IX Subsection "extra_schemaloader_args"
Accepts: HashRef, Not Required.
.PP
Used to populate "extra_schemaloader_args" in DBIx::Class::Migration
.SS migration_sandbox_builder_class
.IX Subsection "migration_sandbox_builder_class"
Accepts: String (Classname), Not Required.
.PP
Used to set "db_sandbox_builder_class" in DBIx::Class::Migration.  You probably
won't mess with this unless you are writing your own Sandbox builder class, or
using the alternative builder DBIx::Class::Migration::TempDirSandboxBuilder
for creating temporary sandboxes when you want to test your migrations.
.SH COMMANDS
.IX Header "COMMANDS"
.Vb 1
\&    dbic\-migration \-Ilib install
.Ve
.PP
Since this class uses MooX::Options, it can be run directly
as a commandline application.  The following is a list of commands we support
as well as the options / flags associated with each command.
.SS help
.IX Subsection "help"
See DBIx::Class::Migration::Script::Help::help.
.SS version
.IX Subsection "version"
See DBIx::Class::Migration::Script::Help::version.
.SS status
.IX Subsection "status"
See DBIx::Class::Migration::Script::Help::status.
.SS prepare
.IX Subsection "prepare"
See DBIx::Class::Migration::Script::Help::prepare.
.SS install
.IX Subsection "install"
See DBIx::Class::Migration::Script::Help::install.
.SS upgrade
.IX Subsection "upgrade"
See DBIx::Class::Migration::Script::Help::upgrade.
.SS downgrade
.IX Subsection "downgrade"
See DBIx::Class::Migration::Script::Help::downgrade.
.SS dump_named_sets
.IX Subsection "dump_named_sets"
See DBIx::Class::Migration::Script::Help::dump_named_sets.
.SS dump_all_sets
.IX Subsection "dump_all_sets"
See DBIx::Class::Migration::Script::Help::dump_all_sets.
.SS populate
.IX Subsection "populate"
See DBIx::Class::Migration::Script::Help::populate.
.SS drop_tables
.IX Subsection "drop_tables"
See DBIx::Class::Migration::Script::Help::drop_tables.
.SS delete_table_rows
.IX Subsection "delete_table_rows"
See DBIx::Class::Migration::Script::Help::delete_table_rows.
.SS make_schema
.IX Subsection "make_schema"
See DBIx::Class::Migration::Script::Help::make_schema.
.SS install_if_needed
.IX Subsection "install_if_needed"
See DBIx::Class::Migration::Script::Help::install_if_needed.
.SS install_version_storage
.IX Subsection "install_version_storage"
See DBIx::Class::Migration::Script::Help::install_version_storage.
.SS diagram
.IX Subsection "diagram"
See DBIx::Class::Migration::Script::Help::diagram.
.SS delete_named_sets
.IX Subsection "delete_named_sets"
See DBIx::Class::Migration::Script::Help::delete_named_sets.
.SS "Command Flags"
.IX Subsection "Command Flags"
The following flags are used to modify or inform commands.
.PP
\fIincludes\fR
.IX Subsection "includes"
.PP
See DBIx::Class::Migration::Script::Help::includes.
.PP
\fIschema_class\fR
.IX Subsection "schema_class"
.PP
See DBIx::Class::Migration::Script::Help::schema_class.
.PP
\fItarget_dir\fR
.IX Subsection "target_dir"
.PP
See DBIx::Class::Migration::Script::Help::target_dir.
.PP
\fIusername\fR
.IX Subsection "username"
.PP
Aliases: U
Value:  Str
.PP
\fIpassword\fR
.IX Subsection "password"
.PP
Aliases: P
Value: String
.PP
\fIdsn\fR
.IX Subsection "dsn"
.PP
Value: String
.PP
These three commandline flags describe how to connect to a target, physical
database, where we will deploy migrations and fixtures.  If you don't provide
them, we will automatically deploy to a DBD::SQLite managed database located
at "target_dir".
.PP
.Vb 1
\&    dbic\-migration install \-\-username myuser \-\-password mypass \-\-dsn DBI:SQLite:mydb.db
.Ve
.PP
\fIforce_overwrite\fR
.IX Subsection "force_overwrite"
.PP
See DBIx::Class::Migration::Script::Help::force_overwrite
.PP
\fIto_version\fR
.IX Subsection "to_version"
.PP
See DBIx::Class::Migration::Script::Help::to_version
.PP
\fIdatabases\fR
.IX Subsection "databases"
.PP
See DBIx::Class::Migration::Script::Help::databases
.PP
\fIfixture_sets\fR
.IX Subsection "fixture_sets"
.PP
See DBIx::Class::Migration::Script::Help::fixture_sets
.PP
\fIsandbox_class\fR
.IX Subsection "sandbox_class"
.PP
See DBIx::Class::Migration::Script::Help::sandbox_class
.PP
The default sqlite sandbox is documented at DBIx::Class::Migration::SQLiteSandbox
although this single file database is pretty straightforward to use.
.PP
If you are declaring the value in a subclass, you can use the pre-defined
constants to avoid typos (see "CONSTANTS").
.PP
\fIdbic_fixture_class\fR
.IX Subsection "dbic_fixture_class"
.PP
See DBIx::Class::Migration::Script::Help::dbic_fixture_class
.PP
\fIdbic_fixtures_extra_args\fR
.IX Subsection "dbic_fixtures_extra_args"
.PP
See DBIx::Class::Migration::Script::Help::dbic_fixtures_extra_args
.PP
\fIdbic_connect_attrs\fR
.IX Subsection "dbic_connect_attrs"
.PP
See DBIx::Class::Migration::Script::Help::dbic_connect_attrs
.PP
\fIdbi_connect_attrs\fR
.IX Subsection "dbi_connect_attrs"
.PP
See DBIx::Class::Migration::Script::Help::dbi_connect_attrs
.PP
\fIextra_schemaloader_args\fR
.IX Subsection "extra_schemaloader_args"
.PP
See DBIx::Class::Migration::Script::Help::extra_schemaloader_args
.SH "OPTIONAL METHODS FOR SUBCLASSES"
.IX Header "OPTIONAL METHODS FOR SUBCLASSES"
If you decide to make a custom subclass of DBIx::Class::Migration::Script,
(you might do this for example to better integrate your migrations with an
existing framework, like Catalyst) you may defined the following option
methods.
.SS default
.IX Subsection "default"
Returns a Hash of instantiation values.
.PP
Merges some predefined values when instantiating.  For example:
.PP
.Vb 1
\&    package MusicBase::Schema::MigrationScript;
\&
\&    use Moose;
\&    use MusicBase::Web;
\&
\&    extends \*(AqDBIx::Class::Migration::Script\*(Aq;
\&
\&    sub defaults {
\&      schema => MusicBase::Web\->model(\*(AqSchema\*(Aq)\->schema,
\&    }
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
\&    _\|_PACKAGE_\|_\->run_if_script;
.Ve
.PP
This would create a version of your script that already includes the target
\&\f(CW\*(C`schema\*(C'\fR.  In this example we will let Catalyst configuration handle which
database to run deployments against.
.SH "ADDITIONAL INFORMATION FOR SUBCLASSERS"
.IX Header "ADDITIONAL INFORMATION FOR SUBCLASSERS"
The following methods are documented of interest to subclassers.
.SS run_if_script
.IX Subsection "run_if_script"
Class method that detects if your module is being called as a script.  Place it
at the end of your subclass:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->run_if_script;
.Ve
.PP
This returns true in the case you are using the class as a module, and calls
"run_with_options" otherwise.  Adding this lets you invoke your class module
as a script from the commandline (saving you the trouble of writing a thin
script wrapper).
.PP
.Vb 1
\&    perl \-Ilib lib/MyApp/Schema/MigrationScript.pm \-\-status
.Ve
.SS run_with_options
.IX Subsection "run_with_options"
Given a Hash of initial arguments, merges those with the results of values passed
on the commandline (via MooX::Options) and run.
.SS run
.IX Subsection "run"
Actually runs commands.
.SH CONSTANTS
.IX Header "CONSTANTS"
The following constants are defined but not exported.  These are used to give
a canonical value for the "sandbox_class" attribute.
.SS SANDBOX_SQLITE
.IX Subsection "SANDBOX_SQLITE"
SqliteSandbox
.SS SANDBOX_MYSQL
.IX Subsection "SANDBOX_MYSQL"
MySQLSandbox
.SS SANDBOX_POSTGRESQL
.IX Subsection "SANDBOX_POSTGRESQL"
PostgresqlSandbox
.SH EXAMPLES
.IX Header "EXAMPLES"
Please see DBIx::Class::Migration::Tutorial for more.  Here's some basic use
cases.
.SS "Prepare deployment files for a schema"
.IX Subsection "Prepare deployment files for a schema"
.Vb 1
\&    dbic\-migration prepare \-\-schema_class MyApp::Schema
.Ve
.PP
This will prepare deployment files for just SQLite
.PP
.Vb 2
\&    dbic\-migration prepare \-\-database SQLite \-\-database MySQL \e
\&      \-\-schema_class MyApp::Schema
.Ve
.PP
This will prepare deployment files for both SQLite and MySQL
.SS "Install database from deployments"
.IX Subsection "Install database from deployments"
.Vb 1
\&    dbic\-migration install \-\-schema_class MyApp::Schema
.Ve
.PP
Creates the default sqlite database in the \f(CW\*(C`share\*(C'\fR directory.
.PP
.Vb 1
\&    dbic\-migration install \-\-schema_class MyApp::Schema \-\-to_version 2
.Ve
.PP
Same as the previous command, but installs version 2, instead of whatever is
the most recent version
.PP
.Vb 1
\&    dbic\-migration populate \-\-schema_class MyApp::Schema \-\-fixture_set seed
.Ve
.PP
Populates the \f(CW\*(C`seed\*(C'\fR fixture set to the current database (matches the database
version to the seed version.)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Class::Migration
.SH AUTHOR
.IX Header "AUTHOR"
See DBIx::Class::Migration for author information
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
See DBIx::Class::Migration for copyright and license information
