.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Any::Adapter::Development 3pm"
.TH Log::Any::Adapter::Development 3pm 2023-08-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Log::Any::Adapter::Development \- Manual for developing new Log::Any adapters
.SH VERSION
.IX Header "VERSION"
version 1.717
.SH SYNOPSIS
.IX Header "SYNOPSIS"
The adapter module:
.PP
.Vb 5
\&   package Log::Any::Adapter::YAL;
\&   use strict;
\&   use warnings;
\&   use Log::Any::Adapter::Util ();
\&   use base qw(Log::Any::Adapter::Base);
\&
\&   # Optionally initialize object, e.g. for delegation
\&   #
\&   sub init {
\&       my ($self) = @_;
\&
\&       $self\->{attr} = ...;
\&   }
\&
\&   # Create logging methods: debug, info, etc.
\&   #
\&   foreach my $method ( Log::Any::Adapter::Util::logging_methods() ) {
\&       no strict \*(Aqrefs\*(Aq;
\&       *$method = sub { ... };
\&   }
\&
\&   # or, support structured logging instead
\&   sub structured {
\&       my ($self, $level, $category, @args) = @_;
\&       # ... process and log all @args
\&   }
\&
\&
\&   # Create detection methods: is_debug, is_info, etc.
\&   #
\&   foreach my $method ( Log::Any::Adapter::Util::detection_methods() ) {
\&       no strict \*(Aqrefs\*(Aq;
\&       *$method = sub { ... };
\&   }
.Ve
.PP
and the application:
.PP
.Vb 1
\&   Log::Any\->set_adapter(\*(AqYAL\*(Aq);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This document describes how to implement a new Log::Any adapter.
.PP
The easiest way to start is to look at the source of existing adapters, such as
Log::Any::Adapter::Log4perl and
Log::Any::Adapter::Dispatch.
.SH NAMING
.IX Header "NAMING"
If you are going to publicly release your adapter, call it
\&'Log::Any::Adapter::\fIsomething\fR' so that users can use it with
.PP
.Vb 1
\&    Log::Any\->set_adapter(I<something>);
.Ve
.PP
If it's an internal driver, you can call it whatever you like and use it like
.PP
.Vb 1
\&    Log::Any\->set_adapter(\*(Aq+My::Log::Adapter\*(Aq);
.Ve
.SH "BASE CLASS"
.IX Header "BASE CLASS"
All adapters must directly or indirectly inherit from
Log::Any::Adapter::Base.
.SH "LOG LEVELS"
.IX Header "LOG LEVELS"
Log::Any supports the following log levels:
.PP
If the logging mechanism used by your adapter supports different levels,
it's your responsibility to map them appropriately when you implement the
logging and detection methods described below.  For example, if your
mechanism only supports "debug", "normal" and "fatal" levels, you might map
the levels like this:
.SH METHODS
.IX Header "METHODS"
.SS Constructor
.IX Subsection "Constructor"
The constructor (\f(CW\*(C`new\*(C'\fR) is provided by
Log::Any::Adapter::Base. It will:
.PP
At this point, overriding the default constructor is not supported. Hopefully
it will not be needed.
.PP
The constructor is called whenever a log object is requested. e.g. If the
application initializes Log::Any like so:
.PP
.Vb 1
\&    Log::Any\->set_adapter(\*(AqLog::YAL\*(Aq, yal_object => $yal, depth => 3);
.Ve
.PP
and then a class requests a logger like so:
.PP
.Vb 2
\&    package Foo;
\&    use Log::Any qw($log);
.Ve
.PP
Then \f(CW$log\fR will be populated with the return value of:
.PP
.Vb 1
\&    Log::Any::Adapter::Yal\->new(yal_object => $yal, depth => 3, category => \*(AqFoo\*(Aq);
.Ve
.PP
This is memoized, so if the same category should be requested again (e.g.
through a separate \f(CW\*(C`get_logger\*(C'\fR call, the same object will be returned.
Therefore, you should try to avoid anything non-deterministic in your "init"
function.
.SS "Logging methods"
.IX Subsection "Logging methods"
The following methods have no default implementation, and MUST be defined by
your subclass, unless your adapter supports "Structured logging":
.PP
These methods must log a message at the specified level.
.PP
To help generate these methods programmatically, you can get a list of the
sub names with the
Log::Any::Adapter::Util::logging_methods
function.
.SS "Log-level detection methods (required)"
.IX Subsection "Log-level detection methods (required)"
The following methods have no default implementation, and MUST be defined by
your subclass:
.PP
These methods must return a boolean indicating whether the specified level is
active, i.e. whether the adapter is listening for messages of that level.
.PP
To help generate these methods programmatically, you can get a list of the
sub names with the
Log::Any::Adapter::Util::detection_methods
function.
.SS "Structured logging"
.IX Subsection "Structured logging"
Your adapter can choose to receive structured data instead of a
string. In this case, instead of implementing all the "Logging
methods", you define a single method called \f(CW\*(C`structured\*(C'\fR. The method
receives the log level, the category, and all arguments that were
passed to the logging function, so be prepared to not only handle
strings, but also hashrefs, arrayrefs, coderefs, etc.
.SS Aliases
.IX Subsection "Aliases"
Aliases (e.g. "err" for "error") are handled by Log::Any::Proxy and will
call the corresponding real name in your adapter class.  You do not need to
implement them in your adapter.
.SS "Optional methods"
.IX Subsection "Optional methods"
The following methods have no default implementation but MAY be provided by
your subclass:
.IP init 4
.IX Item "init"
This is called after the adapter object is created and blessed into your class.
Perform any necessary validation or initialization here.  For example, you
would use \f(CW\*(C`init\*(C'\fR to create a logging object for delegation, or open a file
or socket, etc.
.SS "Support methods"
.IX Subsection "Support methods"
The following Log::Any::Adapter::Base method may be useful for defining
adapters via delegation:
.ie n .IP "delegate_method_to_slot ($slot, $method, $adapter_method)" 4
.el .IP "delegate_method_to_slot ($slot, \f(CW$method\fR, \f(CW$adapter_method\fR)" 4
.IX Item "delegate_method_to_slot ($slot, $method, $adapter_method)"
Handle the specified \f(CW$method\fR by calling \f(CW$adapter_method\fR on the object
contained in \f(CW\*(C`$self\->{$slot}\*(C'\fR.
.Sp
See Log::Any::Adapter::Dispatch and Log::Any::Adapter::Log4perl for
examples of usage.
.PP
The following Log::Any::Adapter::Util functions give you a list of
methods that you need to implement.  You can get logging methods, detection
methods or both:
.SH AUTHORS
.IX Header "AUTHORS"
.IP \(bu 4
Jonathan Swartz <swartz@pobox.com>
.IP \(bu 4
David Golden <dagolden@cpan.org>
.IP \(bu 4
Doug Bell <preaction@cpan.org>
.IP \(bu 4
Daniel Pittman <daniel@rimspace.net>
.IP \(bu 4
Stephen Thirlwall <sdt@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Jonathan Swartz, David Golden, and Doug Bell.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
