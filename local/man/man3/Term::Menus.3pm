.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Term::Menus 3pm"
.TH Term::Menus 3pm 2024-10-05 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Term::Menus \- Create Powerful Terminal, Console and CMD Enviroment Menus
.SH SYNOPSIS
.IX Header "SYNOPSIS"
\&\f(CW\*(C`use Term::Menus;\*(C'\fR
.PP
see METHODS section below
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Term::Menus allows you to create powerful Terminal, Console and CMD environment
menus. Any perl script used in a Terminal, Console or CMD environment can
now include a menu facility that includes sub-menus, forward and backward
navigation, single or multiple selection capabilities, dynamic item creation
and customized banners. All this power is simple to implement with a straight
forward and very intuitive configuration hash structure that mirrors the actual
menu architechture needed by the application. A separate configuration file is
optional. Term::Menus is cross platform compatible.
.PP
Term::Menus was initially conceived and designed to work seemlessly
with the perl based Network Process Automation Utility Module called
Net::FullAuto (Available in CPAN :\-) \- however, it is not itself dependant
on other Net::FullAuto components, and will work with *any* perl
script/application.
.PP
Reasons to use this module are:
.IP \(bu 2
You have a list (or array) of items, and wish to present the user a simple
CMD enviroment menu to pick a single item and return that item as a scalar
(or simple string). Example:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my @list=(\*(AqFirst Item\*(Aq,\*(AqSecond Item\*(Aq,\*(AqThird Item\*(Aq);
\&   my $banner="  Please Pick an Item:";
\&   my $selection=&pick(\e@list,$banner);
\&   print "SELECTION = $selection\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Please Pick an Item:
\&
\&       1      First Item
\&       2      Second Item
\&       3      Third Item
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 2 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTION = Second Item
.Ve
.IP \(bu 2
You have a large list of items and need scrolling capability:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my @list=\`ls \-1 /bin\`;
\&   my $banner="   Please Pick an Item:";
\&   my $selection=&pick(\e@list,$banner);
\&   print "SELECTION = $selection\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Please Pick an Item:
\&
\&       1      arch
\&       2      ash
\&       3      awk
\&       4      basename
\&       5      bash
\&       6      cat
\&       7      chgrp
\&       8      chmod
\&       9      chown
\&       10     cp
\&
\&   a.  Select All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Please Pick an Item:
\&
\&       11      cpio
\&       12      csh
\&       13      cut
\&       14      date
\&       15      dd
\&       16      df
\&       17      echo
\&       18      ed
\&       19      egrep
\&       20      env
\&
\&   a.  Select All   f.  FINISH
\&                        _\|_\|_
\&   93  Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 14 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTION = date
.Ve
.IP \(bu 2
You need to select multiple items and return the selected list:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my %Menu_1=(
\&
\&      Item_1 => {
\&
\&         Text    => "/bin Utility \- ]Convey[",
\&         Convey  => [ \`ls \-1 /bin\` ],
\&
\&      },
\&
\&      Select => \*(AqMany\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my @selections=&Menu(\e%Menu_1);
\&   print "SELECTIONS = @selections\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 3 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
\&\-\-< 7 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&    *  3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&    *  7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< f >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTIONS = /bin Utility \- awk /bin Utility \- chgrp
.Ve
.IP \(bu 2
You need sub-menus:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my %Menu_2=(
\&
\&      Name   => \*(AqMenu_2\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Previous[ is a ]Convey[ Utility",
\&         Convey => [ \*(AqGood\*(Aq,\*(AqBad\*(Aq ]
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose an Answer :"
\&   );
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my $selection=&Menu(\e%Menu_1);
\&   print "\en   SELECTION=$selection\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&      1.        /bin Utility \- arch
\&      2.        /bin Utility \- ash
\&      3.        /bin Utility \- awk
\&      4.        /bin Utility \- basename
\&      5.        /bin Utility \- bash
\&      6.        /bin Utility \- cat
\&      7.        /bin Utility \- chgrp
\&      8.        /bin Utility \- chmod
\&      9.        /bin Utility \- chown
\&      10.       /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.   FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 5 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Choose an Answer :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 1 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTIONS = bash is a Good Utility
.Ve
.IP \(bu 2
You have a large amount of text, or instructional information, and want
a \fIbanner only screen\fR that displays the banner only (no selections) and
that moves to the next screen/menu with just a press of the ENTER key.
Yet, you want to preserve selections from earlier menus, and/or return
to more menus after user completes reading the banner only screens.
You can also navigate backwards and forwards through these screens.
.Sp
.Vb 1
\&   use Term::Menus:
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Banner => "\en   This is a BANNER ONLY display."
\&
\&   );
\&
\&   &Menu(\e%Menu_1);
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   This is a BANNER ONLY display.
\&
\&   ([ESC] to Quit)   Press ENTER to continue ...
.Ve
.IP \(bu 2
You want to use perl subroutines to create the text items and/or banner:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   sub create_items {
\&
\&      my $previous=shift;
\&      my @textlines=();
\&      push @textlines, "$previous is a Good Utility";
\&      push @textlines, "$previous is a Bad Utility";
\&      return @textlines;
\&             ## return value must be an array
\&             ## NOT an array reference
\&
\&   }
\&
\&   sub create_banner {
\&
\&      my $previous=shift;
\&      return "\en   Choose an Answer for $previous :"
\&             ## return value MUST be a string for banner
\&
\&   }
\&
\&   my %Menu_2=(
\&
\&      Name   => \*(AqMenu_2\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Convey[",
\&         Convey => "create_items(]Previous[)",
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "create_banner(]Previous[)",
\&
\&   );
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my @selection=&Menu(\e%Menu_1);
\&   print "\en   SELECTION=@selection\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 5 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Choose an Answer for bash :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 1 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTION = bash is a Good Utility
.Ve
.IP \(bu 2
You want to use anonymous subroutines to create the text items and/or banner
(see the more detailed treatment of anonymous subroutines and Term::Menus
macros in a later section of this documentation):
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my $create_items = sub {
\&
\&      my $previous=shift;
\&      my @textlines=();
\&      push @textlines, "$previous is a Good Utility";
\&      push @textlines, "$previous is a Bad Utility";
\&      return \e@textlines;
\&             ## return value must an array reference
\&
\&   };
\&
\&   my $create_banner = sub {
\&
\&      my $previous=shift;
\&      return "\en   Choose an Answer for ]Previous[ :"
\&             ## return value MUST be a string for banner
\&
\&   };
\&
\&   my %Menu_2=(
\&
\&      Name   => \*(AqMenu_2\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Convey[",
\&         Convey => $create_items\->(\*(Aq]Previous[\*(Aq), # Subroutine executed
\&                                                  # at runtime by Perl
\&                                                  # and result is passed
\&                                                  # to Term::Menus.
\&
\&                                                  # Do not use this argument
\&                                                  # construct with Result =>
\&                                                  # elements because only Menu
\&                                                  # blocks or subroutines can
\&                                                  # be passed. (Unless the
\&                                                  # return item is itself
\&                                                  # a Menu configuration
\&                                                  # block [HASH] or an
\&                                                  # anonymous subroutine
\&                                                  # [CODE])
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => $create_banner, # Perl passes sub itself at runtime and
\&                                # execution is carried out by Term::Menus.
\&
\&   );
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my @selection=&Menu(\e%Menu_1);
\&   print "\en   SELECTION=@selection\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 5 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Choose an Answer for bash :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 1 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTION = bash is a Good Utility
.Ve
.PP
Usage questions should be directed to the Usenet newsgroup
comp.lang.perl.modules.
.PP
Contact me, Brian Kelly <Brian.Kelly@fullautosoftware.net>,
if you find any bugs or have suggestions for improvements.
.SS "What To Know Before Using"
.IX Subsection "What To Know Before Using"
.IP \(bu 2
There are two methods available with Term::Menus \- &\fBpick()\fR and &\fBMenu()\fR.
\&\f(CW&Menu()\fR uses \f(CW&pick()\fR \- you can get the same results using
only
\&\f(CW&Menu()\fR. However, if you need to simply pick one item from a single
list \- use \f(CW&pick()\fR. The syntax is simpler, and you'll write less code.
;\-)
.IP \(bu 2
You'll need to be running at least Perl version 5.002 to use this
module.
.SH METHODS
.IX Header "METHODS"
.IP "\fBpick\fR \- create a simple menu" 4
.IX Item "pick - create a simple menu"
.Vb 1
\&    $pick = &pick ($list|\e@list|[\*(Aqlist\*(Aq,...],[$Banner]);
.Ve
.Sp
Where \fR\f(CI$list\fR\fI\fR is a variable containing an array or list reference.
This argument can also be a escaped array (sending a reference) or
an anonymous array (which also sends a reference).
.Sp
\&\fR\f(CI$Banner\fR\fI\fR is an optional argument sending a customized Banner to
top the simple menu \- giving instructions, descriptions, etc.
The default is "Please Pick an Item:"
.IP "\fBMenu\fR \- create a complex Menu" 4
.IX Item "Menu - create a complex Menu"
.Vb 1
\&    $pick  = &Menu ($list|\e@list|[\*(Aqlist\*(Aq,...],[$Banner]);
.Ve
.Sp
Where \fR\f(CI$pick\fR\fI\fR is a variable containing an array or list reference
of the pick or picks.
.Sp
.Vb 1
\&    @picks = &Menu ($Menu_1|\e%Menu_1|{ Name => \*(AqMenu_1\*(Aq });
.Ve
.Sp
Where \fR\f(CI$Menu_1\fR\fI\fR is a hash reference to the top level Menu
Configuration Hash Structure.
.SS "Menu Configuration Hash Structures"
.IX Subsection "Menu Configuration Hash Structures"
.RS 4
These are the building blocks of the overall Menu architecture. Each
hash structure represents a \fImenu screen\fR. A single menu layer, has
only one hash structure defining it. A menu with a single sub-menu
will have two hash structures. The menus connect via the \f(CW\*(C`Result\*(C'\fR
element of an \fIItem\fR \- \f(CW\*(C`Item_1\*(C'\fR \- hash structure in parent menu
\&\f(CW%Menu_1\fR:
.Sp
.Vb 1
\&   my %Menu_2=(
\&
\&      Name   => \*(AqMenu_2\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Previous[ is a ]Convey[ Utility",
\&         Convey => [ \*(AqGood\*(Aq,\*(AqBad\*(Aq ]
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose an Answer :"
\&   );
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
.Ve
.RE
.PP
\fIMenu Component Elements\fR
.IX Subsection "Menu Component Elements"
.PP
Each Menu Configuration Hash Structure consists of elements that define
and control it's behavior, appearance, constitution and purpose. An
element's syntax is as you would expect it to be in perl \- a key string
pointing to an assocaited value: \f(CW\*(C`key => value\*(C'\fR. The following
items
list supported key names and ther associated value types:
.IP \(bu 4
\&\fBDisplay\fR => 'Integer'
.RS 4
.Sp
.RS 2
The \fIDisplay\fR key is an \fIoptional\fR key that determines the number
of Menu
Items that will be displayed on each screen. This is useful when the items
are multi-lined, or the screen size is bigger or smaller than the default
number utilizes in the most practical fashion. The default number is 10.
.Sp
.Vb 1
\&   Display => 15,
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBName\fR => 'Char String consisting of ASCII Characters'
.RS 4
.Sp
.RS 2
The \fIName\fR key provides a unique identifier to each Menu Structure.
This element is not "strictly" required for most Menu construts to
function properly. Term::Menus goes to great lengths to discover and
utilize the Menu's name provided on the left side of the equals
character of a Menu block using the following construct:
.Sp
.Vb 1
\&   my %MenuName=(
\&
\&      [ Menu Contents Here ]
\&
\&   );
.Ve
.Sp
In the above example, the Menu name is "MenuName". Most of the time 
Term::Menus will discover this name successfully, affording the user 
or Menu developer one less requirement to worry about. Allowing 
Term::Menus to discover this name will cut down on opportunities for
coding errors (and we all have enough of those already). HOWEVER,
there are "edge cases" and more complex Menu constructs that will 
prevent Term::Menus from accurately discovering this name. Therefore,
it is recommended and is considered a "best practice" to always 
explicitly "Name" Menu blocks as follows:
.Sp
.Vb 1
\&   my %MenuName=(
\&
\&      Name => \*(AqMenuName\*(Aq,
\&
\&      [ Menu Contents Here ]
\&
\&   );
.Ve
.Sp
Be careful to always use the SAME NAME for the Name element as for
the Menu block itself. This can be a source of error, especially
when one is using Macros that reference Menu Names explicitly (So
be CAREFUL!) One case where the Name element must ALWAYS be used
(if one wishes to reference that Menu with an explicit Named Macro)
is when creating anonymous Menu blocks to feed directly to Result
elements:
.Sp
.Vb 1
\&   my %ContainingMenu=(
\&
\&      Name   => \*(AqContainingMenu\*(Aq,
\&      Item_1 => {
\&
\&          Text => "Some Text",
\&          Result => {
\&
\&             Name => "Anonymous_Menu", # MUST use "Name" element
\&                                       # if planning to use
\&                                       # explicit Macros
\&
\&             [ Menu Contents Here ]
\&
\&          },
\&      },
\&
\&   );
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBItem_<int>\fR => { Item Configuration Hash
Structure }
.RS 4
.Sp
.RS 2
The \fIItem_<int>\fR elements define customized menu items.
There are
essentially two methods for creating menu items: The \fIItem_<int>\fR
elements, and the \f(CW\*(C`]Convey[\*(C'\fR macro (described later). The difference being
that the \f(CW\*(C`]Convey[\*(C'\fR macro turns an Item Configuration Hash into an Item
\&\fITemplate\fR \-> a \fBpowerful\fR way to \fIItem\fR\-ize large lists
or quantities
of data that would otherwise be difficult \- even impossible \- to anticipate
and cope with manually.
.Sp
.Vb 2
\&   Item_1 => { Text => \*(AqItem 1\*(Aq },
\&   Item_2 => { Text => \*(AqItem 2\*(Aq },
.Ve
.Sp
Items created via \f(CW\*(C`]Convey[\*(C'\fR macros have two drawbacks:
.IP \(bu 2
They all have the same format.
.IP \(bu 2
They all share the same \f(CW\*(C`Result\*(C'\fR element.
.RE
.RS 2
.Sp
The syntax and usage of \fIItem_<int>\fR elements is important
and
extensive enough to warrant it's own section. See \fR\f(BIItem Configuration 
Hash Structures\fR\fB\fR below.
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBSelect\fR => 'One' \-\-or\-\- 'Many'
.RS 4
.Sp
.RS 2
The MENU LEVEL \fISelect\fR element determines whether this particular menu
layer allows the selection of multiple items \- or a single item. The 
default is 'One'.
.Sp
.Vb 1
\&   Select => \*(AqMany\*(Aq,
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBBanner\fR => 'Char String consisting of ASCII Characters' or  
anonymous subroutine or subroutine reference for generating 
dynamic banners.
.RS 4
.Sp
.RS 2
The \fIBanner\fR element provides a customized descriptive header to the menu.
\&\fR\f(CI$Banner\fR\fI\fR is an optional element \- giving instructions, descriptions, etc.
The default is "Please Pick an Item:"
.Sp
.Vb 2
\&   Banner => "The following items are for selection,\en".
\&             "\etEnjoy the Experience!",
.Ve
.Sp
\&\-\-or\-\-
.Sp
.Vb 1
\&   Banner => sub { <generate dynamic banner content here> },
.Ve
.Sp
\&\-\-or\-\-
.Sp
.Vb 1
\&   my $create_banner = sub { <generate dynamic banner content here> },
\&
\&   Banner => $create_banner,
.Ve
.Sp
Creating a reference to a Banner subroutine enables the sharing of
Banner generation code between multiple Menus.
.Sp
\&\fBNOTE:\fR   Macros (like  \f(CW\*(C`]Previous[\*(C'\fR )  \fIcan\fR be used in Banners!   :\-)   ( See Item Configuration Macros below )
.RE
.RE
.RS 4
.RE
.PP
\fIItem Configuration Hash Structures\fR
.IX Subsection "Item Configuration Hash Structures"
.PP
Each Menu Item can have an independant configurtion. Each Menu Configuration
Hash Structure consists of elements that define and control it's behavior,
appearance, constitution and purpose. An element's syntax is as you would
expect it to be in perl \- a key string pointing to an assocaited value: key
=> value. The following items list supported key names and ther associated
value types:
.IP \(bu 4
\&\fBText\fR => 'Char String consisting of ASCII Characters'
.RS 4
.Sp
.RS 2
The \fIText\fR element provides a customized descriptive string for the Item.
It is the text the user will see displayed, describing the selection.
.Sp
.Vb 1
\&   Text => \*(AqThis is Item_1\*(Aq,
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBConvey\fR => [ List ] \-\-or\-\- \f(CW@List\fR \-\-or\-\- \f(CW$Scalar\fR \-\-or\-\- 'ASCII String' \-\-or\-\- Anonymous Subroutine \-\-or\-\- Subroutine Reference \-\-or\-\- Ordinary Subroutine (*Ordinary* subroutine calls need to be surrounded by quotes. DO NOT use quotes with anonymous subroutine calls or ones called with a reference!)
.RS 4
.Sp
.RS 2
The \fIConvey\fR element has a twofold purpose; it provides for the contents
of the \f(CW\*(C`]Convey[\*(C'\fR macro, and defines or contains the string or result that
is passed on to child menus \- if any. Use of this configuration element is
\&\fIoptional\fR. If \f(CW\*(C`Convey\*(C'\fR is not a list, then it's value is passed onto child
menus. If \f(CW\*(C`Convey\*(C'\fR \fIis\fR a list, then the Item selected is passed onto the
children \- if any. It is important to note, \fIwhen used\fR, that only the
resulting \fIConvey\fR string \- \fR\f(BINOT\fR\fB\fR the the Item \f(CW\*(C`Text\*(C'\fR value or string,
is conveyed to child menus. When the \f(CW\*(C`Convey\*(C'\fR element is not used, the
full Item \f(CW\*(C`Text\*(C'\fR value \fBis\fR conveyed to the children \- if any. However, the
full contents of the \f(CW\*(C`Text\*(C'\fR element is \fIreturned\fR as the \fIResult\fR of the
operation when the user completes all menu activity. See the \fIMacro\fR section
below for more information.
.Sp
.Vb 1
\&   Convey => [ \`ls \-1\` ],
.Ve
.Sp
\&\fBNOTE:\fR     When using anonymous subroutines or subroutine references, there may be situations where code populating the Convey item encounters an error or gets data that is empty or unsatisfactory for some reason, and there is a need to print a message or write to a log or send an alert, and then return from this routine to an earlier menu. To force a return to a parent menu (assuming there is one) from a subroutine assigned to a Convey element, just return '<' from the subroutine. To return to any ancestor Menu in the stack, return this macro from the subroutine: \f(CW\*(C`{Menu_Name}<\*(C'\fR :\-)
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBDefault\fR => 'Char String' \-\-or\-\- Perl regular expression \- qr/.../
.RS 4
.Sp
.RS 2
The \fIDefault\fR element provides a means to pre-select certain elements,
as if the items were selected by the user. This can be done with two
constructs \- simple string or pre-compiled regular expression.
Note: The \f(CW\*(C`Default\*(C'\fR element is available only when the \f(CW\*(C`Select\*(C'\fR element
is set to \f(CW\*(AqMany\*(Aq\fR \- \f(CW\*(C`Select =\*(C'\fR 'Many',>
.Sp
.Vb 1
\&   Default => \*(Aqbase|chown\*(Aq,
\&
\&   Default => qr/base|chown/i,
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&    *  4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&    *  9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBSelect\fR => 'One' \-\-or\-\- 'Many'
.RS 4
.Sp
.RS 2
The ITEM LEVEL \fISelect\fR element provides a means to inform Term::Menus
that the specific items of a single ITEM BLOCK (as opposed to full menu)
are subject to multiple selecting \- or just single selection. This is
useful in particular for Directory Tree navigation \- where files can
be multi-selected (or tagged), yet when a directory is selectedi, it
forces an immediate navigation and new menu \- showing the contents of
the just selected directory.
.Sp
\&\fBNOTE:\fR See the \fBRECURSIVELY CALLED MENUS\fR section for more information.
.Sp
.Vb 1
\&   Select => \*(AqMore\*(Aq,
.Ve
.Sp
The user sees ==>
.Sp
.Vb 10
\&    d  1      bin
\&    d  2      blib
\&    d  3      dist
\&    d  4      inc
\&    d  5      lib
\&    d  6      Module
\&    d  7      t
\&       8      briangreat2.txt
\&    *  9      ChangeLog
\&       10     close.perl
\&
\&   a.  Select All   f.  FINISH
\&                       _\|_\|_
\&   49 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBExclude\fR => 'Char String' \-\-or\-\- Perl regular expression \- qr/.../
.RS 4
.Sp
.RS 2
The \fIExclude\fR element provides a means to remove matching elements
from the Menu seen by the user. This element is useful only when the
\&\f(CW\*(C`]Convey[\*(C'\fR macro is used to populate items. This can be done with two
constructs \- simple string or pre-compiled regular expression.
.Sp
.Vb 1
\&   Exclude => \*(Aqbase|chown\*(Aq,
\&
\&   Exclude => qr/base|chown/i,
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBInclude\fR => 'Char String' \-\-or\-\- Perl regular expression \- qr/.../
.RS 4
.Sp
.RS 2
The \fIInclude\fR element provides a means to create items filtered from a larger
list of potential items available via the \f(CW\*(C`]Convey[\*(C'\fR macro. This element is
useful only when the \f(CW\*(C`]Convey[\*(C'\fR macro is used to populate items. The
\&\f(CW\*(C`Exclude\*(C'\fR element can be used in conjunction with \f(CW\*(C`Include\*(C'\fR to further
refine the final list of items used to construct the menu. The \f(CW\*(C`Include\*(C'\fR
element \- when used \- always takes presidence, and the \f(CW\*(C`Exclude\*(C'\fR will be used
only on the \f(CW\*(C`Include\*(C'\fR filtered results. This element can be used with
two value constructs \- simple string or pre-compiled regular expression.
.Sp
.Vb 1
\&   Include => \*(Aqbase|chown\*(Aq,
\&
\&   Include => qr/base|chown/i,
.Ve
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBResult\fR => \e%Menu_2  \-\-or \-\-  "&\fBany_method()\fR",
.RS 4
.IP \(bu 2
\&\fIResult\fR is an \fIoptional\fR element that also has two important uses:
.IP \(bu 2
For selecting the child menu next in the chain of operation and conveyance,
.Sp
.Vb 1
\&   Result => \e%Menu_2,
.Ve
.Sp
\&\-\-or\-\-
.IP \(bu 2
For building customized method arguements using \f(CW&Menu()\fR's built-in
macros.
.IP \(bu 2

.Sp
.Vb 1
\&   Result => "&any_method($arg1,\e"]Selected[\e",\e"]Previous[\e")",
.Ve
.Sp
\&\fBNOTE:\fR \fIALWAYS\fR be sure to surround the subroutine or method calling
syntax with DOUBLE QUOTES. (You can use single quotes if you don't want
interpolation). Quotes are necessary because you're telling \f(CW&Menu()\fR \-
\&\fInot\fR Perl \- what method you want invoked. \f(CW&Menu()\fR won't invoke the method
until after all other processing \- where Perl will try to invoke it the first
time it encounters the line during runtime \- lo\-\-\-\-ng before a user gets a
chance to see or do \fIanything\fR. \fBBUT\fR \- be sure \fR\f(BINOT\fR\fI\fR to use quotes
when assigning a child menu reference to the \f(CW\*(C`Result\*(C'\fR value.
.Sp
Again, \fIResult\fR is an \fIoptional\fR element. The default behavior when
\&\f(CW\*(C`Result\*(C'\fR is omitted from the Item Configuration element, is for the selection
to be returned to the \f(CW&Menu()\fR's calling script/module/app. If the \f(CW\*(C`Select\*(C'\fR
element was set to \f(CW\*(AqOne\*(Aq\fR, then that item is returned regardless of whether
the Perl structure receiving the output is an array or scalar. If there were
multiple selections \- i.e., \f(CW\*(C`Select\*(C'\fR is set to \f(CW\*(AqMany\*(Aq\fR \- then, depending
on what structure is set for receiving the output, will determine whether
\&\f(CW&Menu()\fR returns a list (i.e. \- array), or \fIreference\fR to an array.
.RE
.RS 4
.RE
.IP \(bu 4
\&\fBInput\fR => 1  \-\-or \-\-  0,
.RS 4
.IP \(bu 2
\&\fIInput\fR is an \fIoptional\fR element that that is used with Term::Menus FORMS:
.IP \(bu 2
For indicating to Term::Menus that the configuration hash is for a FORMS page.
.Sp
.Vb 1
\&   Input => 1,
.Ve
.RE
.RS 4
.RE
.PP
\fIItem Configuration Macros\fR
.IX Subsection "Item Configuration Macros"
.PP
Each Menu Item can utilize a very powerful set of configuration \fIMacros\fR.
These constructs principally act as purveyors of information \- from one
menu to another, from one element to another. There are currently three
available Macros:
.IP \(bu 4
\&\fB]Convey[\fR
.RS 4
.Sp
.RS 2
\&\f(CW\*(C`]Convey[\*(C'\fR is used in conjunction with the \fIConvey\fR element (described)
earlier. It's purpose to "convey" or transport or carry a list item associated
with the \f(CW\*(C`Convey\*(C'\fR element \- and replace the \f(CW\*(C`]Convey[\*(C'\fR Macro in the \f(CW\*(C`Text\*(C'\fR
element value with that list item. The \fIConvey\fR mechanism utilizing the
\&\f(CW\*(C`Convey\*(C'\fR Macro is essentially an \fIItem multiplier\fR. The entire contents of
the list associated with the \fIConvey\fR element will be turned into it's own
\&\f(CW\*(C`Item\*(C'\fR when the menu is displayed. Both ordinary and anonymous subroutines can be use to dynamically generate \fIConvey\fR lists. (With \fI]Convey[\fR, macros can be used only as subroutine arguments or in the body of anonymous subroutines \- see other examples.)
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my @selections=&Menu(\e%Menu_1);
\&   print "SELECTIONS=@selections\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\fBNOTE:\fR     \f(CW\*(C`]C[\*(C'\fR  can be used as a shorthand for  \f(CW\*(C`]Convey[\*(C'\fR.
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fB]Previous[\fR
.RS 4
.Sp
.RS 2
\&\f(CW\*(C`]Previous[\*(C'\fR can be used in child menus. The \f(CW\*(C`]Previous[\*(C'\fR Macro contains
the \fISelection\fR of the parent menu. Unlike the \f(CW\*(C`]Convey[\*(C'\fR Macro, the
\&\f(CW\*(C`]Previous[\*(C'\fR Macro can be used in both the \f(CW\*(C`Text\*(C'\fR element value, and the
\&\f(CW\*(C`Result\*(C'\fR element values (when constructing method calls):
.Sp
The \f(CW\*(C`]Previous[\*(C'\fR Macro can also be used in the Banner.
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my %Menu_2=(
\&
\&      Name   => \*(AqMenu_2\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Previous[ is a ]Convey[ Utility",
\&         Convey => [ \*(AqGood\*(Aq,\*(AqBad\*(Aq ]
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose an Answer :"
\&   );
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my @selections=&Menu(\e%Menu_1);
\&   print "SELECTIONS=@selections\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 5 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Choose an Answer :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 1 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTIONS = bash is a Good Utility
.Ve
.Sp
\&\fBNOTE:\fR     \f(CW\*(C`]P[\*(C'\fR  can be used as a shorthand for  \f(CW\*(C`]Previous[\*(C'\fR.
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fB]Previous[{\fR <\fIMenu_Name\fR> \fB}\fR  i.e. Explicit Named Macro
.RS 4
.Sp
.RS 2
\&\f(CW\*(C`]Previous[{Menu_Name}\*(C'\fR (i.e. Explicit Named Macros) can be used in child menus. 
The \f(CW\*(C`]Previous[{Menu_Name}\*(C'\fR Macro contains the \fISelection\fR of any preceding menu 
specified with the \f(CW\*(C`Menu_Name\*(C'\fR string. The \f(CW\*(C`]Previous[{Menu_Name}\*(C'\fR follows the 
same conventions as the \f(CW\*(C`]Previous[\*(C'\fR Macro \- but enables access to the selection 
of i<any> preceding menu. This is very useful for Menu trees more than two levels 
deep.
.Sp
The \f(CW\*(C`]Previous[{Menu_Name}\*(C'\fR Macro can also be used in the Banner.
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my %Menu_3=(
\&
\&      Name   => \*(AqMenu_3\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Convey[ said ]P[{Menu_1} is a ]Previous[ Utility!",
\&         Convey => [ \*(AqBob\*(Aq,\*(AqMary\*(Aq ]
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Who commented on ]Previous[{Menu_1}? :"
\&   );
\&
\&   my %Menu_2=(
\&
\&      Name   => \*(AqMenu_2\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "]Previous[ is a ]C[ Utility",
\&         Convey => [ \*(AqGood\*(Aq,\*(AqBad\*(Aq ],
\&         Result => \e%Menu_3,
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Is ]P[ Good or Bad? :"
\&   );
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => \e%Menu_2,
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my @selections=&Menu(\e%Menu_1);
\&   print "SELECTIONS=@selections\en";
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&       5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 5 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Is bash Good or Bad? :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 1 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
.Vb 1
\&   Who commented on bash? :
\&
\&       1      Bob said bash is a Good Utility!
\&       2      Mary said bash is a Good Utility!
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 2 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   SELECTIONS = Mary said bash is a Good Utility!
.Ve
.Sp
\&\fBNOTE:\fR     \f(CW\*(C`]P[\*(C'\fR  can be used as a shorthand for  \f(CW\*(C`]Previous[\*(C'\fR.
.Sp
\&\f(CW\*(C`]P[{Menu_Name}\*(C'\fR  can be used as a shorthand for \f(CW\*(C`]Previous[{Menu_Name}\*(C'\fR.
.Sp
\&\f(CW\*(C`]C[\*(C'\fR can be used as a shorthand for \f(CW\*(C`]Convey[\*(C'\fR.
.RE
.RE
.RS 4
.RE
.IP \(bu 4
\&\fB]Selected[\fR
.RS 4
.Sp
.RS 2
\&\f(CW\*(C`]Selected[\*(C'\fR can only be used in a \fIterminal\fR menu. \fB(\fR \fIA terminal menu is
the last menu in the chain, or the last menu the user sees. It is the menu that
defines the\fR \f(CW\*(C`Result\*(C'\fR \fIelement with a method\fR \f(CW\*(C`Result => &any_method()\*(C'\fR,
\&\fIor does not have a\fR \f(CW\*(C`Result\*(C'\fR \fIelement included or defined.\fR \fB)\fR
\&\f(CW\*(C`]Selected[\*(C'\fR is used to pass the selection of the \fIcurrent\fR menu to the
\&\f(CW\*(C`Result\*(C'\fR element method of the current menu:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   sub selected { print "\en   SELECTED ITEM = $_[0]\en" }
\&
\&   my %Menu_1=(
\&
\&      Name   => \*(AqMenu_1\*(Aq,
\&      Item_1 => {
\&
\&         Text   => "/bin/Utility \- ]Convey[",
\&         Convey => [ \`ls \-1 /bin\` ],
\&         Result => "&selected(]Selected[)", # ]Selected[ macro passed to
\&                                            # ordinary perl subroutine.
\&                                            # The \*(Aq&\*(Aq characater is optional
\&                                            # but the quotes are NOT. Ordinary
\&                                            # subroutine calls MUST be
\&                                            # surrounded by either double or
\&                                            # single quotes. (DO NOT use
\&                                            # quotes around anonymous
\&                                            # subroutine calls, however!) 
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my $selection=&Menu(\e%Menu_1);
\&   print "\en   SELECTION=$selection\en";
.Ve
.Sp
\&\fBNOTE:\fR     \f(CW\*(C`]S[\*(C'\fR  can be used as a shorthand for  \f(CW\*(C`]Selected[\*(C'\fR.
.Sp
\&\fBNOTE:\fR     It is possible to use the same Result subroutine in
             different \fBItem_<int>\fR blocks, and even in
             other Menu blocks within the same script. Furthermore,
             when complex Menu structures are created using lots
             of anonymous subroutines with generous subroutine
             reuse, it can be difficult to prevent early substitution
             of this Macro by a parent Menu. To prevent this, use
             the Explicit Named Macro construct with this Macro as
             well \- \f(CW\*(C`]Selected[{Menu_Name}\*(C'\fR
.Sp
.Vb 4
\&             Also, if the same Result subroutine is to be used by
\&             multiple nested menus, all the Menu_Names of those Menu
\&             blocks should be included in the Named section
\&             separated by the vertical bar symbol \- C<]S[{Menu1_Name|Menu2_Name}>
.Ve
.Sp
\&\fBNOTE:\fR     \fBStepchild and Grandchild Menus\fR \- While on the topic
             of multiple nested menus, one of the more challenging
             aspects is preventing child menus from having their
             macros expanded or populated too "early" during runtime.
             Using the "Explict Name" convention (\f(CW\*(C`]Selected[{Menu_Name}\*(C'\fR)
             helps, but there is another issue to be aware of. It is
             extremely useful (and powerful!) to use previous menu
             selections to dynamically build and return child menus
             for some results, but not for others. Code to reflect
             this goal would ordinarly look like this:
.Sp
.Vb 1
\&             $result_code = sub {
\&
\&                my $selection=\*(Aq]S[{current_menu_name}\*(Aq;
\&                if ($selection eq \*(AqReturn to Main Menu\*(Aq)  {
\&
\&                   return \*(Aq{main}<\*(Aq;
\&
\&                } else {
\&
\&                   my %next_menu=(
\&
\&                      Name => \*(Aqnext_menu\*(Aq,
\&                      Item_1 => {
\&
\&                         Text => \*(Aq]C[\*(Aq,
\&                         Convey => [ ... ],
\&
\&                      },
\&                      Item_2 => { ... },
\&
\&                   );
\&
\&                }
\&
\&             };
\&
\&             But this may not work correctly. The reason is that
\&             Term::Menus identifies menus in result blocks by
\&             explicitly looking for the \*(AqItem_\*(Aq (Item underscore)
\&             string in the block. If it finds one it will treat
\&             the result as a child menu to be I<immediately>
\&             created \- not a routine to be evaluated first! So,
\&             in this scenario, the routine is acting as a kind
\&             of surrogate or "step" parent, since it is not a
\&             "real" parent menu. Hence, the "stepchild" menu. In
\&             this situation it may be necessary to "trick"
\&             Term::Menus into not recognizing the embedded menu
\&             (yet) that is part of a conditional structure that
\&             will be returned, only if the conditional is true.
\&             To do that, you can code this scenario like this:
\&
\&             $result_code = sub {
\&
\&                my $selection=\*(Aq]S[{current_menu_name}\*(Aq;
\&                if ($selection eq \*(AqReturn to Main Menu\*(Aq)  {
\&
\&                   return \*(Aq{main}<\*(Aq;
\&
\&                } else {
\&
\&                   my %next_menu=(  # This is a "stepchild" menu
\&
\&                      Name => \*(Aqnext_menu\*(Aq,
\&
\&                   );
\&                   my $key = \*(AqItem\*(Aq.\*(Aq_1\*(Aq;
\&                   $next_menu{$key}={
\&
\&                       Text => \*(Aq]C[\*(Aq,
\&                       Convey => [ ... ],
\&
\&                   };
\&                   $key = \*(AqItem\*(Aq.\*(Aq_2\*(Aq; 
\&                   $next_menu{$key}={
\&
\&                       Text => \*(Aq. . .\*(Aq,
\&
\&                   };
\&                   return \e%next_menu;
\&
\&                }
\&
\&             };
\&
\&             While that works, it is not very elegant (and not
\&             Best Practice!). It is better in these situations
\&             to substitute the Select (C<]Select[>) or Previous
\&             (C<]Previous[>) Macros with a TEST Macro (C<]Test[>
\&             or C<]T[> is shorthand):
\&
\&             $result_code = sub {
\&
\&                my $selection=\*(Aq]T[{current_menu_name}\*(Aq; # <\-\- Note the ]T[
\&                if ($selection eq \*(AqReturn to Main Menu\*(Aq)  {
\&
\&                   return \*(Aq{main}<\*(Aq;
\&
\&                } else {
\&
\&                   my %next_menu=(  # "stepchild" menu
\&
\&                      Name => \*(Aqnext_menu\*(Aq,
\&                      Item_1 => {
\&
\&                         Text => \*(Aq]C[\*(Aq,
\&                         Convey => [ ... ],
\&
\&                      },
\&                      Item_2 => { ... },
\&
\&                   );
\&
\&                }
\&
\&             };
\&
\&             The presence of the C<]Test[> macro tells
\&             Term::Menus that it\*(Aqs dealing with stepchild menus,
\&             and not to evaluate them early.
\&
\&             However, there are scenario\*(Aqs where you want to
\&             evaluate on a condition that does not involve a
\&             child or even a step child menu \- but a grandchild
\&             or great grandchild menu, etc. (This can certainly
\&             happen when there is menu re\-use or recursion). In
\&             these situations Term::Menus will invariably
\&             determine there is an error condition (due to the
\&             explicitly named menu missing in the history stack)
\&             when there isn\*(Aqt \- because there is no "obvious"
\&             way for Term::Menus to know that an explicitly named
\&             menu is not yet "supposed" to exist. In these
\&             scenarios the only option will be to suppress the
\&             error message and allow macro expansion to otherwise
\&             continue unabated. To do that, and allow processing
\&             to continue, use a "bang" (or exclamation point)
\&             character in the macro syntax after the starting
\&             bracket:
\&
\&             C<my $selection=\*(Aq]!S[{menu_name}\*(Aq;>
\&
\&             \-\-OR\-\-
\&
\&             C<my $selection=\*(Aq]!T[{menu_name}\*(Aq;> 
\&
\&             Hopefully, one or more of these approaches or
\&             "tricks" will deliver the results you\*(Aqre after.
\&             Whatever works!
.Ve
.Sp
\&\fBNOTE:\fR     if you want to return output from the Result subroutine,
             you must include a 'return' statement. So the sub above:
.Sp
.Vb 1
\&                sub selected { print "\en   SELECTED ITEM = $_[0]\en" }
\&
\&             Becomes:
\&
\&                sub selected { print "\en   SELECTED ITEM = $_[0]\en";return $_[0] }
.Ve
.RE
.RE
.RS 4
.RE
.SH "ANONYMOUS SUBROUTINES AND MACROS"
.IX Header "ANONYMOUS SUBROUTINES AND MACROS"
Term::Menus macros can be used \fIdirectly\fR in the body of \fBanonymous\fR subroutines! Ordinary subroutines can be used as illustrated above of course, but the macro values can only be passed as arguments to ordinary subroutines. This is much more complicated and less intuitive than using macros directly in the code itself. Below is an example of their usage. The author received a request a while back from a user, asking if it was possible to return the item number rather than it's text value. The answer of course is YES! The code below illustrates this:
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my @list=(\*(AqOne\*(Aq,\*(AqTwo\*(Aq,\*(AqThree\*(Aq);
\&
\&   my %Menu_1=(
\&
\&      Item_1 => {
\&
\&         Text    => "NUMBER \- ]Convey[",
\&         Convey  => \e@list,
\&         Result  => sub {
\&                           my $cnt=\-1;my $selection=\*(Aq]Selected[\*(Aq;
\&                           foreach my $item (@list) {
\&                              $cnt++;
\&                              chomp($item);
\&                              last if \-1<index $selection, $item;
\&                           } return "$cnt";
\&                        }
\&                        # Note use of ]Selected[ macro in
\&                        # anonymous subroutine body
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my $selection=Menu(\e%Menu_1);
\&   print "   \enSELECTION = $selection\en";
.Ve
.PP
Anonymous subroutines can be assigned directly to "Item_1" (or Item_2, etc.) elements 'Convey' and 'Result' as well as to the Menu "Banner" element. Use of the these constructs over more traditional subroutines is encouraged because it means writing less code, while enabling the code that is written to be less complex, more intuitive and readable, and certainly easier to maintain. The same anonymous routine can be use in multipe Menus or Items of a single Menu by assigning that routine to a variable, and then assigning the variable instead.
.PP
\&\fBNOTE:\fR   To force a return to a parent menu (assuming there is one) from a subroutine assigned to a Result element, just return '<' from the subroutine. This is extremely useful when there is a desire to process a selection, and then return to the parent menu when processing is complete. To return to any ancestor Menu in the stack, return this macro from the subroutine: \f(CW\*(C`{Menu_Name}<\*(C'\fR :\-)
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my @list=(\*(AqOne\*(Aq,\*(AqTwo\*(Aq,\*(AqThree\*(Aq);
\&
\&   my $result = sub {
\&                       my $cnt=\-1;my $selection=\*(Aq]Selected[\*(Aq;
\&                       foreach my $item (@list) {
\&                          $cnt++;
\&                          chomp($item);
\&                          last if \-1<index $selection, $item;
\&                       } return "$cnt";
\&                    };
\&                    # Anonymous subroutine assigned to "$result" variable
\&
\&   my %Menu_1=(
\&
\&      Item_1 => {
\&
\&         Text    => "NUMBER \- ]Convey[",
\&         Convey  => \e@list,
\&         Result  => $result, # Anonymous subroutine assisned via
\&                             # "$result" variable
\&
\&      },
\&
\&      Select => \*(AqOne\*(Aq,
\&      Banner => "\en   Choose a /bin Utility :"
\&   );
\&
\&   my $selection=Menu(\e%Menu_1);
\&   print "   \enSELECTION = $selection\en";
.Ve
.SH "RECURSIVELY CALLED MENUS"
.IX Header "RECURSIVELY CALLED MENUS"
There are occasions where it is desirable to re-use the same Menu template/hash configuration with dynamically discovered data. One obvious example of this is navigating directory trees. Each subsequent directory selection could potentially contain deeper levels of directories. Essentially, any data structured in any kind of relational tree layout is subject to this kind of navigation approach. Be warned however, unlike most other functionality that is handled almost entirely by the Term::Menus module, the code for doing recursive templating is mostly contained in the template/hash configuration itself. There is a "helper routine" (&get_Menu_map) that Term::Menus provides to assist with the creation of recursively-friendly configurations, but given the highly data-centric characteristics of such functionality, most of the working code must be left to the authoring and management of the user.
.SS &\fBget_Menu_map()\fP
.IX Subsection "&get_Menu_map()"
This is a helper routine that returns a list of ancestor menu results. This is needed when wanting to navigate a directory tree for instance. Imagine a directory path that looks like this: /one/two/three. A call to &\fBget_Menu_map()\fR when processing directory three with return this list: ('one','two').
.Sp
.RS 4
The following code is an example of how to use recursion for navigating a directory tree.
.Sp
.Vb 1
\&   use Term::Menus;
\&
\&   my %dir_menu=(
\&
\&      Name   => \*(Aqdir_menu\*(Aq,
\&      Item_1 => {
\&
\&         Text => "]C[",
\&         Mark => "d",
\&         Convey => sub {
\&
\&            if ("]P[") {
\&
\&               my $dir="]P[";
\&               if ($^O eq \*(Aqcygwin\*(Aq) {
\&                  $dir=\*(Aq/cygdrive/c/\*(Aq;
\&               } else {
\&                  $dir=\*(Aq/\*(Aq;
\&               }
\&               my @xfiles=();
\&               my @return=();
\&               my @map=get_Menu_map;
\&               my $path=join "/", @map;
\&               opendir(DIR,"$dir$path") || die $!;
\&               @xfiles = readdir(DIR);
\&               closedir(DIR);
\&               foreach my $entry (sort @xfiles) {
\&                  next if $entry eq \*(Aq.\*(Aq;
\&                  next if $entry eq \*(Aq..\*(Aq;
\&                  if (\-1<$#map) {
\&                     next unless \-d "$dir$path/$entry";
\&                  } else {
\&                     next unless \-d "$dir/$entry";
\&                  }
\&                  push @return, "$entry";
\&               }
\&               return @return;
\&
\&            }
\&            my @xfiles=();
\&            my @return=();
\&            if ($^O eq \*(Aqcygwin\*(Aq) {
\&               opendir(DIR,\*(Aq/cygdrive/c/\*(Aq) || die $!;
\&            } else {
\&               opendir(DIR,\*(Aq/\*(Aq) || die $!;
\&            }
\&            @xfiles = readdir(DIR);
\&            closedir(DIR);
\&            foreach my $entry (@xfiles) {
\&               next if $entry eq \*(Aq.\*(Aq;
\&               next if $entry eq \*(Aq..\*(Aq;
\&               next unless \-d "$entry";
\&               push @return, "$entry";
\&            }
\&            return @return;
\&
\&         },
\&         Result => { \*(Aqdir_menu\*(Aq=>\*(Aqrecurse\*(Aq },
\&
\&      },
\&      Item_2 => {
\&
\&         Text => "]C[",
\&         Select => \*(AqMany\*(Aq,
\&         Convey => sub {
\&
\&            if ("]P[") {
\&
\&               my $dir="]P[";
\&               if ($^O eq \*(Aqcygwin\*(Aq) {
\&                  $dir=\*(Aq/cygdrive/c/\*(Aq;
\&               } else {
\&                  $dir=\*(Aq/\*(Aq;
\&               }
\&
\&               my @xfiles=();
\&               my @return=();
\&               my @map=get_Menu_map;
\&               my $path=join "/", @map;
\&               opendir(DIR,"$dir/$path") || die $!;
\&               @xfiles = readdir(DIR);
\&               closedir(DIR);
\&               foreach my $entry (sort @xfiles) {
\&                  next if $entry eq \*(Aq.\*(Aq;
\&                  next if $entry eq \*(Aq..\*(Aq;
\&                  if (\-1<$#map) {
\&                     next if \-d "$dir/$path/$entry";
\&                  } else {
\&                     next if \-d "$dir/$entry";
\&                  }
\&                  push @return, "$entry";
\&               }
\&               return @return;
\&
\&            }
\&            my @xfiles=();
\&            my @return=();
\&            if ($^O eq \*(Aqcygwin\*(Aq) {
\&               opendir(DIR,\*(Aq/cygdrive/c/\*(Aq) || die $!;
\&            } else {
\&               opendir(DIR,\*(Aq/\*(Aq) || die $!;
\&            }
\&            @xfiles = readdir(DIR);
\&            closedir(DIR);
\&            foreach my $entry (@xfiles) {
\&               next if $entry eq \*(Aq.\*(Aq;
\&               next if $entry eq \*(Aq..\*(Aq;
\&               next if \-d "$entry";
\&               push @return, "$entry";
\&            }
\&            return @return;
\&
\&         },
\&      },
\&      Banner => "   Current Directory: ]P[\en",
\&
\&   );
\&
\&   my $selection=Menu(\e%dir_menu);
\&
\&   if (ref $selection eq \*(AqARRAY\*(Aq) {
\&      print "\enSELECTION=",(join " ",@{$selection}),"\en";
\&   } else {
\&      print "\enSELECTION=$selection\en";
\&   }
.Ve
.RE
.SH FORMS
.IX Header "FORMS"
With Term::Menus, you can now create CMD and Terminal environment input forms.
Below is an example of a form that works with the program "figlet":
.PP
.Vb 8
\&   \*(Aq########:\*(Aq##::::\*(Aq##::::\*(Aq###::::\*(Aq##::::\*(Aq##:\*(Aq########::\*(Aq##:::::::\*(Aq########:
\&    ##.....::. ##::\*(Aq##::::\*(Aq## ##::: ###::\*(Aq###: ##.... ##: ##::::::: ##.....::
\&    ##::::::::. ##\*(Aq##::::\*(Aq##:. ##:: ####\*(Aq####: ##:::: ##: ##::::::: ##:::::::
\&    ######:::::. ###::::\*(Aq##:::. ##: ## ### ##: ########:: ##::::::: ######:::
\&    ##...:::::: ## ##::: #########: ##. #: ##: ##.....::: ##::::::: ##...::::
\&    ##:::::::: ##:. ##:: ##.... ##: ##:.:: ##: ##:::::::: ##::::::: ##:::::::
\&    ########: ##:::. ##: ##:::: ##: ##:::: ##: ##:::::::: ########: ########:
\&   ........::..:::::..::..:::::..::..:::::..::..:::::::::........::........::
\&
\&   ========================================
\&   [ EXAMPLE                              ]  banner3\-D  font
\&   ========================================
\&
\&   The box above is an input box. The [DEL] key will clear the contents.
\&   Type anything you like, and it will appear in the banner3\-D FIGlet font!
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   Press ENTER when finished
.Ve
.PP
In this example, input typed in the input field, immediately appears in the
output field in the figlet font "banner3\-D". Here is the code for this example:
.PP
.Vb 10
\&      use Term::Menus;
\&      my $path=\*(Aq/usr/share/figlet\*(Aq;
\&      opendir(my $dh, $path) || die "can\*(Aqt opendir $path: $!";
\&      while (my $file=readdir($dh)) {
\&         chomp($file);
\&         next unless $file=~s/.flf$//;
\&         push @figletfonts,$file;
\&      }
\&      my $figlet=\*(Aq/usr/bin/\*(Aq;
\&      my $figban=\`${figlet}figlet \-f small "FIGlet   Fonts"\`;
\&      $figban=~s/^/   /mg;
\&      $figban="\en\en$figban   ".
\&         "Choose a FIGlet Font (by number) to preview with text \e"Example\e"".
\&         "\en   \-OR\- continuously scroll and view by repeatedly pressing ENTER".
\&         "\en\en   HINT: Typing  !figlet \-f<fontname> YOUR TEXT\en\en".
\&         "         is another way to preview the font of your choice.\en\en";
\&
\&      $main::figletoutput=sub {
\&
\&         return \`figlet \-f ]P[{figmenu} $_[0]\`;
\&
\&      };
\&
\&      my $figlet_banner=<<END;
\&
\&      ]O[{1,\*(Aqfigletoutput\*(Aq}
\&
\&
\&                           ]P[{figmenu}  font
\&      ]I[{1,\*(AqExample\*(Aq,40}
\&
\&      The box above is an input box. The [DEL] key will clear the contents.
\&      Type anything you like, and it will appear in the ]P[{figmenu} FIGlet font!
\&
\&   END
\&   # ^ Be sure the END is at the margin (no spaces from edge)
\&
\&      my %figletoutput=(
\&
\&         Name   => \*(Aqfigletoutput\*(Aq,
\&         Result => sub { return \*(Aq{figmenu}<\*(Aq },
\&         Input  => 1,
\&         Banner => $figlet_banner,
\&
\&      );
\&
\&      my %figmenu=(
\&
\&         Name => \*(Aqfigmenu\*(Aq,
\&         Item_1 => {
\&
\&            Text    => \*(Aq]C[\*(Aq,
\&            Convey  => \e@figletfonts,
\&            Result  => \e%figletoutput,
\&
\&         },
\&         Display => 8,
\&         Scroll => 1,
\&         Banner => $figban,
\&
\&      );
\&      my $selection=Menu(\e%figmenu);
.Ve
.PP
Any number of input fields can be added to a form page, and navigation among
 fields is accomplished using the TAB key (as you would use in most GUI applications).
.PP
.Vb 1
\&   Term::Menus FORM \- 3 input fields:
\&
\&                      ========================================
\&   Name               [                                      ]
\&                      ========================================
\&                      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   Street Address     |                                      |
\&                      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-
\&   City, State        |                               | |    |
\&                      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-
\&                      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   Zip Code, Phone    |              | |                     |
\&                      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   Press ENTER when finished
.Ve
.PP
Note how the first field has a thicker border than the other two. This means this
field is "highlighted" and is the one chosen for entry. The following keys have
special behavior:
.PP
.Vb 1
\&   [DEL]        ==>  Clears the selected input field entirely
\&
\&   [BACKSPACE]  ==>  Deletes one character at time going backwards
\&
\&   [TAB]        ==>  Navigates among input fields
\&
\&   [ENTER]      ==>  Submits entire form
.Ve
.SS "Form Assembly"
.IX Subsection "Form Assembly"
Form syntax is used in the \f(CW\*(C`Banner\*(C'\fR that is fed to \f(CW&Menu()\fR via the Menu
Configuration Hash Structure. This is the code for the input fields above:
.PP
.Vb 1
\&   use Term::Menus;
\&
\&   my $input_fields_banner.=<<END;
\&
\&   my @default_input=(\*(Aq\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq);
\&
\&   Term::Menus FORM \- 6 input fields:
\&
\&
\&   Name
\&                      ]I[{1,$default_input[0],40}
\&
\&   Street Address
\&                      ]I[{2,$default_input[1],40}
\&
\&   City, State
\&                      ]I[{3,$default_input[2],33} ]I[{4,$default_input[3],6}
\&
\&   Zip Code, Phone
\&                      ]I[{5,$default_input[4],16} ]I[{6,$default_input[5],23}
.Ve
.PP
END
   my \f(CW$input_example\fR={
.PP
.Vb 9
\&      Name => \*(Aqinput_example\*(Aq,
\&      Input => 1,
\&      Banner => $input_fields_banner,
\&      Result => sub { return "]I[{\*(Aqinput_example\*(Aq,1}",
\&                             "]I[{\*(Aqinput_example\*(Aq,2}",
\&                             "]I[{\*(Aqinput_example\*(Aq,3}",
\&                             "]I[{\*(Aqinput_example\*(Aq,4}",
\&                             "]I[{\*(Aqinput_example\*(Aq,5}",
\&                             "]I[{\*(Aqinput_example\*(Aq,6}"  },
\&
\&   };
\&
\&   my @output=Menu($input_example);
\&   print "\en   OUTPUT=@output\en";
.Ve
.PP
\fIInput Macro \-> Banner\fR
.IX Subsection "Input Macro -> Banner"
.PP
The Input Macro syntax for Banner is as follows:
.PP
.Vb 1
\&   ]I[{<identity_number>,\*(Aq<default_input>\*(Aq,<length_of_input_box>}
.Ve
.PP
*NOTE* => Be sure you have a RESULT \f(CW\*(C`]I[\*(C'\fR macro for every BANNER \f(CW\*(C`]I[\*(C'\fR macro you use!
.PP
\fIInput Macro \-> Result\fR
.IX Subsection "Input Macro -> Result"
.PP
The Input Macro syntax for Result is as follows:
.PP
.Vb 1
\&   ]I[{\*(Aq<menu_name>\*(Aq,\*(Aq<identity_number>\*(Aq}
.Ve
.PP
\fIOutput Macro \-> Banner\fR
.IX Subsection "Output Macro -> Banner"
.PP
The Output Macro syntax for Banner is as follows:
.PP
.Vb 1
\&   ]O[{<identity_number>,\*(Aq<name_of_method_to_operate_on_character_input>\*(Aq}
.Ve
.SH "USAGE and NAVIGATION"
.IX Header "USAGE and NAVIGATION"
Usage of \f(CW&pick()\fR and/or \f(CW&Menu()\fR during the runtime of a script in which
one or both are included, is simple and intuitive. Nearly everything the end
user needs in terms of instruction is included on-screen. The
script\-writer/developer/programmer can also include whatever instructions s/he
deems necessary and/or helpful in the customizable \f(CW\*(C`Banner\*(C'\fR (as described
above). There is however, one important feature about using \f(CW&Menu()\fR with
sub-menus that's important to know about.
.SS "Forward  ' \fB>\fP ' and  Backward  ' \fB<\fP ' Navigation"
.IX Subsection "Forward ' > ' and Backward ' < ' Navigation"
When working with more than one \f(CW&Menu()\fR screen, it's valuable to know how
to navigate back and forth between the different \f(CW&Menu()\fR levels/layers.  For
example, above was illustrated the output for two layers of menus \- a parent
and a child:
.Sp
.RS 4
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&      1.        /bin Utility \- arch
\&      2.        /bin Utility \- ash
\&      3.        /bin Utility \- awk
\&      4.        /bin Utility \- basename
\&      5.        /bin Utility \- bash
\&      6.        /bin Utility \- cat
\&      7.        /bin Utility \- chgrp
\&      8.        /bin Utility \- chmod
\&      9.        /bin Utility \- chown
\&      10.       /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< 5 >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose an Answer :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
In the above example, suppose that the user "fat-fingered" his/her
choice, and really didn't want to "bash" bash, but wanted to bash
awk instead. Is restarting the whole script/application now necessary?
Suppose it was a process that had run overnight, and the user is seeing
this menu through fogged glasses from the steam rising out of their
morning coffee? Having to run the whole job again would not be welcome news
for the BOSS. THANKFULLY, navigation makes this situation avoidable.
All the user would have to do is type ' \fB<\fR ' to go backward to the
previous menu, and ' \fB>\fR ' to go forward to the next menu (assuming there
is one in each case):
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose an Answer :
\&
\&       1      bash is a Good Utility
\&       2      bash is a Bad Utility
\&
\&   (Press [F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
\&
\& \-\-<  >  >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1      /bin Utility \- arch
\&       2      /bin Utility \- ash
\&       3      /bin Utility \- awk
\&       4      /bin Utility \- basename
\&    \-  5      /bin Utility \- bash
\&       6      /bin Utility \- cat
\&       7      /bin Utility \- chgrp
\&       8      /bin Utility \- chmod
\&       9      /bin Utility \- chown
\&       10     /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
Note in the above example the Dash ' \fB\-\fR ' in front of item \fB5.\fR This informs
the user that s/he had previously selected this item. To clear the selection,
the user would simply choose item \fB5\fR again. This effectively deletes the
previous choice and restores the menu for a new selection. If the user was
satisfied with the choice, and was simply double checking thier selection, they
simply repeat the navigation process by typing ' \fB>\fR ' \- then <ENTER>
\&\-
and returning to the child menu they left.
.Sp
If the child menu was a \fImultiple-selection\fR menu, and the user had made some
selections before navigating back to the parent menu, the user would see a
\&' \fB+\fR ' rather than a ' \fB\-\fR '. This informs the user that selections were
made in the child menu.
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&      1.        /bin Utility \- arch
\&      2.        /bin Utility \- ash
\&      3.        /bin Utility \- awk
\&      4.        /bin Utility \- basename
\&   +  5.        /bin Utility \- bash
\&      6.        /bin Utility \- cat
\&      7.        /bin Utility \- chgrp
\&      8.        /bin Utility \- chmod
\&      9.        /bin Utility \- chown
\&      10.       /bin Utility \- cp
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                       _\|_\|_
\&   93 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.RE
.SS "View Sorted Items ' \fB%\fP '"
.IX Subsection "View Sorted Items ' % '"
When working with numerous items in a single menu, it may be desirable to see
the set of choices organized in either descending or reverse acscii order.
Term::Menus provides this feature with the \fIPercent\fR ' \fB%\fR ' key.  Simply
type ' \fB%\fR ' and the items will be sorted in descending ascii order. Type
\&' \fB%\fR ' again, and you will see the items reverse sorted. Assume that we have
the following menus.
.Sp
.RS 4
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&    *  1      [.exe
\&    *  2      2to3
\&       3      2to3\-3.2
\&    *  4      411toppm.exe
\&       5      a2p.exe
\&       6      aaflip.exe
\&       7      aclocal
\&    *  8      aclocal\-1.10
\&       9      aclocal\-1.11
\&    *  10     aclocal\-1.12
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                         _\|_\|_
\&   1925 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< % >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&   *  2.        2to3
\&      3.        2to3\-3.2
\&   *  4.        411toppm.exe
\&      759.      FvwmCommand.exe
\&      1650.     Ted.exe
\&      1782.     WPrefs.exe
\&      1785.     X
\&      1889.     XWin.exe
\&      1808.     Xdmx.exe
\&      1815.     Xephyr.exe
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&
\&   (Type \*(Aq<\*(Aq to return to previous Menu)
\&                          _\|_\|_
\&   1925  Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
And if we choose to enter ' \fB%\fR ' \fIagain\fR
.Sp
\&\-\-< % >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&       1925     znew
\&       1924     zmore
\&       1923     zless
\&       1922     zipsplit.exe
\&       1921     zipnote.exe
\&       1920     zipinfo.exe
\&       1919     zipgrep
\&       1918     zipcloak.exe
\&       1917     zip.exe
\&       1916     zgrep
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&
\&   (Type \*(Aq<\*(Aq to return to previous Menu)
\&                         _\|_\|_
\&   1925 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP 
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
This submenu of sorted selections works just like any other menu. The user can
deselect an item, clear all items, re-choose all items, etc. The choices made
here are preserved when the user navigates back to the original (parent)
menu. In other words, if Item 1. is deselected in the sorted menu, Item 1.
will also be deselected in the parent menu. Navigating back to the
parent is necessary \- the menu will not generate results from a sort menu.
Use either the \fBLEFTARROW\fR ' \fB<\fR ' key or FINISH key ' \fBF\fR or \fBf\fR ' to
return to the parent menu, and then continue your menu activities there.
.RE
.SS "View Summary of Selected Items ' \fB*\fP '"
.IX Subsection "View Summary of Selected Items ' * '"
When working with numerous items in a single menu, it is desirable to see the
set of choices made before leaving the menu and committing to a non-returnable
forward (perhaps even critical) process. Term::Menus provides this feature
with the \fIStar\fR ' \fB*\fR ' key. Assume we have the following menu with 93 Total
Choices. Assume further that we have selected items 1,3,9 & 11. Note that we
cannot see Item 11 on the first screen since this menu is configured to show
only 10 Items at a time.
.Sp
.RS 4
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&    *  1      [.exe
\&       2      2to3
\&    *  3      2to3\-3.2
\&       4      411toppm.exe
\&       5      a2p.exe
\&       6      aaflip.exe
\&       7      aclocal
\&       8      aclocal\-1.10
\&    *  9      aclocal\-1.11
\&       10     aclocal\-1.12
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                         _\|_\|_
\&   1925 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< * >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&    *  1      [.exe
\&    *  3      2to3\-3.2
\&    *  9      aclocal\-1.11
\&    *  11     aclocal\-1.13
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&
\&   (Type \*(Aq<\*(Aq to return to previous Menu)
\&
\&   ([F1] for HELP)
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
This submenu of summary selections works just like any other menu. The user 
can deselect an item, clear all items, re-choose all items, etc. The choices
made here are preserved when the user navigates back to the original (parent)
menu. In other words, if Item 1. is deselected in the summary menu, Item 1.
will also be deselected in the parent menu. Navigating back to the
parent is necessary \- the menu will not generate results from a summary menu.
Use either the \fBLEFTARROW\fR ' \fB<\fR ' key or FINISH key ' \fBF\fR or \fBf\fR ' to
return to the parent menu, and then continue your menu activities there.
.RE
.SS "Shell Out to Command Environment ' \fB!\fP\fIcommand\fP '"
.IX Subsection "Shell Out to Command Environment ' !command '"
Borrowed from the editor vi, users can run any command environment command
(typically a shell command) without leaving their Term::Menus session or even
context. At anytime, a user can type an exclamation point ' \fB!\fR ' followed
by the command they wish to run, and that command will be run and the results
returned for viewing.
.Sp
.RS 4
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&    *  1      [.exe
\&       2      2to3
\&    *  3      2to3\-3.2
\&       4      411toppm.exe
\&       5      a2p.exe
\&       6      aaflip.exe
\&       7      aclocal
\&       8      aclocal\-1.10
\&    *  9      aclocal\-1.11
\&       10     aclocal\-1.12
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                         _\|_\|_
\&   1925 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
\&\-\-< !hostname >\-<ENTER>\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Sp
The user sees ==>
.Sp
.Vb 1
\&   Choose a /bin Utility :
\&
\&    *  1      [.exe
\&       2      2to3
\&    *  3      2to3\-3.2
\&       4      411toppm.exe
\&       5      a2p.exe
\&       6      aaflip.exe
\&       7      aclocal
\&       8      aclocal\-1.10
\&    *  9      aclocal\-1.11
\&       10     aclocal\-1.12
\&
\&   a.  Select All   c.  Clear All   f.  FINISH
\&                         _\|_\|_
\&   1925 Total Choices   |_v_| Scroll with ARROW keys   [F1] for HELP
\&
\&   ([ESC] to Quit)   PLEASE ENTER A CHOICE:
.Ve
.Sp
central_server
.Sp
Press ENTER to continue
.RE
.SH AUTHOR
.IX Header "AUTHOR"
Brian M. Kelly <Brian.Kelly@fullautosoftware.net>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (C) 2000\-2024
by Brian M. Kelly.
.PP
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU Affero General Public License.
(http://www.gnu.org/licenses/agpl.html).
