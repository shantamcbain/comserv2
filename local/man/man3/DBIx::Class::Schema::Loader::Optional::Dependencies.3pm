.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::Loader::Optional::Dependencies 3pm"
.TH DBIx::Class::Schema::Loader::Optional::Dependencies 3pm 2024-01-06 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
$class \- Optional module dependency specifications (for module authors)
EOC
.PP
#@@
#@@ SYNOPSIS HEADING
#@@
  push @chunks, <<"EOC";
=head1 SYNOPSIS
.PP
Somewhere in your build\-file (e.g. ExtUtils::MakeMaker's Makefile.PL):
.PP
.Vb 1
\&  ...
\&
\&  \e$EUMM_ARGS{CONFIGURE_REQUIRES} = {
\&    \e%{ \e$EUMM_ARGS{CONFIGURE_REQUIRES} || {} },
\&    \*(AqDBIx::Class::Schema::Loader\*(Aq => \*(Aq$distver\*(Aq,
\&  };
\&
\&  ...
\&
\&  my %DBIC_CONFIG_AND_ORACLE_DEPS = %{ eval {
\&    require $class;
\&    $class\->req_list_for([qw( dbicdump_config rdbms_oracle )]);
\&  } || {} };
\&
\&  \e$EUMM_ARGS{PREREQ_PM} = {
\&    \e%DBIC_CONFIG_AND_ORACLE_DEPS,
\&    \e%{ \e$EUMM_ARGS{PREREQ_PM} || {} },
\&  };
\&
\&  ...
\&
\&  ExtUtils::MakeMaker::WriteMakefile(\e%EUMM_ARGS);
.Ve
.PP
\&\fBNote\fR: The \f(CW\*(C`eval\*(C'\fR protection within the example is due to support for
requirements during the \f(CW\*(C`configure\*(C'\fR build phase
not being available on a sufficient portion of production installations of
Perl. Robust support for such dependency requirements is available in the
CPAN installer only since version \f(CW\*(C`1.94_56\*(C'\fR first made available for
production with perl version \f(CW5.12\fR. It is the belief of the current
maintainer that support for requirements during the \f(CW\*(C`configure\*(C'\fR build phase
will not be sufficiently ubiquitous until the \fByear 2020\fR at the earliest,
hence the extra care demonstrated above. It should also be noted that some
3rd party installers (e.g. cpanminus) do the right thing
with configure requirements independent from the versions of perl and CPAN
available.
EOC
.PP
#@@
#@@ DESCRIPTION HEADING
#@@
  push \f(CW@chunks\fR, <<'EOC';
=head1 DESCRIPTION
.PP
Some of the less-frequently used features of DBIx::Class::Schema::Loader have external
module dependencies on their own. In order not to burden the average user
with modules they will never use, these optional dependencies are not included
in the base Makefile.PL. Instead an exception with a descriptive message is
thrown when a specific feature can't find one or several modules required for
its operation. This module is the central holding place for the current list
of such dependencies, for DBIx::Class::Schema::Loader core authors, and DBIx::Class::Schema::Loader extension
authors alike.
.PP
Dependencies are organized in groups where each
group can list one or more required modules, with an optional minimum version
(or 0 for any version). In addition groups prefixed with \f(CW\*(C`test_\*(C'\fR can specify
a set of environment variables, some (or all) of which are marked as required
for the group to be considered by "req_list_for"
.PP
Each group name (or a combination thereof) can be used in the
public methods as described below.
EOC
.PP
#@@
#@@ REQUIREMENT GROUPLIST HEADING
#@@
  push \f(CW@chunks\fR, '=head1 CURRENT REQUIREMENT GROUPS';
.PP
.Vb 1
\&  my $standalone_info;
\&
\&  for my $group (sort keys %$dbic_reqs) {
\&
\&    my $info = $standalone_info\->{$group} ||= $class\->_groups_to_reqs($group);
\&
\&    next unless (
\&      $info\->{modreqs_fully_documented}
\&        and
\&      ( $info\->{augments} or $info\->{modreqs} )
\&    );
\&
\&    my $p = $dbic_reqs\->{$group}{pod};
\&
\&    push @chunks, (
\&      "=head2 $p\->{title}",
\&      "=head3 $group",
\&      $p\->{desc},
\&      \*(Aq=over\*(Aq,
\&    );
\&
\&    if ( keys %{ $info\->{modreqs}||{} } ) {
\&      push @chunks, map
\&        { "=item * $_" . ($info\->{modreqs}{$_} ? " >= $info\->{modreqs}{$_}" : \*(Aq\*(Aq) }
\&        ( sort keys %{ $info\->{modreqs} } )
\&      ;
\&    }
\&    else {
\&      push @chunks, \*(Aq=item * No standalone requirements\*(Aq,
\&    }
\&
\&    push @chunks, \*(Aq=back\*(Aq;
\&
\&    for my $ag ( sort keys %{ $info\->{augments} || {} } ) {
\&      my $ag_info = $standalone_info\->{$ag} ||= $class\->_groups_to_reqs($ag);
\&
\&      my $newreqs = $class\->modreq_list_for([ $group, $ag ]);
\&      for (keys %$newreqs) {
\&        delete $newreqs\->{$_} if (
\&          ( defined $info\->{modreqs}{$_}    and $info\->{modreqs}{$_}    == $newreqs\->{$_} )
\&            or
\&          ( defined $ag_info\->{modreqs}{$_} and $ag_info\->{modreqs}{$_} == $newreqs\->{$_} )
\&        );
\&      }
\&
\&      if (keys %$newreqs) {
\&        push @chunks, (
\&          "Combined with L</$ag> additionally requires:",
\&          \*(Aq=over\*(Aq,
\&          ( map
\&            { "=item * $_" . ($newreqs\->{$_} ? " >= $newreqs\->{$_}" : \*(Aq\*(Aq) }
\&            ( sort keys %$newreqs )
\&          ),
\&          \*(Aq=back\*(Aq,
\&        );
\&      }
\&    }
\&  }
.Ve
.PP
#@@
#@@ API DOCUMENTATION HEADING
#@@
  push \f(CW@chunks\fR, <<'EOC';
.SH "IMPORT-LIKE ACTIONS"
.IX Header "IMPORT-LIKE ACTIONS"
Even though this module is not an Exporter, it recognizes several \f(CW\*(C`actions\*(C'\fR
supplied to its \f(CW\*(C`import\*(C'\fR method.
.SS \-skip_all_without
.IX Subsection "-skip_all_without"
.ie n .IP "Arguments: @group_names" 4
.el .IP "Arguments: \f(CW@group_names\fR" 4
.IX Item "Arguments: @group_names"
.PP
A convenience wrapper for use during testing:
EOC
.PP
.Vb 1
\&  push @chunks, " use $class \-skip_all_without => qw(admin test_rdbms_mysql);";
\&
\&  push @chunks, \*(AqRoughly equivalent to the following code:\*(Aq;
\&
\&  push @chunks, sprintf <<\*(AqEOS\*(Aq, ($class) x 2;
\&
\& BEGIN {
\&   require %s;
\&   if ( my $missing = %s\->req_missing_for(\e@group_names_) ) {
\&     print "1..0 # SKIP requirements not satisfied: $missing\en";
\&     exit 0;
\&   }
\& }
\&EOS
\&
\&  push @chunks, <<\*(AqEOC\*(Aq;
.Ve
.PP
It also takes into account the \f(CW\*(C`RELEASE_TESTING\*(C'\fR environment variable and
behaves like "\-die_without" for any requirement groups marked as
\&\f(CW\*(C`release_testing_mandatory\*(C'\fR.
.SS \-die_without
.IX Subsection "-die_without"
.ie n .IP "Arguments: @group_names" 4
.el .IP "Arguments: \f(CW@group_names\fR" 4
.IX Item "Arguments: @group_names"
.PP
A convenience wrapper around "die_unless_req_ok_for":
EOC
.PP
.Vb 1
\&  push @chunks, " use $class \-die_without => qw(deploy admin);";
\&
\&  push @chunks, <<\*(AqEOC\*(Aq;
.Ve
.SS \-list_missing
.IX Subsection "-list_missing"
.ie n .IP "Arguments: @group_names" 4
.el .IP "Arguments: \f(CW@group_names\fR" 4
.IX Item "Arguments: @group_names"
.PP
A convenience wrapper around "modreq_missing_for":
.PP
.Vb 1
\& perl \-Ilib \-MDBIx::Class::Schema::Loader::Optional::Dependencies=\-list_missing,dbicdump_config,rdbms_oracle | cpanm
.Ve
.SH METHODS
.IX Header "METHODS"
.SS req_group_list
.IX Subsection "req_group_list"
.IP "Arguments: none" 4
.IX Item "Arguments: none"
.PD 0
.IP "Return Value: \e%list_of_requirement_groups" 4
.IX Item "Return Value: %list_of_requirement_groups"
.PD
.PP
This method should be used by DBIx::Class::Schema::Loader packagers, to get a hashref of all
dependencies \fBkeyed\fR by dependency group. Each key (group name), or a combination
thereof (as an arrayref) can be supplied to the methods below.
The \fBvalues\fR of the returned hash are currently a set of options \fBwithout a
well defined structure\fR. If you have use for any of the contents \- contact the
maintainers, instead of treating this as public (left alone stable) API.
.SS req_list_for
.IX Subsection "req_list_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PD 0
.IP "Return Value: \e%set_of_module_version_pairs" 4
.IX Item "Return Value: %set_of_module_version_pairs"
.PD
.PP
This method should be used by DBIx::Class::Schema::Loader extension authors, to determine the
version of modules a specific set of features requires for this version of
DBIx::Class::Schema::Loader (regardless of their availability on the system).
See the "SYNOPSIS" for a real-world example.
.PP
When handling \f(CW\*(C`test_*\*(C'\fR groups this method behaves \fBdifferently\fR from
"modreq_list_for" below (and is the only such inconsistency among the
\&\f(CW\*(C`req_*\*(C'\fR methods). If a particular group declares as requirements some
\&\f(CW\*(C`environment variables\*(C'\fR and these requirements are not satisfied (the envvars
are unset) \- then the \f(CW\*(C`module requirements\*(C'\fR of this group are not included in
the returned list.
.SS modreq_list_for
.IX Subsection "modreq_list_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PD 0
.IP "Return Value: \e%set_of_module_version_pairs" 4
.IX Item "Return Value: %set_of_module_version_pairs"
.PD
.PP
Same as "req_list_for" but does not take into consideration any
\&\f(CW\*(C`environment variable requirements\*(C'\fR \- returns just the list of required
modules.
.SS req_ok_for
.IX Subsection "req_ok_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PD 0
.IP "Return Value: 1|0" 4
.IX Item "Return Value: 1|0"
.PD
.PP
Returns true or false depending on whether all modules/envvars required by
the group(s) are loadable/set on the system.
.SS req_missing_for
.IX Subsection "req_missing_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PD 0
.ie n .IP "Return Value: $error_message_string" 4
.el .IP "Return Value: \f(CW$error_message_string\fR" 4
.IX Item "Return Value: $error_message_string"
.PD
.PP
Returns a single-line string suitable for inclusion in larger error messages.
This method would normally be used by DBIx::Class::Schema::Loader core features, to indicate to
the user that they need to install specific modules and/or set specific
environment variables before being able to use a specific feature set.
.PP
For example if some of the requirements for \f(CW\*(C`deploy\*(C'\fR are not available,
the returned string could look like:
EOC
.PP
.Vb 1
\&  push @chunks, qq{ "Moose~$moosever" (see $class documentation for details)};
\&
\&  push @chunks, <<\*(AqEOC\*(Aq;
\&The author is expected to prepend the necessary text to this message before
\&returning the actual error seen by the user. See also L</modreq_missing_for>
.Ve
.SS modreq_missing_for
.IX Subsection "modreq_missing_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PD 0
.ie n .IP "Return Value: $error_message_string" 4
.el .IP "Return Value: \f(CW$error_message_string\fR" 4
.IX Item "Return Value: $error_message_string"
.PD
.PP
Same as "req_missing_for" except that the error string is guaranteed to be
either empty, or contain a set of module requirement specifications suitable
for piping to e.g. cpanminus. The method explicitly does not
attempt to validate the state of required environment variables (if any).
.PP
For instance if some of the requirements for \f(CW\*(C`deploy\*(C'\fR are not available,
the returned string could look like:
EOC
.PP
.Vb 1
\&  push @chunks, qq{ "Moose~$moosever"};
\&
\&  push @chunks, <<\*(AqEOC\*(Aq;
.Ve
.PP
See also "\-list_missing".
.SS skip_without
.IX Subsection "skip_without"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PP
A convenience wrapper around skip. It does not take neither
a reason (it is generated by "req_missing_for") nor an amount of skipped tests
(it is always \f(CW1\fR, thus mandating unconditional use of
done_testing). Most useful in combination with ad hoc
requirement specifications:
EOC
.PP
.Vb 3
\&  push @chunks, <<EOC;
\&  SKIP: {
\&    $class\->skip_without([ deploy YAML>=0.90 ]);
\&
\&    ...
\&  }
\&EOC
\&
\&  push @chunks, <<\*(AqEOC\*(Aq;
.Ve
.SS die_unless_req_ok_for
.IX Subsection "die_unless_req_ok_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PP
Checks if "req_ok_for" passes for the supplied group(s), and
in case of failure throws an exception including the information
from "req_missing_for". See also "\-die_without".
.SS modreq_errorlist_for
.IX Subsection "modreq_errorlist_for"
.ie n .IP "Arguments: $group_name | \e@group_names" 4
.el .IP "Arguments: \f(CW$group_name\fR | \e@group_names" 4
.IX Item "Arguments: $group_name | @group_names"
.PD 0
.IP "Return Value: \e%set_of_loaderrors_per_module" 4
.IX Item "Return Value: %set_of_loaderrors_per_module"
.PD
.PP
Returns a hashref containing the actual errors that occurred while attempting
to load each module in the requirement group(s).
.SS req_errorlist_for
.IX Subsection "req_errorlist_for"
Deprecated method name, equivalent (via proxy) to "modreq_errorlist_for".
.PP
EOC
.PP
#@@
#@@ FOOTER
#@@
  push \f(CW@chunks\fR, <<'EOC';
=head1 FURTHER QUESTIONS?
.PP
Check the list of additional DBIC resources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This module is free software copyright
by the DBIx::Class::Schema::Loader (DBICSL) authors.
You can redistribute it and/or modify it under the same terms as the
DBIx::Class::Schema::Loader library.
EOC
.PP
.Vb 7
\&  eval {
\&    open (my $fh, \*(Aq>\*(Aq, $podfn) or die;
\&    print $fh join ("\en\en", @chunks) or die;
\&    print $fh "\en" or die;
\&    close ($fh) or die;
\&  } or croak( "Unable to write $podfn: " . ( $! || $@ || \*(Aqunknown error\*(Aq) );
\&}
.Ve
.PP
1;
