.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DateTime::SpanSet 3pm"
.TH DateTime::SpanSet 3pm 2025-03-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DateTime::SpanSet \- set of DateTime spans
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    $spanset = DateTime::SpanSet\->from_spans( spans => [ $dt_span, $dt_span ] );
\&
\&    $set = $spanset\->union( $set2 );         # like "OR", "insert", "both"
\&    $set = $spanset\->complement( $set2 );    # like "delete", "remove"
\&    $set = $spanset\->intersection( $set2 );  # like "AND", "while"
\&    $set = $spanset\->complement;             # like "NOT", "negate", "invert"
\&
\&    if ( $spanset\->intersects( $set2 ) ) { ...  # like "touches", "interferes"
\&    if ( $spanset\->contains( $set2 ) ) { ...    # like "is\-fully\-inside"
\&
\&    # data extraction 
\&    $date = $spanset\->min;           # first date of the set
\&    $date = $spanset\->max;           # last date of the set
\&
\&    $iter = $spanset\->iterator;
\&    while ( $dt = $iter\->next ) {
\&        # $dt is a DateTime::Span
\&        print $dt\->start\->ymd;   # first date of span
\&        print $dt\->end\->ymd;     # last date of span
\&    };
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\f(CW\*(C`DateTime::SpanSet\*(C'\fR is a class that represents sets of datetime
spans.  An example would be a recurring meeting that occurs from
13:00\-15:00 every Friday.
.PP
This is different from a \f(CW\*(C`DateTime::Set\*(C'\fR, which is made of individual
datetime points as opposed to ranges.
.SH METHODS
.IX Header "METHODS"
.IP \(bu 4
from_spans
.Sp
Creates a new span set from one or more \f(CW\*(C`DateTime::Span\*(C'\fR objects.
.Sp
.Vb 1
\&   $spanset = DateTime::SpanSet\->from_spans( spans => [ $dt_span ] );
.Ve
.IP \(bu 4
from_set_and_duration
.Sp
Creates a new span set from one or more \f(CW\*(C`DateTime::Set\*(C'\fR objects and a
duration.
.Sp
The duration can be a \f(CW\*(C`DateTime::Duration\*(C'\fR object, or the parameters
to create a new \f(CW\*(C`DateTime::Duration\*(C'\fR object, such as "days",
"months", etc.
.Sp
.Vb 3
\&   $spanset =
\&       DateTime::SpanSet\->from_set_and_duration
\&           ( set => $dt_set, days => 1 );
.Ve
.IP \(bu 4
from_sets
.Sp
Creates a new span set from two \f(CW\*(C`DateTime::Set\*(C'\fR objects.
.Sp
One set defines the \fIstarting dates\fR, and the other defines the \fIend
dates\fR.
.Sp
.Vb 3
\&   $spanset =
\&       DateTime::SpanSet\->from_sets
\&           ( start_set => $dt_set1, end_set => $dt_set2 );
.Ve
.Sp
The spans have the starting date \f(CW\*(C`closed\*(C'\fR, and the end date \f(CW\*(C`open\*(C'\fR,
like in \f(CW\*(C`[$dt1, $dt2)\*(C'\fR.
.Sp
If an end date comes without a starting date before it, then it
defines a span like \f(CW\*(C`(\-inf, $dt)\*(C'\fR.
.Sp
If a starting date comes without an end date after it, then it defines
a span like \f(CW\*(C`[$dt, inf)\*(C'\fR.
.IP \(bu 4
empty_set
.Sp
Creates a new empty set.
.IP \(bu 4
is_empty_set
.Sp
Returns true is the set is empty; false otherwise.
.Sp
.Vb 1
\&    print "nothing" if $set\->is_empty_set;
.Ve
.IP \(bu 4
clone
.Sp
This object method returns a replica of the given object.
.IP \(bu 4
set_time_zone( \f(CW$tz\fR )
.Sp
This method accepts either a time zone object or a string that can be
passed as the "name" parameter to \f(CW\*(C`DateTime::TimeZone\->new()\*(C'\fR.
If the new time zone's offset is different from the old time zone,
then the \fIlocal\fR time is adjusted accordingly.
.Sp
If the old time zone was a floating time zone, then no adjustments to
the local time are made, except to account for leap seconds.  If the
new time zone is floating, then the \fIUTC\fR time is adjusted in order
to leave the local time untouched.
.IP \(bu 4
start, min
.IP \(bu 4
end, max
.Sp
First or last dates in the set.
.Sp
It is possible that the return value from these methods may be a
\&\f(CW\*(C`DateTime::Infinite::Future\*(C'\fR or a \f(CW\*(C`DateTime::Infinite::Past\*(C'\fR object.
.Sp
If the set ends \f(CW\*(C`before\*(C'\fR a date \f(CW$dt\fR, it returns \f(CW$dt\fR. Note that
in this case \f(CW$dt\fR is not a set element \- but it is a set boundary.
.Sp
These methods may return \f(CW\*(C`undef\*(C'\fR if the set is empty.
.Sp
These methods return just a \fIcopy\fR of the actual boundary value.
If you modify the result, the set will not be modified.
.IP \(bu 4
duration
.Sp
The total size of the set, as a \f(CW\*(C`DateTime::Duration\*(C'\fR object.
.Sp
The duration may be infinite.
.Sp
Also available as \f(CWsize()\fR.
.IP \(bu 4
span
.Sp
The total span of the set, as a \f(CW\*(C`DateTime::Span\*(C'\fR object.
.IP \(bu 4
next
.Sp
.Vb 1
\&  my $span = $set\->next( $dt );
.Ve
.Sp
This method is used to find the next span in the set,
after a given datetime or span.
.Sp
The return value is a \f(CW\*(C`DateTime::Span\*(C'\fR, or \f(CW\*(C`undef\*(C'\fR if there is no matching
span in the set.
.IP \(bu 4
previous
.Sp
.Vb 1
\&  my $span = $set\->previous( $dt );
.Ve
.Sp
This method is used to find the previous span in the set,
before a given datetime or span.
.Sp
The return value is a \f(CW\*(C`DateTime::Span\*(C'\fR, or \f(CW\*(C`undef\*(C'\fR if there is no matching
span in the set.
.IP \(bu 4
current
.Sp
.Vb 1
\&  my $span = $set\->current( $dt );
.Ve
.Sp
This method is used to find the "current" span in the set,
that intersects a given datetime or span. If no current span
is found, then the "previous" span is returned.
.Sp
The return value is a \f(CW\*(C`DateTime::SpanSet\*(C'\fR, or \f(CW\*(C`undef\*(C'\fR if there is no
matching span in the set.
.Sp
If a span parameter is given, it may happen that "current" returns
more than one span.
.Sp
See also: \f(CWintersected_spans()\fR method.
.IP \(bu 4
closest
.Sp
.Vb 1
\&  my $span = $set\->closest( $dt );
.Ve
.Sp
This method is used to find the "closest" span in the set, given a
datetime or span.
.Sp
The return value is a \f(CW\*(C`DateTime::SpanSet\*(C'\fR, or \f(CW\*(C`undef\*(C'\fR if the set is
empty.
.Sp
If a span parameter is given, it may happen that "closest" returns
more than one span.
.IP \(bu 4
as_list
.Sp
Returns a list of \f(CW\*(C`DateTime::Span\*(C'\fR objects.
.Sp
.Vb 1
\&  my @dt_span = $set\->as_list( span => $span );
.Ve
.Sp
Just as with the \f(CWiterator()\fR method, the \f(CWas_list()\fR method can be
limited by a span.
.Sp
Applying \f(CWas_list()\fR to a large recurring spanset is a very expensive
operation, both in CPU time and in the memory used.
.Sp
For this reason, when \f(CWas_list()\fR operates on large recurrence sets,
it will return at most approximately 200 spans. For larger sets, and
for \fIinfinite\fR sets, \f(CWas_list()\fR will return \f(CW\*(C`undef\*(C'\fR.
.Sp
Please note that this is explicitly not an empty list, since an empty
list is a valid return value for empty sets!
.Sp
If you \fIreally\fR need to extract spans from a large set, you can:
.Sp
\&\- limit the set with a shorter span:
.Sp
.Vb 1
\&    my @short_list = $large_set\->as_list( span => $short_span );
.Ve
.Sp
\&\- use an iterator:
.Sp
.Vb 3
\&    my @large_list;
\&    my $iter = $large_set\->iterator;
\&    push @large_list, $dt while $dt = $iter\->next;
.Ve
.IP \(bu 4
union
.IP \(bu 4
intersection
.IP \(bu 4
complement
.Sp
Set operations may be performed not only with \f(CW\*(C`DateTime::SpanSet\*(C'\fR
objects, but also with \f(CW\*(C`DateTime\*(C'\fR, \f(CW\*(C`DateTime::Set\*(C'\fR and
\&\f(CW\*(C`DateTime::Span\*(C'\fR objects.  These set operations always return a
\&\f(CW\*(C`DateTime::SpanSet\*(C'\fR object.
.Sp
.Vb 4
\&    $set = $spanset\->union( $set2 );         # like "OR", "insert", "both"
\&    $set = $spanset\->complement( $set2 );    # like "delete", "remove"
\&    $set = $spanset\->intersection( $set2 );  # like "AND", "while"
\&    $set = $spanset\->complement;             # like "NOT", "negate", "invert"
.Ve
.IP \(bu 4
intersected_spans
.Sp
This method can accept a \f(CW\*(C`DateTime\*(C'\fR list, a \f(CW\*(C`DateTime::Set\*(C'\fR, a
\&\f(CW\*(C`DateTime::Span\*(C'\fR, or a \f(CW\*(C`DateTime::SpanSet\*(C'\fR object as an argument.
.Sp
.Vb 1
\&    $set = $set1\->intersected_spans( $set2 );
.Ve
.Sp
The method always returns a \f(CW\*(C`DateTime::SpanSet\*(C'\fR object, containing
all spans that are intersected by the given set.
.Sp
Unlike the \f(CW\*(C`intersection\*(C'\fR method, the spans are not modified.  See
diagram below:
.Sp
.Vb 2
\&               set1   [....]   [....]   [....]   [....]
\&               set2      [................]
\&
\&       intersection      [.]   [....]   [.]
\&
\&  intersected_spans   [....]   [....]   [....]
.Ve
.IP \(bu 4
intersects
.IP \(bu 4
contains
.Sp
These set functions return a boolean value.
.Sp
.Vb 2
\&    if ( $spanset\->intersects( $set2 ) ) { ...  # like "touches", "interferes"
\&    if ( $spanset\->contains( $dt ) ) { ...    # like "is\-fully\-inside"
.Ve
.Sp
These methods can accept a \f(CW\*(C`DateTime\*(C'\fR, \f(CW\*(C`DateTime::Set\*(C'\fR,
\&\f(CW\*(C`DateTime::Span\*(C'\fR, or \f(CW\*(C`DateTime::SpanSet\*(C'\fR object as an argument.
.Sp
\&\fBintersects()\fR returns 1 for true, and 0 for false. In a few cases
the algorithm can't decide if the sets intersect at all, and 
\&\fBintersects()\fR will return \f(CW\*(C`undef\*(C'\fR.
.IP \(bu 4
iterator / next / previous
.Sp
This method can be used to iterate over the spans in a set.
.Sp
.Vb 6
\&    $iter = $spanset\->iterator;
\&    while ( $dt = $iter\->next ) {
\&        # $dt is a DateTime::Span
\&        print $dt\->min\->ymd;   # first date of span
\&        print $dt\->max\->ymd;   # last date of span
\&    }
.Ve
.Sp
The boundaries of the iterator can be limited by passing it a \f(CW\*(C`span\*(C'\fR
parameter.  This should be a \f(CW\*(C`DateTime::Span\*(C'\fR object which delimits
the iterator's boundaries.  Optionally, instead of passing an object,
you can pass any parameters that would work for one of the
\&\f(CW\*(C`DateTime::Span\*(C'\fR class's constructors, and an object will be created
for you.
.Sp
Obviously, if the span you specify does is not restricted both at the
start and end, then your iterator may iterate forever, depending on
the nature of your set.  User beware!
.Sp
The \f(CWnext()\fR or \f(CWprevious()\fR methods will return \f(CW\*(C`undef\*(C'\fR when there
are no more spans in the iterator.
.IP \(bu 4
start_set
.IP \(bu 4
end_set
.Sp
These methods do the inverse of the \f(CW\*(C`from_sets\*(C'\fR method:
.Sp
\&\f(CW\*(C`start_set\*(C'\fR retrieves a DateTime::Set with the start datetime of each
span.
.Sp
\&\f(CW\*(C`end_set\*(C'\fR retrieves a DateTime::Set with the end datetime of each
span.
.IP \(bu 4
map ( sub { ... } )
.Sp
.Vb 11
\&    # example: enlarge the spans
\&    $set = $set2\->map( 
\&        sub {
\&            my $start = $_\->start;
\&            my $end = $_\->end;
\&            return DateTime::Span\->from_datetimes(
\&                start => $start,
\&                before => $end,
\&            );
\&        }
\&    );
.Ve
.Sp
This method is the "set" version of Perl "map".
.Sp
It evaluates a subroutine for each element of the set (locally setting
"$_" to each DateTime::Span) and returns the set composed of the
results of each such evaluation.
.Sp
Like Perl "map", each element of the set may produce zero, one, or
more elements in the returned value.
.Sp
Unlike Perl "map", changing "$_" does not change the original
set. This means that calling map in void context has no effect.
.Sp
The callback subroutine may not be called immediately.  Don't count on
subroutine side-effects. For example, a \f(CW\*(C`print\*(C'\fR inside the subroutine
may happen later than you expect.
.Sp
The callback return value is expected to be within the span of the
\&\f(CW\*(C`previous\*(C'\fR and the \f(CW\*(C`next\*(C'\fR element in the original set.
.Sp
For example: given the set \f(CW\*(C`[ 2001, 2010, 2015 ]\*(C'\fR, the callback
result for the value \f(CW2010\fR is expected to be within the span \f(CW\*(C`[
2001 .. 2015 ]\*(C'\fR.
.IP \(bu 4
grep ( sub { ... } )
.Sp
.Vb 7
\&    # example: filter out all spans happening today
\&    my $today = DateTime\->today;
\&    $set = $set2\->grep( 
\&        sub {
\&            return ( ! $_\->contains( $today ) );
\&        }
\&    );
.Ve
.Sp
This method is the "set" version of Perl "grep".
.Sp
It evaluates a subroutine for each element of the set (locally setting
"$_" to each DateTime::Span) and returns the set consisting of those
elements for which the expression evaluated to true.
.Sp
Unlike Perl "grep", changing "$_" does not change the original
set. This means that calling grep in void context has no effect.
.Sp
Changing "$_" does change the resulting set.
.Sp
The callback subroutine may not be called immediately.  Don't count on
subroutine side-effects. For example, a \f(CW\*(C`print\*(C'\fR inside the subroutine
may happen later than you expect.
.IP \(bu 4
iterate
.Sp
\&\fIInternal method \- use "map" or "grep" instead.\fR
.Sp
This function apply a callback subroutine to all elements of a set and
returns the resulting set.
.Sp
The parameter \f(CW$_[0]\fR to the callback subroutine is a
\&\f(CW\*(C`DateTime::Span\*(C'\fR object.
.Sp
If the callback returns \f(CW\*(C`undef\*(C'\fR, the datetime is removed from the
set:
.Sp
.Vb 3
\&    sub remove_sundays {
\&        $_[0] unless $_[0]\->start\->day_of_week == 7;
\&    }
.Ve
.Sp
The callback return value is expected to be within the span of the
\&\f(CW\*(C`previous\*(C'\fR and the \f(CW\*(C`next\*(C'\fR element in the original set.
.Sp
For example: given the set \f(CW\*(C`[ 2001, 2010, 2015 ]\*(C'\fR, the callback
result for the value \f(CW2010\fR is expected to be within the span \f(CW\*(C`[
2001 .. 2015 ]\*(C'\fR.
.Sp
The callback subroutine may not be called immediately.  Don't count on
subroutine side-effects. For example, a \f(CW\*(C`print\*(C'\fR inside the subroutine
may happen later than you expect.
.SH SUPPORT
.IX Header "SUPPORT"
Support is offered through the \f(CW\*(C`datetime@perl.org\*(C'\fR mailing list.
.PP
Please report bugs using rt.cpan.org
.SH AUTHOR
.IX Header "AUTHOR"
Flavio Soibelmann Glock <fglock@gmail.com>
.PP
The API was developed together with Dave Rolsky and the DateTime Community.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2003 Flavio Soibelmann Glock. All rights reserved.
This program is free software; you can distribute it and/or
modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the LICENSE file
included with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Set::Infinite
.PP
For details on the Perl DateTime Suite project please see
<http://datetime.perl.org>.
