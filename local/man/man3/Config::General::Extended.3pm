.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "General::Extended 3pm"
.TH General::Extended 3pm 2025-01-07 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Config::General::Extended \- Extended access to Config files
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& use Config::General;
\&
\& $conf = Config::General\->new(
\&    \-ConfigFile     => \*(Aqconfigfile\*(Aq,
\&    \-ExtendedAccess => 1
\& );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is an internal module which makes it possible to use object
oriented methods to access parts of your config file.
.PP
Normally you don't call it directly.
.SH METHODS
.IX Header "METHODS"
.IP configfile('filename') 4
.IX Item "configfile('filename')"
Set the filename to be used by \fBsave\fR to "filename". It returns the current
configured filename if called without arguments.
.IP obj('key') 4
.IX Item "obj('key')"
Returns a new object (of Config::General::Extended Class) from the given key.
Short example:
Assume you have the following config:
.Sp
.Vb 10
\& <individual>
\&      <martin>
\&         age   23
\&      </martin>
\&      <joseph>
\&         age   56
\&      </joseph>
\& </individual>
\& <other>
\&      blah     blubber
\&      blah     gobble
\&      leer
\& </other>
.Ve
.Sp
and already read it in using \fBConfig::General::Extended::new()\fR, then you can get a
new object from the "individual" block this way:
.Sp
.Vb 1
\& $individual = $conf\->obj("individual");
.Ve
.Sp
Now if you call \fBgetall\fR on \fR\f(CI$individual\fR\fI\fR (just for reference) you would get:
.Sp
.Vb 3
\& $VAR1 = (
\&    martin => { age => 13 }
\&         );
.Ve
.Sp
Or, here is another use:
.Sp
.Vb 5
\& my $individual = $conf\->obj("individual");
\& foreach my $person ($conf\->keys("individual")) {
\&    $man = $individual\->obj($person);
\&    print "$person is " . $man\->value("age") . " years old\en";
\& }
.Ve
.Sp
See the discussion on \fBhash()\fR and \fBvalue()\fR below.
.Sp
If the key from which you want to create a new object is empty, an empty
object will be returned. If you run the following on the above config:
.Sp
.Vb 1
\& $obj = $conf\->obj("other")\->obj("leer");
.Ve
.Sp
Then \f(CW$obj\fR will be empty, just like if you have had run this:
.Sp
.Vb 1
\& $obj = Config::General::Extended\->new( () );
.Ve
.Sp
Read operations on this empty object will return nothing or even fail.
But you can use an empty object for \fIcreating\fR a new config using write
operations, i.e.:
.Sp
.Vb 1
\& $obj\->someoption("value");
.Ve
.Sp
See the discussion on \fBAUTOLOAD METHODS\fR below.
.Sp
If the key points to a list of hashes, a list of objects will be
returned. Given the following example config:
.Sp
.Vb 6
\& <option>
\&   name = max
\& </option>
\& <option>
\&   name = bea
\& </option>
.Ve
.Sp
you could write code like this to access the list the OOP way:
.Sp
.Vb 4
\& my $objlist = $conf\->obj("option");
\& foreach my $option (@{$objlist}) {
\&  print $option\->name;
\& }
.Ve
.Sp
Please note that the list will be returned as a reference to an array.
.Sp
Empty elements or non-hash elements of the list, if any, will be skipped.
.IP hash('key') 4
.IX Item "hash('key')"
This method returns a hash(if it \fBis\fR one!) from the config which is referenced by
"key". Given the sample config above you would get:
.Sp
.Vb 5
\& my %sub_hash = $conf\->hash("individual");
\& print Dumper(\e%sub_hash);
\& $VAR1 = {
\&    martin => { age => 13 }
\&         };
.Ve
.IP array('key') 4
.IX Item "array('key')"
This the equivalent of \fBhash()\fR mentioned above, except that it returns an array.
Again, we use the sample config mentioned above:
.Sp
.Vb 4
\& $other = $conf\->obj("other");
\& my @blahs = $other\->array("blah");
\& print Dumper(\e@blahs);
\& $VAR1 = [ "blubber", "gobble" ];
.Ve
.IP value('key') 4
.IX Item "value('key')"
This method returns the scalar value of a given key. Given the following sample
config:
.Sp
.Vb 2
\& name  = arthur
\& age   = 23
.Ve
.Sp
you could do something like that:
.Sp
.Vb 1
\& print $conf\->value("name") . " is " . $conf\->value("age") . " years old\en";
.Ve
.Sp
You can use this method also to set the value of "key" to something if you give over
a hash reference, array reference or a scalar in addition to the key. An example:
.Sp
.Vb 5
\& $conf\->value("key", \e%somehash);
\& # or
\& $conf\->value("key", \e@somearray);
\& # or
\& $conf\->value("key", $somescalar);
.Ve
.Sp
Please note, that this method does not complain about existing values within "key"!
.IP "is_hash('key') is_array('key') is_scalar('key')" 4
.IX Item "is_hash('key') is_array('key') is_scalar('key')"
As seen above, you can access parts of your current config using hash, array or scalar
methods. But you are right if you guess, that this might become problematic, if
for example you call \fBhash()\fR on a key which is in real not a hash but a scalar. Under
normal circumstances perl would refuse this and die.
.Sp
To avoid such behavior you can use one of the methods \fBis_hash()\fR \fBis_array()\fR \fBis_scalar()\fR to
check if the value of "key" is really what you expect it to be.
.Sp
An example(based on the config example from above):
.Sp
.Vb 6
\& if($conf\->is_hash("individual") {
\&    $individual = $conf\->obj("individual");
\& }
\& else {
\&    die "You need to configure a "individual" block!\en";
\& }
.Ve
.IP exists('key') 4
.IX Item "exists('key')"
This method returns just true if the given key exists in the config.
.IP keys('key') 4
.IX Item "keys('key')"
Returns an array of the keys under the specified "key". If you use the example
config above you could do that:
.Sp
.Vb 2
\& print Dumper($conf\->keys("individual");
\& $VAR1 = [ "martin", "joseph" ];
.Ve
.Sp
If no key name was supplied, then the keys of the object itself will be returned.
.Sp
You can use this method in \fBforeach\fR loops as seen in an example above(\fBobj()\fR ).
.IP delete('key') 4
.IX Item "delete('key')"
This method removes the given key and all associated data from the internal
hash structure. If 'key' contained data, then this data will be returned,
otherwise undef will be returned.
.IP find(@list) 4
.IX Item "find(@list)"
Given a list of nodes, \->find will search for a tree that branches in
just this way, returning the Config::General::Extended object it finds
at the bottom if it exists.  You can also search partway down the tree
and \->find should return where you left off.
.Sp
For example, given the values \fBfind (qw (A B C))\fR and the following
tree (</end> tags omitted for brevity):
.Sp
.Vb 8
\& <A>
\&        <FOO>
\&                ...
\&        <B>
\&                <BAZ>
\&                        ...
\&                <C>
\&                        BAR = shoo
.Ve
.Sp
\&\fBfind()\fR will find the object at \fIC\fR with the value BAR = shoo and
return it.
.SH "AUTOLOAD METHODS"
.IX Header "AUTOLOAD METHODS"
Another useful feature is implemented in this class using the \fBAUTOLOAD\fR feature
of perl. If you know the keynames of a block within your config, you can access to
the values of each individual key using the method notation. See the following example
and you will get it:
.PP
We assume the following config:
.PP
.Vb 5
\& <person>
\&    name    = Moser
\&    prename = Peter
\&    birth   = 12.10.1972
\& </person>
.Ve
.PP
Now we read it in and process it:
.PP
.Vb 3
\& my $conf = Config::General::Extended\->new("configfile");
\& my $person = $conf\->obj("person");
\& print $person\->prename . " " . $person\->name . " is " . $person\->age . " years old\en";
.Ve
.PP
This notation supports only scalar values! You need to make sure, that the block
<person> does not contain any subblock or multiple identical options(which will become
an array after parsing)!
.PP
If you access a non-existent key this way, Config::General will croak an error.
You can turn this behavior off by setting \fB\-StrictObjects\fR to 0 or "no". In
this case undef will be returned.
.PP
Of course you can use this kind of methods for writing data too:
.PP
.Vb 1
\& $person\->name("Neustein");
.Ve
.PP
This changes the value of the "name" key to "Neustein". This feature behaves exactly like
\&\fBvalue()\fR, which means you can assign hash or array references as well and that existing
values under the given key will be overwritten.
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2000\-2022 Thomas Linden
.PP
This library is free software; you can redistribute it and/or
modify it under the terms of the Artistic License 2.0.
.SH BUGS
.IX Header "BUGS"
none known yet.
.SH AUTHOR
.IX Header "AUTHOR"
Thomas Linden <tlinden |AT| cpan.org>
.SH VERSION
.IX Header "VERSION"
2.07
