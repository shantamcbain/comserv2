.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "MLDBM 3pm"
.TH MLDBM 3pm 2025-03-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
MLDBM \- store multi\-level Perl hash structure in single level tied hash
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 3
\&    use MLDBM;                          # this gets the default, SDBM
\&    #use MLDBM qw(DB_File FreezeThaw);  # use FreezeThaw for serializing
\&    #use MLDBM qw(DB_File Storable);    # use Storable for serializing
\&
\&    $dbm = tie %o, \*(AqMLDBM\*(Aq [..other DBM args..] or die $!;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module can serve as a transparent interface to any TIEHASH package
that is required to store arbitrary perl data, including nested references.
Thus, this module can be used for storing references and other arbitrary data
within DBM databases.
.PP
It works by serializing the references in the hash into a single string. In the
underlying TIEHASH package (usually a DBM database), it is this string that
gets stored.  When the value is fetched again, the string is deserialized to
reconstruct the data structure into memory.
.PP
For historical and practical reasons, it requires the \fBData::Dumper\fR package,
available at any CPAN site. \fBData::Dumper\fR gives you really nice-looking dumps of
your data structures, in case you wish to look at them on the screen, and
it was the only serializing engine before version 2.00.  However, as of version
2.00, you can use any of \fBData::Dumper\fR, \fBFreezeThaw\fR or \fBStorable\fR to
perform the underlying serialization, as hinted at by the SYNOPSIS overview
above.  Using \fBStorable\fR is usually much faster than the other methods.
.PP
See the BUGS section for important limitations.
.SS "Changing the Defaults"
.IX Subsection "Changing the Defaults"
\&\fBMLDBM\fR relies on an underlying TIEHASH implementation (usually a
DBM package), and an underlying serialization package.  The respective
defaults are \fBSDBM_File\fR and \fBData::Dumper\fR.  Both of these defaults
can be changed.  Changing the \fBSDBM_File\fR default is strongly recommended.
See WARNINGS below.
.PP
Three serialization wrappers are currently supported: \fBData::Dumper\fR,
\&\fBStorable\fR, and \fBFreezeThaw\fR.  Additional serializers can be
supported by writing a wrapper that implements the interface required by
\&\fBMLDBM::Serializer\fR.  See the supported wrappers and the \fBMLDBM::Serializer\fR
source for details.
.PP
In the following, \fR\f(CI$OBJ\fR\fI\fR stands for the tied object, as in:
.PP
.Vb 2
\&        $obj = tie %o, ....
\&        $obj = tied %o;
.Ve
.ie n .IP "$MLDBM::UseDB	\fIor\fR	\fR\fI$OBJ\fR\fI\fR\->UseDB(\fI[TIEDOBJECT]\fR)" 4
.el .IP "\f(CW$MLDBM::UseDB\fR	\fIor\fR	\fR\f(CI$OBJ\fR\fI\fR\->UseDB(\fI[TIEDOBJECT]\fR)" 4
.IX Item "$MLDBM::UseDB or $OBJ->UseDB([TIEDOBJECT])"
The global \f(CW$MLDBM::UseDB\fR can be set to default to something other than
\&\f(CW\*(C`SDBM_File\*(C'\fR, in case you have a more efficient DBM, or if you want to use
this with some other TIEHASH implementation.  Alternatively, you can specify
the name of the package at \f(CW\*(C`use\*(C'\fR time, as the first "parameter".
Nested module names can be specified as "Foo::Bar".
.Sp
The corresponding method call returns the underlying TIEHASH object when
called without arguments.  It can be called with any object that
implements Perl's TIEHASH interface, to set that value.
.ie n .IP "$MLDBM::Serializer	\fIor\fR	\fR\fI$OBJ\fR\fI\fR\->Serializer(\fI[SZROBJECT]\fR)" 4
.el .IP "\f(CW$MLDBM::Serializer\fR	\fIor\fR	\fR\f(CI$OBJ\fR\fI\fR\->Serializer(\fI[SZROBJECT]\fR)" 4
.IX Item "$MLDBM::Serializer or $OBJ->Serializer([SZROBJECT])"
The global \f(CW$MLDBM::Serializer\fR can be set to the name of the serializing
package to be used. Currently can be set to one of \f(CW\*(C`Data::Dumper\*(C'\fR,
\&\f(CW\*(C`Storable\*(C'\fR, or \f(CW\*(C`FreezeThaw\*(C'\fR. Defaults to \f(CW\*(C`Data::Dumper\*(C'\fR.  Alternatively,
you can specify the name of the serializer package at \f(CW\*(C`use\*(C'\fR time, as the
second "parameter".
.Sp
The corresponding method call returns the underlying MLDBM serializer object
when called without arguments.  It can be called with an object that
implements the MLDBM serializer interface, to set that value.
.SS "Controlling Serializer Properties"
.IX Subsection "Controlling Serializer Properties"
These methods are meant to supply an interface to the properties of the
underlying serializer used.  Do \fBnot\fR call or set them without
understanding the consequences in full.  The defaults are usually sensible.
.PP
Not all of these necessarily apply to all the supplied serializers, so we
specify when to apply them.  Failure to respect this will usually lead to
an exception.
.ie n .IP "$MLDBM::DumpMeth	\fIor\fR  \fR\fI$OBJ\fR\fI\fR\->DumpMeth(\fI[METHNAME]\fR)" 4
.el .IP "\f(CW$MLDBM::DumpMeth\fR	\fIor\fR  \fR\f(CI$OBJ\fR\fI\fR\->DumpMeth(\fI[METHNAME]\fR)" 4
.IX Item "$MLDBM::DumpMeth or $OBJ->DumpMeth([METHNAME])"
If the serializer provides alternative serialization methods, this
can be used to set them.
.Sp
With \fBData::Dumper\fR (which offers a pure Perl and an XS verion
of its serializing routine), this is set to \f(CW\*(C`Dumpxs\*(C'\fR by default if that
is supported in your installation.  Otherwise, defaults to the slower
\&\f(CW\*(C`Dump\*(C'\fR method.
.Sp
With \fBStorable\fR, a value of \f(CW\*(C`portable\*(C'\fR requests that serialization be
architecture neutral, i.e. the deserialization can later occur on another
platform. Of course, this only makes sense if your database files are
themselves architecture neutral.  By default, native format is used for
greater serializing speed in \fBStorable\fR.  Both \fBData::Dumper\fR and
\&\fBFreezeThaw\fR are always architecture neutral.
.Sp
\&\fBFreezeThaw\fR does not honor this attribute.
.ie n .IP "$MLDBM::Key  \fIor\fR  \fR\fI$OBJ\fR\fI\fR\->Key(\fI[KEYSTRING]\fR)" 4
.el .IP "\f(CW$MLDBM::Key\fR  \fIor\fR  \fR\f(CI$OBJ\fR\fI\fR\->Key(\fI[KEYSTRING]\fR)" 4
.IX Item "$MLDBM::Key or $OBJ->Key([KEYSTRING])"
If the serializer only deals with part of the data (perhaps because
the TIEHASH object can natively store some types of data), it may need
a unique key string to recognize the data it handles.  This can be used
to set that string.  Best left alone.
.Sp
Defaults to the magic string used to recognize MLDBM data. It is a six
character wide, unique string. This is best left alone, unless you know
what you are doing.
.Sp
\&\fBStorable\fR and \fBFreezeThaw\fR do not honor this attribute.
.ie n .IP "$MLDBM::RemoveTaint  \fIor\fR  \fR\fI$OBJ\fR\fI\fR\->RemoveTaint(\fI[BOOL]\fR)" 4
.el .IP "\f(CW$MLDBM::RemoveTaint\fR  \fIor\fR  \fR\f(CI$OBJ\fR\fI\fR\->RemoveTaint(\fI[BOOL]\fR)" 4
.IX Item "$MLDBM::RemoveTaint or $OBJ->RemoveTaint([BOOL])"
If the serializer can optionally untaint any retrieved data subject to
taint checks in Perl, this can be used to request that feature.  Data
that comes from external sources (like disk-files) must always be
viewed with caution, so use this only when you are sure that that is
not an issue.
.Sp
\&\fBData::Dumper\fR uses \f(CWeval()\fR to deserialize and is therefore subject to
taint checks.  Can be set to a true value to make the \fBData::Dumper\fR
serializer untaint the data retrieved. It is not enabled by default.
Use with care.
.Sp
\&\fBStorable\fR and \fBFreezeThaw\fR do not honor this attribute.
.SH EXAMPLES
.IX Header "EXAMPLES"
Here is a simple example.  Note that does not depend upon the underlying
serializing package\-\-most real life examples should not, usually.
.PP
.Vb 3
\&    use MLDBM;                          # this gets SDBM and Data::Dumper
\&    #use MLDBM qw(SDBM_File Storable);  # SDBM and Storable
\&    use Fcntl;                          # to get \*(Aqem constants
\&
\&    $dbm = tie %o, \*(AqMLDBM\*(Aq, \*(Aqtestmldbm\*(Aq, O_CREAT|O_RDWR, 0640 or die $!;
\&
\&    $c = [\e \*(Aqc\*(Aq];
\&    $b = {};
\&    $a = [1, $b, $c];
\&    $b\->{a} = $a;
\&    $b\->{b} = $a\->[1];
\&    $b\->{c} = $a\->[2];
\&    @o{qw(a b c)} = ($a, $b, $c);
\&
\&    #
\&    # to see what was stored
\&    #
\&    use Data::Dumper;
\&    print Data::Dumper\->Dump([@o{qw(a b c)}], [qw(a b c)]);
\&
\&    #
\&    # to modify data in a substructure
\&    #
\&    $tmp = $o{a};
\&    $tmp\->[0] = \*(Aqfoo\*(Aq;
\&    $o{a} = $tmp;
\&
\&    #
\&    # can access the underlying DBM methods transparently
\&    #
\&    #print $dbm\->fd, "\en";              # DB_File method
.Ve
.PP
Here is another small example using Storable, in a portable format:
.PP
.Vb 1
\&    use MLDBM qw(DB_File Storable);     # DB_File and Storable
\&
\&    tie %o, \*(AqMLDBM\*(Aq, \*(Aqtestmldbm\*(Aq, O_CREAT|O_RDWR, 0640 or die $!;
\&
\&    (tied %o)\->DumpMeth(\*(Aqportable\*(Aq);    # Ask for portable binary
\&    $o{\*(AqENV\*(Aq} = \e%ENV;                  # Stores the whole environment
.Ve
.SH BUGS
.IX Header "BUGS"
.IP 1. 4
Adding or altering substructures to a hash value is not entirely transparent
in current perl.  If you want to store a reference or modify an existing
reference value in the DBM, it must first be retrieved and stored in a
temporary variable for further modifications.  In particular, something like
this will NOT work properly:
.Sp
.Vb 1
\&        $mldb{key}{subkey}[3] = \*(Aqstuff\*(Aq;        # won\*(Aqt work
.Ve
.Sp
Instead, that must be written as:
.Sp
.Vb 3
\&        $tmp = $mldb{key};                      # retrieve value
\&        $tmp\->{subkey}[3] = \*(Aqstuff\*(Aq;
\&        $mldb{key} = $tmp;                      # store value
.Ve
.Sp
This limitation exists because the perl TIEHASH interface currently has no
support for multidimensional ties.
.IP 2. 4
The \fBData::Dumper\fR serializer uses \fBeval()\fR.  A lot.  Try the \fBStorable\fR
serializer, which is generally the most efficient.
.SH WARNINGS
.IX Header "WARNINGS"
.IP 1. 4
Many DBM implementations have arbitrary limits on the size of records
that can be stored.  For example, SDBM and many ODBM or NDBM
implementations have a default limit of 1024 bytes for the size of a
record.  MLDBM can easily exceed these limits when storing large data
structures, leading to mysterious failures.  Although SDBM_File is
used by MLDBM by default, it is not a good choice if you're storing
large data structures.  Berkeley DB and GDBM both do not have these
limits, so I recommend using either of those instead.
.IP 2. 4
MLDBM does well with data structures that are not too deep and not
too wide.  You also need to be careful about how many \f(CW\*(C`FETCH\*(C'\fRes your
code actually ends up doing.  Meaning, you should get the most mileage
out of a \f(CW\*(C`FETCH\*(C'\fR by holding on to the highest level value for as long
as you need it.  Remember that every toplevel access of the tied hash,
for example \f(CW$mldb{foo}\fR, translates to a MLDBM \f(CWFETCH()\fR call.
.Sp
Too often, people end up writing something like this:
.Sp
.Vb 4
\&        tie %h, \*(AqMLDBM\*(Aq, ...;
\&        for my $k (keys %{$h{something}}) {
\&            print $h{something}{$k}[0]{foo}{bar};  # FETCH _every_ time!
\&        }
.Ve
.Sp
when it should be written this for efficiency:
.Sp
.Vb 5
\&        tie %h, \*(AqMLDBM\*(Aq, ...;
\&        my $root = $h{something};                  # FETCH _once_
\&        for my $k (keys %$root) {
\&            print $k\->[0]{foo}{bar};
\&        }
.Ve
.SH AUTHORS
.IX Header "AUTHORS"
Gurusamy Sarathy <\fIgsar@umich.edu\fR>.
.PP
Support for multiple serializing packages by
Raphael Manfredi <\fIRaphael_Manfredi@grenoble.hp.com\fR>.
.PP
Test suite fixes for perl 5.8.0 done by Josh Chamas.
.PP
Copyright (c) 1995\-98 Gurusamy Sarathy.  All rights reserved.
.PP
Copyright (c) 1998 Raphael Manfredi.
.PP
Copyright (c) 2002 Josh Chamas, Chamas Enterprises Inc.
.PP
Copyright (c) 2010\-2013 Alexandr Ciornii (alexchorny@gmail.com).
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH VERSION
.IX Header "VERSION"
Version 2.05
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1), \fBperltie\fR\|(1), \fBperlfunc\fR\|(1), Data::Dumper, FreezeThaw, Storable, DBM::Deep, MLDBM::Serializer::JSON.
