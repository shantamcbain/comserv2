.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Storage::DBI::ADO::MS_Jet 3pm"
.TH DBIx::Class::Storage::DBI::ADO::MS_Jet 3pm 2022-05-15 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Storage::DBI::ADO::MS_Jet \- Support for MS Access over ADO
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This driver is a subclass of DBIx::Class::Storage::DBI::ADO and
DBIx::Class::Storage::DBI::ACCESS for connecting to MS Access via
DBD::ADO.
.PP
See the documentation for DBIx::Class::Storage::DBI::ACCESS for
information on the MS Access driver for DBIx::Class.
.PP
This driver implements workarounds for \f(CW\*(C`TEXT/IMAGE/MEMO\*(C'\fR columns, sets the
cursor_class to
DBIx::Class::Storage::DBI::ADO::MS_Jet::Cursor to normalize returned
\&\f(CW\*(C`GUID\*(C'\fR values and provides DBIx::Class::InflateColumn::DateTime support
for \f(CW\*(C`DATETIME\*(C'\fR columns.
.SH "EXAMPLE DSNs"
.IX Header "EXAMPLE DSNs"
.Vb 2
\&  # older Access versions:
\&  dbi:ADO:Microsoft.Jet.OLEDB.4.0;Data Source=C:\eUsers\erkitover\eDocuments\eaccess_sample.accdb
\&
\&  # newer Access versions:
\&  dbi:ADO:Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\eUsers\erkitover\eDocuments\eaccess_sample.accdb;Persist Security Info=False\*(Aq
.Ve
.SH "TEXT/IMAGE/MEMO COLUMNS"
.IX Header "TEXT/IMAGE/MEMO COLUMNS"
The ADO driver does not suffer from the
problems
the ODBC driver has with these types
of columns. You can use them safely.
.PP
When you execute a \f(CW\*(C`CREATE TABLE\*(C'\fR statement over this driver with a \f(CW\*(C`TEXT\*(C'\fR
column, it will be converted to \f(CW\*(C`MEMO\*(C'\fR, while in the
ODBC driver it is converted to
\&\f(CWVARCHAR(255)\fR.
.PP
However, the caveat about LongReadLen having to be twice the
max size of your largest \f(CW\*(C`MEMO/TEXT\*(C'\fR column \f(CW+1\fR still applies. DBD::ADO
sets LongReadLen to a large value by default, so it should be
safe to just leave it unset. If you do pass a LongReadLen in
your connect_info, it will be
multiplied by two and \f(CW1\fR added, just as for the
ODBC driver.
.SH "FURTHER QUESTIONS?"
.IX Header "FURTHER QUESTIONS?"
Check the list of additional DBIC resources.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This module is free software copyright
by the DBIx::Class (DBIC) authors. You can
redistribute it and/or modify it under the same terms as the
DBIx::Class library.
