.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Any::Proxy 3pm"
.TH Log::Any::Proxy 3pm 2023-08-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Log::Any::Proxy \- Log::Any generator proxy object
.SH VERSION
.IX Header "VERSION"
version 1.717
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&    # prefix log messages
\&    use Log::Any \*(Aq$log\*(Aq, prefix => \*(AqMyApp: \*(Aq;
\&
\&    # transform log messages
\&    use Log::Any \*(Aq$log\*(Aq, filter => \e&myfilter;
\&
\&    # format with String::Flogger instead of the default
\&    use String::Flogger;
\&    use Log::Any \*(Aq$log\*(Aq, formatter => sub {
\&        my ($cat, $lvl, @args) = @_;
\&        String::Flogger::flog( @args );
\&    };
\&
\&    # create a clone with different attributes
\&    my $bar_log = $log\->clone( prefix => \*(Aqbar: \*(Aq );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Log::Any::Proxy objects are what modules use to produce log messages.  They
construct messages and pass them along to a configured adapter.
.SH ATTRIBUTES
.IX Header "ATTRIBUTES"
.SS adapter
.IX Subsection "adapter"
A Log::Any::Adapter object to receive any messages logged.  This is
generated by Log::Any and can not be overridden.
.SS category
.IX Subsection "category"
The category name of the proxy.  If not provided, Log::Any will set it
equal to the calling when the proxy is constructed.
.SS filter
.IX Subsection "filter"
A code reference to transform messages before passing them to a
Log::Any::Adapter.  It gets three arguments: a category, a numeric level
and a string.  It should return a string to be logged.
.PP
.Vb 4
\&    sub {
\&        my ($cat, $lvl, $msg) = @_;
\&        return "[$lvl] $msg";
\&    }
.Ve
.PP
If the return value is undef or the empty string, no message will be
logged.  Otherwise, the return value is passed to the logging adapter.
.PP
Numeric levels range from 0 (emergency) to 8 (trace).  Constant functions
for these levels are available from Log::Any::Adapter::Util.
.PP
Configuring a filter disables structured logging, even if the
configured adapter supports it.
.SS formatter
.IX Subsection "formatter"
A code reference to format messages given to the \f(CW*f\fR methods (\f(CW\*(C`tracef\*(C'\fR,
\&\f(CW\*(C`debugf\*(C'\fR, \f(CW\*(C`infof\*(C'\fR, etc..)
.PP
It get three or more arguments: a category, a numeric level and the list
of arguments passsed to the \f(CW*f\fR method.  It should return a string to
be logged.
.PP
.Vb 4
\&    sub {
\&        my ($cat, $lvl, $format, @args) = @_;
\&        return sprintf($format, @args);
\&    }
.Ve
.PP
The default formatter does the following:
.SS prefix
.IX Subsection "prefix"
If defined, this string will be prepended to all messages.  It will not
include a trailing space, so add that yourself if you want.  This is less
flexible/powerful than "filter", but avoids an extra function call.
.SS context
.IX Subsection "context"
Logging context data hashref. All the key/value pairs added to this hash
will be printed with every log message.
.SH USAGE
.IX Header "USAGE"
.SS "Simple logging"
.IX Subsection "Simple logging"
Your library can do simple logging using logging methods corresponding to
the log levels (or aliases):
.PP
Pass a string to be logged.  Do not include a newline.
.PP
.Vb 1
\&    $log\->info("Got some new for you.");
.Ve
.PP
The log string will be transformed via the \f(CW\*(C`filter\*(C'\fR attribute (if any) and
the \f(CW\*(C`prefix\*(C'\fR (if any) will be prepended. Returns the transformed log string.
.PP
\&\fBNOTE\fR: While you are encouraged to pass a single string to be logged, if
multiple arguments are passed, they are concatenated with a space character
into a single string before processing.  This ensures consistency across
adapters, some of which may support multiple arguments to their logging
functions (and which concatenate in different ways) and some of which do
not.
.SS "Advanced logging"
.IX Subsection "Advanced logging"
Your library can do advanced logging using logging methods corresponding to
the log levels (or aliases), but with an "f" appended:
.PP
When these methods are called, the adapter is first checked to see if it is
logging at that level.  If not, the method returns without logging.
.PP
Next, arguments are transformed to a message string via the \f(CW\*(C`formatter\*(C'\fR
attribute.
.PP
The default formatter first checks if the first log argument is a code
reference.  If so, it will executed and the result used as the formatted
message. Otherwise, the formatter acts like \f(CW\*(C`sprintf\*(C'\fR with some helpful
formatting.
.PP
Finally, the message string is logged via the simple logging functions,
which can transform or prefix as described above. The transformed log
string is then returned.
.PP
Numeric levels range from 0 (emergency) to 8 (trace).  Constant functions
for these levels are available from Log::Any::Adapter::Util.
.SS "Logging Structured Data"
.IX Subsection "Logging Structured Data"
If you have data in addition to the text you want to log, you can
specify a hashref after your string. If the configured adapter
supports structured data, it will receive the hashref as-is, otherwise
it will be converted to a string using Data::Dumper and will be
appended to your text.
.SH TIPS
.IX Header "TIPS"
.SS "UTF\-8 in Data Structures"
.IX Subsection "UTF-8 in Data Structures"
If you have high-bit characters in a data structure being passed to a log
method, Log::Any will output that data structure with the high-bit
characters encoded as \f(CW\*(C`\ex{###}\*(C'\fR, Perl's escape sequence for high-bit
characters. This is because the Data::Dumper module escapes those
characters.
.PP
.Vb 5
\&    use utf8;
\&    use Log::Any qw( $log );
\&    my @data = ( "Привет мир" ); # Hello, World!
\&    $log\->infof("Got: %s", \e@data);
\&    # Got: ["\ex{41f}\ex{440}\ex{438}\ex{432}\ex{435}\ex{442} \ex{43c}\ex{438}\ex{440}"]
.Ve
.PP
If you want to instead display the actual characters in your log file or
terminal, you can use the Data::Dumper::AutoEncode module. To wire this
up into Log::Any, you must pass a custom \f(CW\*(C`formatter\*(C'\fR sub:
.PP
.Vb 2
\&    use utf8;
\&    use Data::Dumper::AutoEncode;
\&
\&    sub log_formatter {
\&        my ( $category, $level, $format, @params ) = @_;
\&        # Run references through Data::Dumper::AutoEncode
\&        @params = map { ref $_ ? eDumper( $_ ) : $_ } @params;
\&        return sprintf $format, @params;
\&    }
\&
\&    use Log::Any \*(Aq$log\*(Aq, formatter => \e&log_formatter;
.Ve
.PP
This formatter changes the output to:
.PP
.Vb 3
\&        Got: $VAR1 = [
\&                          \*(AqПривет мир\*(Aq
\&                        ];
.Ve
.PP
Thanks to \f(CW@denis\fR\-it <https://github.com/denis-it> for this tip!
.SH AUTHORS
.IX Header "AUTHORS"
.IP \(bu 4
Jonathan Swartz <swartz@pobox.com>
.IP \(bu 4
David Golden <dagolden@cpan.org>
.IP \(bu 4
Doug Bell <preaction@cpan.org>
.IP \(bu 4
Daniel Pittman <daniel@rimspace.net>
.IP \(bu 4
Stephen Thirlwall <sdt@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Jonathan Swartz, David Golden, and Doug Bell.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
