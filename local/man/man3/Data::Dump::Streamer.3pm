.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Dump::Streamer 3pm"
.TH Data::Dump::Streamer 3pm 2025-03-16 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Data::Dump::Streamer \- Accurately serialize a data structure as Perl code.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&  use Data::Dump::Streamer;
\&  use DDS;                           # optionally installed alias
\&
\&  Dump($x,$y);                       # Prints to STDOUT
\&  Dump($x,$y)\->Out();                #   "          "
\&
\&  my $o=Data::Dump::Streamer\->new(); # Returns a new ...
\&  my $o=Dump();                      # ... uninitialized object.
\&
\&  my $o=Dump($x,$y);                 # Returns an initialized object
\&  my $s=Dump($x,$y)\->Out();          #  "  a string of the dumped obj
\&  my @l=Dump($x,$y);                 #  "  a list of code fragments
\&  my @l=Dump($x,$y)\->Out();          #  "  a list of code fragments
\&
\&  Dump($x,$y)\->To(\e*STDERR)\->Out();  # Prints to STDERR
\&
\&  Dump($x,$y)\->Names(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq)    # Specify Names
\&             \->Out();
\&
\&  Dump($x,$y)\->Indent(0)\->Out();     # No indent
\&
\&  Dump($x,$y)\->To(\e*STDERR)          # Output to STDERR
\&             \->Indent(0)             # ... no indent
\&             \->Names(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq)    # ... specify Names
\&             \->Out();                # Print...
\&
\&  $o\->Data($x,$y);                   # OO form of what Dump($x,$y) does.
\&  $o\->Names(\*(AqFoo\*(Aq,\*(AqNames\*(Aq);          #  ...
\&  $o\->Out();                         #  ...
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Given a list of scalars or reference variables, writes out
their contents in perl syntax. The references can also be
objects. The contents of each variable is output using the least
number of Perl statements as convenient, usually only one.
Self-referential structures, closures, and objects are output
correctly.
.PP
The return value can be evaled to get back an identical copy
of the original reference structure. In some cases this may
require the use of utility subs that
Data::Dump::Streamer will optionally
export.
.PP
This module is very similar in concept to the core module
Data::Dumper, with the major differences
being that this module is designed to output to a stream
instead of constructing its output in memory (trading speed
for memory), and that the traversal over the data structure
is effectively breadth first versus the depth first
traversal done by the others.
.PP
In fact the data structure is scanned twice, first in
breadth first mode to perform structural analysis, and then
in depth first mode to actually produce the output, but
obeying the depth relationships of the first pass.
.SS "Caveats Dumping Closures (CODE Refs)"
.IX Subsection "Caveats Dumping Closures (CODE Refs)"
As of version 1.11 DDS has had the ability to dump closures properly. This
means that the lexicals that are bound to the closure are dumped along
with the subroutine that uses them. This makes it much easier to debug
code that uses closures and to a certain extent provides a persistency
framework for closure based code. The way this works is that DDS figures
out what all the lexicals are that are bound to CODE refs it is dumping
and then pretends that it had originally been called with all of them as
its arguments, (along with the original arguments as well of course.)
.PP
One consequence of the way the dumping process works is that all of the
recreated subroutines will be in the same scope. This of course can lead
to collisions as two subroutines can easily be bound to different
variables that have the same name.
.PP
The way that DDS resolves these collisions is that it renames one of the
variables with a special name so that presumably there are no collisions.
However this process is very simplistic with no checks to prevent
collisions with other lexicals or other globals that may be used by other
dumped code.  In some situations it may be necessary to change the default
value of the rename template which may be done by using the \f(CW\*(C`EclipseName\*(C'\fR
method.
.PP
Similarly to the problem of colliding lexicals is the problem of colliding
lexicals and globals. DDS pays no attention to globals when dumping
closures which can potentially result in lexicals being declared that will
eclipse their global namesake. There is currently no way around this other
than to avoid accessing a global and a lexical with the same name from the
subs being dumped. An example is
.PP
.Vb 2
\&  my $a = sub { $a++ };
\&  Dump( sub { $a\->() } );
.Ve
.PP
which will not be dumped correctly. Generally speaking this kind of thing
is bad practice anyway, so this should probably be viewed as a "feature".
:\-)
.PP
Generally if the closures being dumped avoid accessing lexicals and
globals with the same name from out of scope and that all of the CODE
being dumped avoids vars with the \f(CW\*(C`EclipseName\*(C'\fR in their names the dumps
should be valid and should eval back into existence properly.
.PP
Note that the behaviour of dumping closures is subject to change in future
versions as its possible that I will put some additional effort into more
sophisticated ways of avoiding name collisions in the dump.
.SH USAGE
.IX Header "USAGE"
While Data::Dump::Streamer is at heart an object oriented module, it is
expected (based on experience with using Data::Dumper)
that the common case will not exploit these features. Nevertheless the
method based approach is convenient and accordingly a compromise hybrid
approach has been provided via the \f(CWDump()\fR subroutine. Such as
.PP
.Vb 2
\&   Dump($foo);
\&   $as_string= Dump($foo)\->Out();
.Ve
.PP
All attribute methods are designed to be chained together.  This means
that when used as set attribute (called with arguments) they return the
object they were called against. When used as get attributes (called
without arguments) they return the value of the attribute.
.PP
From an OO point of view the key methods are the \f(CWData()\fR and \f(CWOut()\fR
methods. These correspond to the breadth first and depth first traversal,
and need to be called in this order. Some attributes \fImust\fR be set prior
to the \f(CWData()\fR phase and some need only be set before the \f(CWOut()\fR
phase.
.PP
Attributes once set last the lifetime of the object, unless explicitly
reset.
.SS "Controlling Object Representation"
.IX Subsection "Controlling Object Representation"
This module provides hooks to allow objects to override how they are
represented. The basic idea is that a subroutine (or method) is provided
which is responsible for the override. The return of the method governs
how the object will be represented when dumped, and how it will be
restored. The basic calling convention is
.PP
.Vb 2
\&    my ( $proxy, $thaw, $postop )= $callback\->($obj);
\&    #or                          = $obj\->$method();
.Ve
.PP
The \f(CWFreezer()\fR method controls what methods to use as a default method
and also allows per class overrides. When dumping an object of a given
class the first time it tries to execute the class specific handler if
it is specified, then the user specific generic handler if its been
specified and then "DDS_freeze". This means that class authors can
implement a \f(CWDDS_freeze()\fR method and their objects will automatically
be serialized as necessary. \fBNote\fR that if either the class specific or
generic handler is defined but false \f(CWDDS_freeze()\fR will not be used
even if it is present.
.PP
The interface of the \f(CWFreezer()\fR handler in detail is as follows:
.ie n .IP \fR\fB$obj\fR\fB\fR 4
.el .IP \fR\f(CB$obj\fR\fB\fR 4
.IX Item "$obj"
The object being dumped.
.ie n .IP \fR\fB$proxy\fR\fB\fR 4
.el .IP \fR\f(CB$proxy\fR\fB\fR 4
.IX Item "$proxy"
This is what will be dumped instead of \f(CW$obj\fR. It may be one of
the following values:
.RS 4
.ie n .IP "\fR\fI""undef""\fR\fI\fR (first time only)" 8
.el .IP "\fR\f(CIundef\fR\fI\fR (first time only)" 8
.IX Item "undef (first time only)"
On the first time a serialization hook is called in a dump it may return
undef or the empty list to indicate that it shouldn't be used again for
this class during this pass. Any other time undef is treated the same
as false.
.IP "\fIFALSE value\fR" 8
.IX Item "FALSE value"
A false value for \f(CW$proxy\fR is taken to mean that it should be ignored.
Its like saying IgnoreClass(ref($obj)); \fBNote\fR that undef has a special
meaning when the callback is called the first time.
.IP "\fIA Reference\fR" 8
.IX Item "A Reference"
A reference that will be dumped instead of the object.
.IP "\fIPerl Code\fR" 8
.IX Item "Perl Code"
A string that is to be treated as code and inserted directly into the
dump stream as a proxy for the original. Note that the code must be
able to execute inline or in other words must evaluate to a perl EXPR.
Use \f(CW\*(C`do{}\*(C'\fR to wrap multistatement code.
.RE
.RS 4
.RE
.ie n .IP \fR\fB$thaw\fR\fB\fR 4
.el .IP \fR\f(CB$thaw\fR\fB\fR 4
.IX Item "$thaw"
This values is used to allow extra control over how the object will be
recreated when dumped. It is used for converting the \f(CW$proxy\fR representation
into the real thing. It is only relevant when \f(CW$proxy\fR is a reference.
.RS 4
.IP "\fIFALSE value\fR" 8
.IX Item "FALSE value"
Indicates no thaw action is to be included for this object.
.IP "\fISub or Method Name\fR" 8
.IX Item "Sub or Method Name"
A string matching \f(CW\*(C`/^(\->)?((?:\ew*::)\ew+)(\e(\e))?$/\*(C'\fR in which case it
is taken as a sub name when the string ends in () and a method name
when the string doesn't. If the \f(CW\*(C`\->\*(C'\fR is present then the sub or method
is called inline. If it is not then the sub or method is called
after the main dump.
.IP "\fIPerl Code\fR" 8
.IX Item "Perl Code"
Any other string, in which case the result will be taken as code
which will be emitted after the main dump. It will be wrapped
in a for loop that aliases \f(CW$_\fR to the variable in question.
.RE
.RS 4
.RE
.ie n .IP \fR\fB$postdump\fR\fB\fR 4
.el .IP \fR\f(CB$postdump\fR\fB\fR 4
.IX Item "$postdump"
This is the similar to \f(CW$thaw\fR but is called in process instead
of being emitted as part of the dump. Any return is ignored.
It is only relevant when \f(CW$proxy\fR is a reference.
.RS 4
.IP "\fIFALSE value\fR" 8
.IX Item "FALSE value"
No postdump action is to occur.
.IP "\fICode Reference\fR" 8
.IX Item "Code Reference"
The code ref will be called after serialization is complete
with the object as the argument.
.IP "\fIMethod Name\fR" 8
.IX Item "Method Name"
The method will be called after serialization is complete
.RE
.RS 4
.RE
.PP
An example DDS_freeze method is one I had to put together for an object
which contained a key whose value was a ref to an array tied to the value
of another key. Dumping this got crazy, so I wanted to suppress dumping
the tied array. I did it this way:
.PP
.Vb 5
\&    sub DDS_freeze {
\&        my $self=shift;
\&        delete $self\->{\*(Aqtie\*(Aq};
\&        return ($self,\*(Aq\->fix_tie\*(Aq,\*(Aqfix_tie\*(Aq);
\&    }
\&
\&    sub fix_tie {
\&        my $self=shift;
\&        if ( ! $self\->{\*(Aqtie\*(Aq} ) {
\&            $self\->{str}="" unless defined $self\->{str};
\&            tie my @a, \*(AqTie::Array::PackedC\*(Aq, $self\->{str};
\&            $self\->{\*(Aqtie\*(Aq} = \e@a;
\&        }
\&        return $self;
\&    }
.Ve
.PP
The \f(CW$postop\fR means the object is relatively unaffected after the
dump, the \f(CW$thaw\fR says that we should also include the method
inline as we dump. An example dump of an object like this might be
.PP
.Vb 1
\&   $Foo1=bless({ str=>\*(Aq\*(Aq },\*(AqFoo\*(Aq)\->fix_tie();
.Ve
.PP
Wheras if we omit the \f(CW\*(C`\->\*(C'\fR then we would get:
.PP
.Vb 2
\&    $Foo1=bless({ str=>\*(Aq\*(Aq },\*(AqFoo\*(Aq);
\&    $Foo1\->fix_tie();
.Ve
.PP
In our example it wouldn't actually make a difference, but the former
style can be nicer to read if the object is embedded in another.
However the non arrow notation is slightly more dangerous, in that
its possible that the internals of the object will not be fully linked
when the method is evaluated. The second form guarantees that the object
will be fully linked when the method is evaluated.
.PP
See "Controlling Hash Traversal and Display Order" for a different way
to control the representation of hash based objects.
.SS "Controlling Hash Traversal and Display Order"
.IX Subsection "Controlling Hash Traversal and Display Order"
When dumping a hash you may control the order the keys will be output
and which keys will be included. The basic idea is to specify a subroutine
which takes a hash as an argument and returns a reference to an array
containing the keys to be dumped.
.PP
You can use the \fBKeyOrder()\fR routine or the \fBSortKeys()\fR routine to
specify the sorter to be used.
.PP
The routine will be called in the following way:
.PP
.Vb 2
\&   ( $key_array, $thaw ) = $sorter\->($hash,($pass=0),$addr,$class);
\&   ( $key_array,)        = $sorter\->($hash,($pass=1),$addr,$class);
.Ve
.PP
\&\f(CW$hash\fR is the hash to be dumped, \f(CW$addr\fR is the \fBrefaddr()\fR of the
\&\f(CW$hash\fR, and \f(CW$class\fR will be set if the hash has been blessed.
.PP
When \f(CW$pass\fR is 0 the \f(CW$thaw\fR variable may be supplied as well as the
keyorder. If it is defined then it specifies what thaw action to perform
after dumping the hash. See \f(CW$thaw\fR in "Controlling Object
Representation" for details as to how it works.  This allows an object
to define those keys needed to recreate itself properly, and a followup
hook to recreate the rest.
.PP
\&\fBNote\fR that if a \fBFreezer()\fR method is defined and returns
a \f(CW$thaw\fR then the \f(CW$thaw\fR returned by the sorter
will override it.
.SS "Controlling Array Presentation and Run Length Encoding"
.IX Subsection "Controlling Array Presentation and Run Length Encoding"
By default Data::Dump::Streamer will "run length encode" array values.
This means that when an array value is simple (ie, its not referenced and
does contain a reference) and is repeated multiple times the output will
be single a list multiplier statement, and not each item output
separately. Thus: \f(CW\*(C`Dump([0,0,0,0])\*(C'\fR will be output something like
.PP
.Vb 1
\&   $ARRAY1 = [ (0) x 4 ];
.Ve
.PP
This is particularly useful when dealing with large arrays that are only
partly filled, and when accidentally the array has been made very large,
such as with the improper use of pseudo-hash notation.
.PP
To disable this feature you may set the \fBRle()\fR property to FALSE, by
default it is enabled and set to TRUE.
.SS "Installing \fIDDS\fP as a package alias"
.IX Subsection "Installing DDS as a package alias"
Its possible to have an alias to Data::Dump::Streamer created and
installed for easier usage in one liners and short scripts.
Data::Dump::Streamer is a bit long to type sometimes. However because this
technically means polluting the root level namespace, and having it listed
on CPAN, I have elected to have the installer not install it by default.
If you wish it to be installed you must explicitly state so when
Build.Pl is run:
.PP
.Vb 1
\&  perl Build.Pl DDS [Other Module::Build options]
.Ve
.PP
Then a normal './Build test, ./Build install' invocation will install DDS.
.PP
Using DDS is identical to Data::Dump::Streamer.
.SS "use-time package aliasing"
.IX Subsection "use-time package aliasing"
You can also specify an alias at use-time, then use that alias in the rest
of your program, thus avoiding the permanent (but modest) namespace
pollution of the previous method.
.PP
.Vb 1
\&  use Data::Dumper::Streamer as => \*(AqDDS\*(Aq;
\&
\&  # or if you prefer
\&  use Data::Dumper::Streamer;
\&  import Data::Dumper::Streamer as => \*(AqDDS\*(Aq;
.Ve
.PP
You can use any alias you like, but that doesn't mean you should.. Folks
doing as => 'DBI' will be mercilessly ridiculed.
.SS "PadWalker support"
.IX Subsection "PadWalker support"
If PadWalker 1.0 is installed you can use \fBDumpLex()\fR to try to
automatically determine the names of the vars being dumped. As
long as the vars being dumped have my or our declarations in scope
the vars will be correctly named. Padwalker will also be used
instead of the B:: modules when dumping closures when it is available.
.SH INTERFACE
.IX Header "INTERFACE"
.SS "Data::Dumper Compatibility"
.IX Subsection "Data::Dumper Compatibility"
For drop in compatibility with the \fBDumper()\fR usage of Data::Dumper, you may
request that the \fBDumper()\fR method is exported. It will not be exported by
default. In addition the standard \fBData::Dumper::Dumper()\fR may be exported
on request as \f(CW\*(C`DDumper\*(C'\fR. If you provide the tag \f(CW\*(C`:Dumper\*(C'\fR then both will
be exported.
.IP Dumper 4
.IX Item "Dumper"
.PD 0
.IP "Dumper LIST" 4
.IX Item "Dumper LIST"
.PD
A synonym for scalar Dump(LIST)\->Out for usage compatibility with
Data::Dumper
.IP DDumper 4
.IX Item "DDumper"
.PD 0
.IP "DDumper LIST" 4
.IX Item "DDumper LIST"
.PD
A secondary export of the actual Data::Dumper::Dumper
subroutine.
.SS Constructors
.IX Subsection "Constructors"
.IP new 4
.IX Item "new"
Creates a new Data::Dump::Streamer object. Currently takes no
arguments and simply returns the new object with a default style
configuration.
.Sp
See \f(CWDump()\fR for a better way to do things.
.IP Dump 4
.IX Item "Dump"
.PD 0
.IP "Dump VALUES" 4
.IX Item "Dump VALUES"
.PD
Smart non method based constructor.
.Sp
This routine behaves very differently depending on the context it is
called in and whether arguments are provided.
.Sp
If called with no arguments it is exactly equivalent to calling
.Sp
.Vb 1
\&  Data::Dump::Streamer\->new()
.Ve
.Sp
which means it returns an object reference.
.Sp
If called with arguments and in scalar context it is equivalent to calling
.Sp
.Vb 1
\&  Data::Dump::Streamer\->new()\->Data(@vals)
.Ve
.Sp
except that the actual depth first traversal is \fIdelayed\fR until \f(CWOut()\fR
is called.  This means that options that must be provided before the
\&\f(CWData()\fR phase can be provided after the call to \f(CWDump()\fR.  Again, it
returns a object reference.
.Sp
If called with arguments and in void or list context it is equivelent to
calling
.Sp
.Vb 1
\&  Data::Dump::Streamer\->new()\->Data(@vals)\->Out()
.Ve
.Sp
The reason this is true in list context is to make
\&\f(CW\*(C`print Dump(...),"\en";\*(C'\fR do the right thing. And also that combined with
method chaining options can be added or removed as required quite easily
and naturally.
.Sp
So to put it short:
.Sp
.Vb 3
\&  my $obj=Dump($x,$y);         # Returns an object
\&  my $str=Dump($x,$y)\->Out();  # Returns a string of the dump.
\&  my @code=Dump($x,$y);        # Returns a list of the dump.
\&
\&  Dump($x,$y);                 # prints the dump.
\&  print Dump($x,$y);           # prints the dump.
.Ve
.Sp
It should be noted that the setting of \f(CW\*(C`$\e\*(C'\fR will affect the behaviour of
both of
.Sp
.Vb 2
\&  Dump($x,$y);
\&  print Dump($x,$y);
.Ve
.Sp
but it will not affect the behaviour of
.Sp
.Vb 1
\&  print scalar Dump($x,$y);
.Ve
.Sp
\&\fBNote\fR As of 1.11 Dump also works as a method, with identical properties
as when called as a subroutine, with the exception that when called with
no arguments it is a synonym for \f(CWOut()\fR. Thus
.Sp
.Vb 1
\&  $obj\->Dump($foo)\->Names(\*(Aqfoo\*(Aq)\->Out();
.Ve
.Sp
will work fine, as will the odd looking:
.Sp
.Vb 1
\&  $obj\->Dump($foo)\->Names(\*(Aqfoo\*(Aq)\->Dump();
.Ve
.Sp
which are both the same as
.Sp
.Vb 1
\&  $obj\->Names(\*(Aqfoo\*(Aq)\->Data($foo)\->Out();
.Ve
.Sp
Hopefully this should make method use more or less DWIM.
.IP "DumpLex VALUES" 4
.IX Item "DumpLex VALUES"
DumpLex is similar to Dump except it will try to automatically determine
the names to use for the variables being dumped by using PadWalker to
have a poke around the calling lexical scope to see what is declared. If
a name for a var can't be found then it will be named according to the
normal scheme. When PadWalker isn't installed this is just a wrapper for
\&\fBDump()\fR.
.Sp
Thanks to Ovid for the idea of this. See Data::Dumper::Simple for a
similar wrapper around Data::Dumper.
.IP "DumpVars PAIRS" 4
.IX Item "DumpVars PAIRS"
This is wrapper around \fBDump()\fR which expect to receive
a list of name=>value pairs instead of a list of values.
Otherwise behaves like \fBDump()\fR. Note that names starting
with a '\-' are treated the same as those starting with '*' when
passed to \fBNames()\fR.
.SS Methods
.IX Subsection "Methods"
.IP Data 4
.IX Item "Data"
.PD 0
.IP "Data LIST" 4
.IX Item "Data LIST"
.PD
Analyzes a list of variables in breadth first order.
.Sp
If called with arguments then the internal object state is reset before
scanning the list of arguments provided.
.Sp
If called with no arguments then whatever arguments were provided to \f(CWDump()\fR
will be scanned.
.Sp
Returns \f(CW$self\fR.
.IP Out 4
.IX Item "Out"
.PD 0
.IP "Out VALUES" 4
.IX Item "Out VALUES"
.PD
Prints out a set of values to the appropriate location. If provided a list
of values then the values are first scanned with \f(CWData()\fR and then
printed, if called with no values then whatever was scanned last with
\&\f(CWData()\fR or \f(CWDump()\fR is printed.
.Sp
If the \f(CWTo()\fR attribute was provided then will dump to whatever object
was specified there (any object, including filehandles that accept the
\&\fBprint()\fR method), and will always return \f(CW$self\fR.
.Sp
If the \f(CWTo()\fR attribute was not provided then will use an internal
printing object, returning either a list or scalar or printing to STDOUT
in void context.
.Sp
This routine is virtually always called without arguments as the last
method in the method chain.
.Sp
.Vb 4
\& Dump\->Arguments(1)\->Out(@vars);
\& $obj\->Data(@vars)\->Out();
\& Dump(@vars)\->Out;
\& Data::Dump::Streamer\->Out(@vars);
.Ve
.Sp
All should DWIM.
.IP Names 4
.IX Item "Names"
.PD 0
.IP "Names LIST" 4
.IX Item "Names LIST"
.IP "Names ARRAYREF" 4
.IX Item "Names ARRAYREF"
.PD
Takes a list of strings or a reference to an array of strings to use for
var names for the objects dumped. The names may be prefixed by a *
indicating the variable is to be dumped as its dereferenced type if it is
an array, hash or code ref. Otherwise the star is ignored. Other sigils
may be prefixed but they will be silently converted to *'s.
.Sp
If no names are provided then names are generated automatically based on
the type of object being dumped, with abbreviations applied to compound
class names.
.Sp
If called with arguments then returns the object itself, otherwise in list
context returns the list of names in use, or in scalar context a reference
or undef. In void context with no arguments the names are cleared.
.Sp
\&\fBNOTE:\fR
Must be called before \f(CWData()\fR is called.
.Sp
If you wish to have no names, use Terse.
.IP Terse 4
.IX Item "Terse"
.PD 0
.IP "Terse BOOL" 4
.IX Item "Terse BOOL"
.PD
When true, no variable names will be created.  Data will be dumped as
anonymous references or values.
.Sp
.Vb 2
\&    Dump([])\->Out;              # $ARRAY1 = []
\&    Dump([])\->Terse(1)\->Out;    # []
.Ve
.IP Purity 4
.IX Item "Purity"
.PD 0
.IP "Purity BOOL" 4
.IX Item "Purity BOOL"
.PD
This option can be used to set the level of purity in the output. It
defaults to TRUE, which results in the module doing its best to ensure
that the resulting dump when \fBeval()\fRed is precisely the same as the input.
However, at times such as debugging this can be tedious, resulting in
extremely long dumps with many "fix" statements involved.  By setting
Purity to FALSE the resulting output won't necessarily be legal Perl, but
it will be more legible. In this mode the output is broadly similar to
that of the default setting of Data::Dumper (\fBPurity\fR\|(0)). When set to TRUE
the behaviour is likewise similar to Data::Dumper in \fBPurity\fR\|(1) but more
accurate.
.Sp
When \fBPurity()\fR is set to FALSE aliases will be output with a function call
wrapper of 'alias_to' whose argument will be the value the item is an
alias to. This wrapper does nothing, and is only there as a visual cue.
Likewise, 'make_ro' will be output when the value was readonly, and again
the effect is cosmetic only.
.IP To 4
.IX Item "To"
.PD 0
.IP "To STREAMER" 4
.IX Item "To STREAMER"
.PD
Specifies the object to print to. Data::Dump::Streamer can stream its
output to any object supporting the print method. This is primarily meant
for streaming to a filehandle, however any object that supports the method
will do.
.Sp
If a filehandle is specified then it is used until it is explicitly
changed, or the object is destroyed.
.IP Declare 4
.IX Item "Declare"
.PD 0
.IP "Declare BOOL" 4
.IX Item "Declare BOOL"
.PD
If Declare is True then each object is dumped with 'my' declarations
included, and all rules that follow are obeyed. (Ie, not referencing an
undeclared variable). If Declare is False then all objects are expected to
be previously defined and references to top level objects can be made at
any time.
.Sp
Defaults to False.
.IP Indent 4
.IX Item "Indent"
.PD 0
.IP "Indent INT" 4
.IX Item "Indent INT"
.PD
If Indent is True then data is output in an indented and fairly neat
fashion. If the value is 2 then hash key/value pairs and array values each
on their own line. If the value is 1 then a "smart" indenting mode is
activated where multiple key/value or values may be printed to the same
line. The heuristics for this mode are still experimental so it may
occasional not indent very nicely.
.Sp
Default is \fBIndent\fR\|(2)
.Sp
If indent is False then no indentation is done, and all optional whitespace.
is omitted. See <\fBOptSpace()\fR|/OptSpace> for more details.
.Sp
Defaults to True.
.Sp
Newlines are appended to each statement regardless of this value.
.IP Indentkeys 4
.IX Item "Indentkeys"
.PD 0
.IP "Indentkeys BOOL" 4
.IX Item "Indentkeys BOOL"
.PD
If \fBIndent()\fR and Indentkeys are True then hashes with more than one key
value pair are dumped such that the keys and values line up. Note however
this means each key has to be quoted twice. Not advised for very large
data structures. Additional logic may enhance this feature soon.
.Sp
Defaults to True.
.Sp
\&\fBNOTE:\fR
Must be set before \f(CWData()\fR is called.
.IP OptSpace 4
.IX Item "OptSpace"
.PD 0
.IP "OptSpace STR" 4
.IX Item "OptSpace STR"
.PD
Normally DDS emits a lot of whitespace in between tokens that it
emits. Using this method you can control how much whitespace it
will emit, or even if some other string should be used.
.Sp
If Indent is set to 0 then this value is automatically set to
the empty string. When Indent is set back to a non zero value
the old value will be restored if it has not been changed from
the empty string in the intervening time.
.IP "KeyOrder TYPE_OR_OBJ" 4
.IX Item "KeyOrder TYPE_OR_OBJ"
.PD 0
.IP "KeyOrder TYPE_OR_OBJ, VALUE" 4
.IX Item "KeyOrder TYPE_OR_OBJ, VALUE"
.PD
Sets or returns the key order to for use for a given type or object.
.Sp
TYPE_OR_OBJ may be a string representing a class, or "" for representing
unblessed objects, or it maybe a reference to a hash.
.Sp
VALUE may be a string representing one of built in sort mechanisms, or
it may be a reference to a subroutine, or a method name if TYPE_OR_OBJ
is not an object.
.Sp
The built in sort mechanisms are 'aphabetical'/'lexical', 'numeric',
\&'smart'/'intelligent' and 'each'.
.Sp
If VALUE is omitted returns the current value for the given type.
.Sp
If TYPE_OR_OBJ is omitted or FALSE it defaults to "" which represents
unblessed hashes.
.Sp
See "Controlling Hash Traversal and Display Order" for more details.
.IP SortKeys 4
.IX Item "SortKeys"
.PD 0
.IP "SortKeys VALUE" 4
.IX Item "SortKeys VALUE"
.PD
This is a wrapper for KeyOrder. It allows only the generic hash
sort order to be specified a little more elegantly than via \fBKeyOrder()\fR.
It is syntactically equivalent to
.Sp
.Vb 1
\&  $self\->KeyOrder( "", @_ );
.Ve
.IP Verbose 4
.IX Item "Verbose"
.PD 0
.IP "Verbose BOOL" 4
.IX Item "Verbose BOOL"
.PD
If Verbose is True then when references that cannot be resolved in a
single statement are encountered the reference is substituted for a
descriptive tag saying what type of forward reference it is, and to what
is being referenced. The type is provided through a prefix, "R:" for
reference, and "A:" for alias, "V:" for a value and then the name of the
var in a string. Automatically generated var names are also reduced to
the shortest possible unique abbreviation, with some tricks thrown in
for Long::Class::Names::Like::This (which would abbreviate most likely
to LCNLT1)
.Sp
If Verbose if False then a simple placeholder saying 'A' or 'R' is
provided. (In most situations perl requires a placeholder, and as such
one is always provided, even if technically it could be omitted.)
.Sp
This setting does not change the followup statements that fix up the
structure, and does not result in a loss of accuracy, it just makes it a
little harder to read. OTOH, it means dumps can be quite a bit smaller
and less noisy.
.Sp
Defaults to True.
.Sp
\&\fBNOTE:\fR
Must be set before \f(CWData()\fR is called.
.IP DumpGlob 4
.IX Item "DumpGlob"
.PD 0
.IP "DumpGlob BOOL" 4
.IX Item "DumpGlob BOOL"
.PD
If True then globs will be followed and fully defined, otherwise the globs
will still be referenced but their current value will not be set.
.Sp
Defaults to True
.Sp
\&\fBNOTE:\fR
Must be set before \f(CWData()\fR is called.
.IP Deparse 4
.IX Item "Deparse"
.PD 0
.IP "Deparse BOOL" 4
.IX Item "Deparse BOOL"
.PD
If True then CODE refs will be deparsed use B::Deparse and
included in the dump. If it is False the a stub subroutine reference will
be output as per the setting of \f(CWCodeStub()\fR.
.Sp
Caveat Emptor, dumping subroutine references is hardly a secure act, and
it is provided here only for convenience.
.Sp
Note using this routine is at your own risk as of DDS 1.11, how it
interacts with the newer advanced closure dumping process is undefined.
.IP EclipseName 4
.IX Item "EclipseName"
.PD 0
.IP "EclipseName SPRINTF_FORMAT" 4
.IX Item "EclipseName SPRINTF_FORMAT"
.PD
When necessary DDS will rename vars output during deparsing with this
value. It is a sprintf format string that should contain only and both of
the "%s" and a "%d" formats in any order along with whatever other literal
text you want in the name. No checks are performed on the validity of this
value so be careful. It defaults to
.Sp
.Vb 1
\&  "%s_eclipse_%d"
.Ve
.Sp
where the "%s" represents the name of the var being eclipsed, and the "%d"
a counter to ensure all such mappings are unique.
.IP DeparseOpts 4
.IX Item "DeparseOpts"
.PD 0
.IP "DeparseOpts LIST" 4
.IX Item "DeparseOpts LIST"
.IP "DeparseOpts ARRAY" 4
.IX Item "DeparseOpts ARRAY"
.PD
If Deparse is True then these options will be passed to B::Deparse\->\fBnew()\fR
when dumping a CODE ref. If passed a list of scalars the list is used as
the arguments. If passed an array reference then this array is assumed to
contain a list of arguments. If no arguments are provided returns a an
array ref of arguments in scalar context, and a list of arguments in list
context.
.Sp
Note using this routine is at your own risk as of DDS 1.11, how it
interacts with the newer advanced closure dumping process is undefined.
.IP CodeStub 4
.IX Item "CodeStub"
.PD 0
.IP "CodeStub STRING" 4
.IX Item "CodeStub STRING"
.PD
If Deparse is False then this string will be used in place of CODE
references. Its the users responsibility to make sure its compilable and
blessable.
.Sp
Defaults to 'sub { Carp::confess "Dumped code stub!" }'
.IP FormatStub 4
.IX Item "FormatStub"
.PD 0
.IP "FormatStub STRING" 4
.IX Item "FormatStub STRING"
.PD
If Deparse is False then this string will be used in place of FORMAT
references. Its the users responsibility to make sure its compilable and
blessable.
.Sp
Defaults to 'do{ local *F; eval "format F =\enFormat Stub\en.\en"; *F{FORMAT} }'
.IP DeparseGlob 4
.IX Item "DeparseGlob"
.PD 0
.IP "DeparseGlob BOOL" 4
.IX Item "DeparseGlob BOOL"
.PD
If Deparse is TRUE then this style attribute will determine if subroutines
and FORMAT's contained in globs that are dumped will be deparsed or not.
.Sp
Defaults to True.
.IP Dualvars 4
.IX Item "Dualvars"
.PD 0
.IP "Dualvars BOOL" 4
.IX Item "Dualvars BOOL"
.IP Dualvars 4
.IX Item "Dualvars"
.IP "Dualvars BOOL" 4
.IX Item "Dualvars BOOL"
.PD
If TRUE then dualvar checking will occur and the required statements
emitted to recreate dualvars when they are encountered, otherwise items
will be dumped in their stringified form always. It defaults to TRUE.
.IP Rle 4
.IX Item "Rle"
.PD 0
.IP "Rle BOOL" 4
.IX Item "Rle BOOL"
.IP RLE 4
.IX Item "RLE"
.IP "RLE BOOL" 4
.IX Item "RLE BOOL"
.PD
If True then arrays will be run length encoded using the \f(CW\*(C`x\*(C'\fR operator.
What this means is that if an array contains repeated elements then
instead of outputting each and every one a list multiplier will be output.
This means that considerably less space is taken to dump redundant data.
.IP Freezer 4
.IX Item "Freezer"
.PD 0
.IP "Freezer ACTION" 4
.IX Item "Freezer ACTION"
.IP "Freezer CLASS, ACTION" 4
.IX Item "Freezer CLASS, ACTION"
.PD
This method can be used to override the DDS_freeze hook for a
specific class. If CLASS is omitted then the ACTION applies to
all blessed object.
.Sp
If ACTION is false it indicates that the given CLASS should not
have any serilization hooks called.
.Sp
If ACTION is a string then it is taken to be the method name that
will be executed to freeze the object. CLASS\->can(METHOD) must return
true or the setting will be ignored.
.Sp
If ACTION is a code ref it is executed with the object as the argument.
.Sp
When called with no arguments returns in scalar context the generic
serialization method (defaults to 'DDS_freeze'), in list context
returns the generic serialization method followed by a list of pairs
of Classname=>ACTION.
.Sp
If the action executes a sub or method it is expected to return
a list of three values:
.Sp
.Vb 1
\&   ( $proxy, $thaw, $postdump )=$obj\->DDS_Freeze();
.Ve
.Sp
See "Controlling Object Representation" for more details.
.Sp
\&\fBNOTE:\fR
Must be set before \f(CWData()\fR is called.
.IP Ignore 4
.IX Item "Ignore"
.PD 0
.IP "Ignore OBJ_OR_CLASS" 4
.IX Item "Ignore OBJ_OR_CLASS"
.IP "Ignore OBJ_OR_CLASS, BOOL" 4
.IX Item "Ignore OBJ_OR_CLASS, BOOL"
.PD
Allows a given object or class to be ignored, and replaced with
a string containing the name of the item ignored.
.Sp
If called with no args returns a list of items ignored (using the refaddr
to represent objects). If called with a single argument returns whether
that argument is ignored. If called with more than one arguments then
expects a list of pairs of object => is_ignored.
.Sp
Returns \f(CW$self\fR when setting.
.Sp
\&\fBNOTE:\fR
Must be set before \f(CWData()\fR is called.
.IP Compress 4
.IX Item "Compress"
.PD 0
.IP "Compress SIZE" 4
.IX Item "Compress SIZE"
.PD
Controls compression of string values (not keys). If this value
is nonzero and a string to be dumped is longer than its value then
the \fBCompressor()\fR if defined is used to compress
the string.  Setting size to \-1 will cause all strings to be
processed, setting size to 0 will cause no strings to be processed.
.IP Compressor 4
.IX Item "Compressor"
.PD 0
.IP "Compressor CODE" 4
.IX Item "Compressor CODE"
.PD
This attribute is used to control the compression of strings.
It is expected to be a reference to a subroutine with the following
interface:
.Sp
.Vb 2
\&  my $prelude_code=$compressor\->(); # no arguments.
\&  my $code=$compressor\->(\*(Aqstring\*(Aq); # string argument
.Ve
.Sp
The sub will be called with no arguments at the beginning of the
dump to allow any require statements or similar to be added. During
the dump the sub will be called with a single argument when
compression is required. The code returned in this case is expected
to be an EXPR that will evaluate back to the original string.
.Sp
By default DDS will use Compress::Zlib in conjunction with
MIME::Base64 to do compression and encoding, and exposes the
\&'usqz' subroutine for handling the decoding and decompression.
.Sp
The abbreviated name was chosen as when using the default compressor
every string will be represented by a string like
.Sp
.Vb 1
\&   usqz(\*(Aq....\*(Aq)
.Ve
.Sp
Meaning that eight characters are required without considering the
data itself. Likewise Base64 was chosen because it is a representation
that is high-bit safe, compact and easy to quote. Escaped strings are
much less efficient for storing binary data.
.SS "Reading the Output"
.IX Subsection "Reading the Output"
As mentioned in Verbose there is a notation used to make understanding
the output easier. However at first glance it can probably be a bit
confusing. Take the following example:
.PP
.Vb 6
\&    my $x=1;
\&    my $y=[];
\&    my $array=sub{\e@_ }\->( $x,$x,$y );
\&    push @$array,$y,1;
\&    unshift @$array,\e$array\->[\-1];
\&    Dump($array);
.Ve
.PP
Which prints (without the comments of course):
.PP
.Vb 11
\&    $ARRAY1 = [
\&                \*(AqR: $ARRAY1\->[5]\*(Aq,        # resolved by fix 1
\&                1,
\&                \*(AqA: $ARRAY1\->[1]\*(Aq,        # resolved by fix 2
\&                [],
\&                \*(AqV: $ARRAY1\->[3]\*(Aq,        # resolved by fix 3
\&                1
\&              ];
\&    $ARRAY1\->[0] = \e$ARRAY1\->[5];         # fix 1
\&    alias_av(@$ARRAY1, 2, $ARRAY1\->[1]);  # fix 2
\&    $ARRAY1\->[4] = $ARRAY1\->[3];          # fix 3
.Ve
.PP
The first entry, \f(CW\*(AqR: $ARRAY1\->[5]\*(Aq\fR indicates that this slot in the
array holds a reference to the currently undefined \f(CW\*(C`$ARRAY1\->[5]\*(C'\fR,
and as such the value will have to be provided later in what the author
calls 'fix' statements. The third entry \f(CW\*(AqA: $ARRAY1\->[1]\*(Aq\fR indicates
that is element of the array is in fact the exact same scalar as exists in
\&\f(CW\*(C`$ARRAY1\->[1]\*(C'\fR, or is in other words, an alias to that variable.
Again, this cannot be expressed in a single statement and so generates
another, different, fix statement. The fifth entry \f(CW\*(AqV: $ARRAY1\->[3]\*(Aq\fR
indicates that this slots holds a value (actually a reference value)
that is identical to one elsewhere, but is currently undefined.  In this
case it is because the value it needs is the reference returned by the
anonymous array constructor in the fourth element (\f(CW\*(C`$ARRAY1\->[3]\*(C'\fR).
Again this results in yet another different fix statement.  If \fBVerbose()\fR
is off then only a 'R' 'A' or 'V' tag is emitted as a marker of some form
is necessary.
.PP
All of this specialized behaviour can be bypassed by setting \fBPurity()\fR to
FALSE, in which case the output will look very similar to what
Data::Dumper outputs in low Purity setting.
.PP
In a later version I'll try to expand this section with more examples.
.SS "A Note About Speed"
.IX Subsection "A Note About Speed"
Data::Dumper is much faster than this module for many things. However IMO
it is less readable, and definitely less accurate. YMMV.
.SH EXPORT
.IX Header "EXPORT"
By default exports the \fBDump()\fR command. Or may export on request the same
command as \fBStream()\fR. A Data::Dumper::Dumper compatibility routine is
provided via requesting Dumper and access to the real Data::Dumper::Dumper
routine is provided via DDumper. The later two are exported together with
the :Dumper tag.
.PP
Additionally there are a set of internally used routines that are exposed.
These are mostly direct copies of routines from Array::RefElem,
Lexical::Alias and Scalar::Util, however some where marked have had their
semantics slightly changed, returning defined but false instead of undef
for negative checks, or throwing errors on failure.
.PP
The following XS subs (and tagnames for various groupings) are exportable
on request.
.PP
.Vb 3
\&  :Dumper
\&        Dumper
\&        DDumper
\&
\&  :undump          # Collection of routines needed to undump something
\&        alias_av              # aliases a given array value to a scalar
\&        alias_hv              # aliases a given hashes value to a scalar
\&        alias_ref             # aliases a scalar to another scalar
\&        make_ro               # makes a scalar read only
\&        lock_keys             # pass through to Hash::Util::lock_keys
\&        lock_keys_plus        # like lock_keys, but adds keys to those present
\&        lock_ref_keys         # like lock_keys but operates on a hashref
\&        lock_ref_keys_plus    # like lock_keys_plus but operates on a hashref
\&        dualvar               # make a variable with different string/numeric
\&                              # representation
\&        alias_to              # pretend to return an alias, used in low
\&                              # purity mode to indicate a value is actually
\&                              # an alias to something else.
\&
\&  :alias           # all croak on failure
\&     alias_av(@Array,$index,$var);
\&     alias_hv(%hash,$key,$var);
\&     alias_ref(\e$var1,\e$var2);
\&     push_alias(@array,$var);
\&
\&  :util
\&     blessed($var)           #undef or a class name.
\&     isweak($var)            #returns true if $var contains a weakref
\&     reftype($var)           #the underlying type or false but defined.
\&     refaddr($var)           #a references address
\&     refcount($var)          #the number of times a reference is referenced
\&     sv_refcount($var)       #the number of times a scalar is referenced.
\&     weak_refcount($var)     #the number of weakrefs to an object.
\&                             #sv_refcount($var)\-weak_refcount($var) is the true
\&                             #SvREFCOUNT() of the var.
\&     looks_like_number($var) #if perl will think this is a number.
\&
\&     regex($var)     # In list context returns the pattern and the modifiers,
\&                     # in scalar context returns the pattern in (?msix:) form.
\&                     # If not a regex returns false.
\&     readonly($var)  # returns whether the $var is readonly
\&     weaken($var)    # cause the reference contained in var to become weak.
\&     make_ro($var)   # causes $var to become readonly, returns the value of $var.
\&     reftype_or_glob # returns the reftype of a reference, or if its not
\&                     # a reference but a glob then the globs name
\&     refaddr_or_glob # similar to reftype_or_glob but returns an address
\&                     # in the case of a reference.
\&     globname        # returns an evalable string to represent a glob, or
\&                     # the empty string if not a glob.
\&  :all               # (Dump() and Stream() and Dumper() and DDumper()
\&                     #  and all of the XS)
\&  :bin               # (not Dump() but all of the rest of the XS)
.Ve
.PP
By default exports only \fBDump()\fR, \fBDumpLex()\fR and \fBDumpVars()\fR. Tags are
provided for exporting 'all' subroutines, as well as 'bin' (not \fBDump()\fR),
\&'util' (only introspection utilities) and 'alias' for the aliasing
utilities. If you need to ensure that you can eval the results (undump)
then use the 'undump' tag.
.SH BUGS
.IX Header "BUGS"
Code with this many debug statements is certain to have errors. :\-)
.PP
Please report them with as much of the error output as possible.
.PP
Be aware that to a certain extent this module is subject to whimsies of
your local perl. The same code may not produce the same dump on two
different installs and versions. Luckily these don't seem to pop up often.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Yves Orton, yves at cpan org.
.PP
Copyright (C) 2003\-2005 Yves Orton
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Contains code derived from works by Gisle Aas, Graham Barr, Jeff Pinyan,
Richard Clamp, and Gurusamy Sarathy.
.PP
Thanks to Dan Brook, Yitzchak Scott-Thoennes, eric256, Joshua ben
Jore, Jim Cromie, Curtis "Ovid" Poe, Lars Dɪᴇᴄᴋᴏᴡ, and anybody that
I've forgotten for patches, feedback and ideas.
.SH "SEE ALSO (its a crowded space, isn't it!)"
.IX Header "SEE ALSO (its a crowded space, isn't it!)"
Data::Dumper
\&\- the mother of them all
.PP
Data::Dumper::Simple
\&\- Auto named vars with source filter interface.
.PP
Data::Dumper::Names
\&\- Auto named vars without source filtering.
.PP
Data::Dumper::EasyOO
\&\- easy to use wrapper for DD
.PP
Data::Dump
\&\- Has cool feature to squeeze data
.PP
Data::Dump::Streamer
\&\- The best perl dumper. But I would say that. :\-)
.PP
Data::TreeDumper
\&\- Non perl output, lots of rendering options
.PP
And of course www.perlmonks.org and perl itself.
