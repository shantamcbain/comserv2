.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Producer::TTSchema 3pm"
.TH SQL::Translator::Producer::TTSchema 3pm 2024-11-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Translator::Producer::TTSchema \-
    Produces output using the Template Toolkit from a SQL schema
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 7
\&  use SQL::Translator;
\&  my $translator     = SQL::Translator\->new(
\&      from           => \*(AqMySQL\*(Aq,
\&      filename       => \*(Aqfoo_schema.sql\*(Aq,
\&      to             => \*(AqTTSchema\*(Aq,
\&      producer_args  => {
\&          ttfile     => \*(Aqfoo_template.tt\*(Aq,  # Template file to use
\&
\&          # Extra template variables
\&          tt_vars     => {
\&              author => "Mr Foo",
\&          },
\&
\&          # Template config options
\&          tt_conf     => {
\&              INCLUDE_PATH => \*(Aq/foo/templates\*(Aq,
\&          },
\&      },
\&  );
\&  print $translator\->translate;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Produces schema output using a given Template Tookit template.
.PP
It needs one additional producer arg of \f(CW\*(C`ttfile\*(C'\fR which is the file
name of the template to use.  This template will be passed a variable
called \f(CW\*(C`schema\*(C'\fR, which is the \f(CW\*(C`SQL::Translator::Producer::Schema\*(C'\fR object
created by the parser. You can then use it to walk the schema via the
methods documented in that module.
.PP
Here's a brief example of what the template could look like:
.PP
.Vb 9
\&  database: [% schema.database %]
\&  tables:
\&  [% FOREACH table = schema.get_tables %]
\&      [% table.name %]
\&      ================
\&      [% FOREACH field = table.get_fields %]
\&          [% field.name %]   [% field.data_type %]([% field.size %])
\&      [% END \-%]
\&  [% END %]
.Ve
.PP
See \fIt/data/template/basic.tt\fR for a more complete example.
.PP
The template will also get the set of extra variables given as a
hashref via the \f(CW\*(C`tt_vars\*(C'\fR producer arg. (Note that the old style of
passing this config in the \f(CW\*(C`ttargs\*(C'\fR producer arg has been
deprecated).
.PP
You can set any of the options used to initialize the Template object by
adding a \f(CW\*(C`tt_conf\*(C'\fR producer arg. See Template Toolkit docs for details of
the options.
(Note that the old style of passing this config directly in the \f(CW\*(C`ttargs\*(C'\fR producer args
has been deprecated).
.PP
.Vb 11
\&  $translator          = SQL::Translator\->new(
\&      to               => \*(AqTT\*(Aq,
\&      producer_args    => {
\&          ttfile       => \*(Aqfoo_template.tt\*(Aq,
\&          tt_vars      => {},
\&          tt_conf      => {
\&            INCLUDE_PATH => \*(Aq/foo/templates/tt\*(Aq,
\&            INTERPOLATE  => 1,
\&          }
\&      },
\&  );
.Ve
.PP
You can use this producer to create any type of text output you like,
even using it to create your own versions of what the other producers
make.  For example, you could create a template that translates the
schema into MySQL's syntax, your own HTML documentation, your own
Class::DBI classes (or some other code) \-\- the opportunities are
limitless!
.SS "Producer Args"
.IX Subsection "Producer Args"
.IP ttfile 4
.IX Item "ttfile"
The template file to generate the output with.
.IP tt_vars 4
.IX Item "tt_vars"
A hash ref of extra variables you want to add to the template.
.IP tt_conf 4
.IX Item "tt_conf"
A hash ref of configuration options to pass to the Template object's
constructor.
.SH AUTHOR
.IX Header "AUTHOR"
Mark Addison <grommit@users.sourceforge.net>.
.SH TODO
.IX Header "TODO"
\&\fBMore template vars?\fR e.g. [% tables %] as a shortcut for
[% schema.get_tables %].
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Translator.
