.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::SQLMaker::Role::SQLA2Passthrough 3pm"
.TH DBIx::Class::SQLMaker::Role::SQLA2Passthrough 3pm 2021-01-21 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::SQLMaker::Role::SQLA2Passthrough \- A test of future possibilities
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.IP \(bu 4
select and group_by options are processed using the richer SQLA2 code
.IP \(bu 4
expand_join_condition is provided to more easily express rich joins
.PP
See \f(CW\*(C`examples/sqla2passthrough.pl\*(C'\fR for a small amount of running code.
.SH SETUP
.IX Header "SETUP"
.Vb 5
\&  (on_connect_call => sub {
\&     my ($storage) = @_;
\&     $storage\->sql_maker
\&             \->with::roles(\*(AqDBIx::Class::SQLMaker::Role::SQLA2Passthrough\*(Aq);
\&  })
.Ve
.SS expand_join_condition
.IX Subsection "expand_join_condition"
.Vb 8
\&  _\|_PACKAGE_\|_\->has_many(minions => \*(AqBlah::Person\*(Aq => sub {
\&    my ($args) = @_;
\&    $args\->{self_resultsource}
\&         \->schema\->storage\->sql_maker
\&         \->expand_join_condition(
\&             $args
\&           );
\&  });
.Ve
.SS on
.IX Subsection "on"
.Vb 4
\&  _\|_PACKAGE_\|_\->has_many(minions => \*(AqBlah::Person\*(Aq => on {
\&    { \*(Aqself.group_id\*(Aq => \*(Aqforeign.group_id\*(Aq,
\&      \*(Aqself.rank\*(Aq => { \*(Aq>\*(Aq, \*(Aqforeign.rank\*(Aq } }
\&  });
.Ve
.PP
Or with ParameterizedJoinHack,
.PP
.Vb 10
\&  _\|_PACKAGE_\|_\->parameterized_has_many(
\&      priority_tasks => \*(AqMySchema::Result::Task\*(Aq,
\&      [[\*(Aqmin_priority\*(Aq] => sub {
\&          my $args = shift;
\&          return +{
\&              "$args\->{foreign_alias}.owner_id" => {
\&                  \-ident => "$args\->{self_alias}.id",
\&              },
\&              "$args\->{foreign_alias}.priority" => {
\&                  \*(Aq>=\*(Aq => $_{min_priority},
\&              },
\&          };
\&      }],
\&  );
.Ve
.PP
becomes
.PP
.Vb 7
\&  _\|_PACKAGE_\|_\->parameterized_has_many(
\&      priority_tasks => \*(AqMySchema::Result::Task\*(Aq,
\&      [[\*(Aqmin_priority\*(Aq] => on {
\&        { \*(Aqforeign.owner_id\*(Aq => \*(Aqself.id\*(Aq,
\&          \*(Aqforeign.priority\*(Aq => { \*(Aq>=\*(Aq, { \-value => $_{min_priority} } } }
\&      }]
\&  );
.Ve
.PP
Note that foreign/self can appear in such a condition on either side, BUT
if you want DBIx::Class to be able to use a join-less version you must
ensure that the LHS is all foreign columns, i.e.
.PP
.Vb 6
\&  on {
\&    +{
\&      \*(Aqforeign.x\*(Aq => \*(Aqself.x\*(Aq,
\&      \*(Aqself.y\*(Aq => { \-between => [ \*(Aqforeign.y1\*(Aq, \*(Aqforeign.y2\*(Aq ] }
\&    }
\&  }
.Ve
.PP
is completely valid but DBIC will insist on doing a JOIN even if you
have a fully populated row object to call \f(CW\*(C`search_related\*(C'\fR on \- to avoid
the spurious JOIN, you must specify it with explicit LHS foreign cols as:
.PP
.Vb 7
\&  on {
\&    +{
\&      \*(Aqforeign.x\*(Aq => \*(Aqself.x\*(Aq,
\&      \*(Aqforeign.y1\*(Aq => { \*(Aq<=\*(Aq, \*(Aqself.y\*(Aq },
\&      \*(Aqforeign.y2\*(Aq => { \*(Aq>=\*(Aq, \*(Aqself.y\*(Aq },
\&    }
\&  }
.Ve
