.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CGI::Struct 3pm"
.TH CGI::Struct 3pm 2012-11-24 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
CGI::Struct \- Build structures from CGI data
.SH VERSION
.IX Header "VERSION"
Version 1.21
.SH SYNOPSIS
.IX Header "SYNOPSIS"
This module allows transforming CGI GET/POST data into intricate data
structures.  It is reminiscent of PHP's building arrays from form data,
but with a perl twist.
.PP
.Vb 5
\&  use CGI;
\&  use CGI::Struct;
\&  my $cgi = CGI\->new;
\&  my %params = $cgi\->Vars;
\&  my $struct = build_cgi_struct \e%params;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
CGI::Struct lets you transform CGI data keys that \fIlook like\fR perl data
structures into \fIactual\fR perl data structures.
.PP
CGI::Struct makes no attempt to actually \fIread in\fR the variables from
the request.  You should be using CGI or some equivalent for that.
CGI::Struct expects to be handed a reference to a hash containing all the
keys/values you care about.  The common way is to use something like
\&\f(CW\*(C`CGI\->Vars\*(C'\fR or (as the author does)
\&\f(CW\*(C`Plack::Request\->parameters\->mixed\*(C'\fR.
.PP
Whatever you use should give you a hash mapping the request variable
names (keys) to the values sent in by the users (values).  Any of the
major CGIish modules will have such a method; consult the documentation
for yours if you don't know it offhand.
.PP
Of course, this isn't necessarily tied strictly to CGI; you \fIcould\fR use
it to build data structures from any other source with similar syntax.
All CGI::Struct does is take one hash (reference) and turn it into
another hash (reference).  However, it's aimed at CGI uses, so it may or
may not work for something else.
.SH EXAMPLES
.IX Header "EXAMPLES"
.SS "Basic Usage"
.IX Subsection "Basic Usage"
.Vb 5
\&  <form action="request.cgi">
\&   Name:    <input type="text" name="uinfo{name}">
\&   Address: <input type="text" name="uinfo{addr}">
\&   Email:   <input type="text" name="uinfo{email}">
\&  </form>
.Ve
.PP
When filled out and submitted the data will come in to request.cgi, which
will use something like \f(CW\*(C`CGI\->Vars\*(C'\fR to parse it out into a hash
.PP
.Vb 3
\&  use CGI;
\&  my $cgi = CGI\->new;
\&  my %params = $cgi\->Vars;
.Ve
.PP
You'll wind up with something like
.PP
.Vb 5
\&  %params = (
\&      \*(Aquinfo{name}\*(Aq  => \*(AqBob\*(Aq,
\&      \*(Aquinfo{addr}\*(Aq  => \*(Aq123 Main Street\*(Aq,
\&      \*(Aquinfo{email}\*(Aq => \*(Aqbob@bob.bob\*(Aq,
\&  )
.Ve
.PP
Now we use CGI::Struct to parse that out
.PP
.Vb 2
\&  use CGI::Struct;
\&  my $struct = build_cgi_struct \e%params;
.Ve
.PP
and we wind up with a structure that looks more like
.PP
.Vb 7
\&  $struct = {
\&      \*(Aquinfo\*(Aq => {
\&          name  => \*(AqBob\*(Aq,
\&          addr  => \*(Aq123 Main Street\*(Aq,
\&          email => \*(Aqbob@bob.bob\*(Aq,
\&      }
\&  }
.Ve
.PP
which is much simpler to use in your code.
.SS Arrays
.IX Subsection "Arrays"
CGI::Struct also has the ability to build out arrays.
.PP
.Vb 3
\& First cousin:  <input type="text" name="cousins[0]">
\& Second cousin: <input type="text" name="cousins[1]">
\& Third cousin:  <input type="text" name="cousins[2]">
.Ve
.PP
Run it through CGI to get the parameters, run through
"build_cgi_struct", and we get
.PP
.Vb 7
\&  $struct = {
\&      \*(Aqcousins\*(Aq => [
\&        \*(AqJill\*(Aq,
\&        \*(AqJoe\*(Aq,
\&        \*(AqJudy\*(Aq
\&      ]
\&  }
.Ve
.PP
Of course, most CGIish modules will roll that up into an array if you
just call it 'cousins' and have multiple inputs.  But this lets you
specify the indices.  For instance, you may want to base the array from 1
instead of 0:
.PP
.Vb 3
\& First cousin:  <input type="text" name="cousins[1]">
\& Second cousin: <input type="text" name="cousins[2]">
\& Third cousin:  <input type="text" name="cousins[3]">
\&
\&  $struct = {
\&      \*(Aqcousins\*(Aq => [
\&        undef,
\&        \*(AqJill\*(Aq,
\&        \*(AqJoe\*(Aq,
\&        \*(AqJudy\*(Aq
\&      ]
\&  }
.Ve
.PP
See also the "Auto-arrays" section.
.PP
\fINULL delimited multiple values\fR
.IX Subsection "NULL delimited multiple values"
.PP
When using CGI's \f(CW\*(C`\->Vars\*(C'\fR and similar, multiple passed values
will wind up as a \f(CW\*(C`\e0\*(C'\fR\-delimited string, rather than an array ref.  By
default, CGI::Struct will split it out into an array ref.  This behavior
can by disabled by using the \f(CW\*(C`nullsplit\*(C'\fR config param; see the
function doc below.
.SS "Deeper and deeper"
.IX Subsection "Deeper and deeper"
Specifying arrays explicitly is also useful when building arbitrarily
deep structures, since the array doesn't have to be at the end
.PP
.Vb 1
\&  <select name="users{bob}{cousins}[5]{firstname}">
.Ve
.PP
After a quick trip through "build_cgi_struct", that'll turn into
\&\f(CW\*(C`$struct\->{users}{bob}{cousins}[5]{firstname}\*(C'\fR just like you'd expect.
.SS "Dotted hashes"
.IX Subsection "Dotted hashes"
Also supported is dot notation for hash keys.  This saves you a few
keystrokes, and can look neater.  Hashes may be specified with either
the \f(CW\*(C`.\*(C'\fR or with \f(CW\*(C`{}\*(C'\fR.  Arrays can only be written with \f(CW\*(C`[]\*(C'\fR.
.PP
The above \f(CW\*(C`select\*(C'\fR could be written using dots for some or all of the
hash keys instead, looking a little Javascript-ish
.PP
.Vb 3
\&  <select name="users.bob.cousins[5].firstname">
\&  <select name="users.bob{cousins}[5].firstname">
\&  <select name="users{bob}.cousins[5]{firstname}">
.Ve
.PP
of course, you wouldn't really want to mix-and-match in one field in
practice; it just looks silly.
.PP
Sometimes, though, you may want to have dots in field names, and you
wouldn't want this parsing to happen then.  It can be disabled for a run
of "build_cgi_struct" by passing a config param in; see the function
doc below.
.SS Auto-arrays
.IX Subsection "Auto-arrays"
CGI::Struct also builds 'auto\-arrays', which is to say it turns
parameters ending with an empty \f(CW\*(C`[]\*(C'\fR into arrays and pushes things onto
them.
.PP
.Vb 1
\&  <select multiple="multiple" name="users[]">
.Ve
.PP
turns into
.PP
.Vb 1
\&  $struct\->{users} = [\*(Aqlots\*(Aq, \*(Aqof\*(Aq, \*(Aqchoices\*(Aq];
.Ve
.PP
This may seem unnecessary, given the ability of most CGI modules to
already build the array just by having multiple \f(CW\*(C`users\*(C'\fR params given.
Also, since "build_cgi_struct" only sees the data after your CGI module
has already parsed it out, it will only ever see a single key in its
input hash for any name anyway, since hashes can't have multiple keys
with the same name anyway.
.PP
However, there are a few uses for it.  PHP does this, so it makes for an
easier transition.  Also, it forces an array, so if you only chose one
entry in the list, "build_cgi_struct" would still make that element in
the structure a (single-element) array
.PP
.Vb 1
\&  $struct\->{users} = [\*(Aqone choice\*(Aq];
.Ve
.PP
which makes your code a bit simpler, since you don't have to expect both
a scalar and an array in that place (though of course you should make
sure it's what you expect for robustness).
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.SS build_cgi_struct
.IX Subsection "build_cgi_struct"
.Vb 1
\&  $struct = build_cgi_struct \e%params;
\&
\&  $struct = build_cgi_struct \e%params, \e@errs;
\&
\&  $struct = build_cgi_struct \e%params, \e@errs, \e%conf;
.Ve
.PP
\&\f(CWbuild_cgi_struct()\fR is the only function provided by this module.  It
takes as an argument a reference to a hash of parameter name keys and
parameter value values.  It returns a reference to a hash with the fully
built up structure.  Any keys that can't be figured out are not present
in the returned hash.
.PP
An optional array reference can be passed as the second argument, in
which case the array will be filled in with any warnings or errors found
in trying to build the structure.  This should be taken as a debugging
tool for the developer's eyes to parse, not a source of friendly-looking
warnings to hand to non-technical users or as strongly formatted strings
for automated error mining.
.PP
A hash reference may be supplied as a third argument for passing config
parameters.  The currently supported parameters are:
.IP nodot 4
.IX Item "nodot"
This allows you to disable processing of \f(CW\*(C`.\*(C'\fR as a hash element
separator.  There may be cases where you want a \f(CW\*(C`.\*(C'\fR as part of a field
name, so this lets you still use \f(CW\*(C`{}\*(C'\fR and \f(CW\*(C`[]\*(C'\fR structure in those
cases.
.Sp
The default is \fBfalse\fR (i.e., \fIdo\fR use \f(CW\*(C`.\*(C'\fR as separator).  Pass a true
value (like \f(CW1\fR) to \fBnot\fR do so.
.IP nullsplit 4
.IX Item "nullsplit"
\&\f(CW\*(C`CGI\->Vars\*(C'\fR and compatible functions tend to, in hash form, wind up
with a NULL-delimited list rather than an array ref when passed multiple
values with the same key.  CGI::Struct will check string values for
embedded \f(CW\*(C`\e0\*(C'\fR's and, if found, \f(CW\*(C`split\*(C'\fR the string on them and create an
arrayref.
.Sp
The \f(CW\*(C`nullsplit\*(C'\fR config param lets you disable this if you want strings
with embedded \f(CW\*(C`\e0\*(C'\fR to pass through unmolested.  Pass a false value (like
\&\f(CW0\fR) to disable the splitting.
.IP dclone 4
.IX Item "dclone"
By default, CGI::Struct uses Storable's \f(CW\*(C`dclone\*(C'\fR to do deep copies of
incoming data structures.  This ensures that whatever changes you might
make to \f(CW$struct\fR later on don't change stuff in \f(CW%params\fR too.  By
setting dclone to a \fBfalse\fR value (like \f(CW0\fR) you can disable this, and
make it so deeper refs in the data structures point to the same items.
.Sp
You probably don't want to do this, unless some data is so huge you don't
want to keep 2 copies around, or you really \fIdo\fR want to edit the
original \f(CW%params\fR for some reason.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI, CGI::Simple, CGI::Minimal, Plack, and many other choices
for handling transforming a browser's request info a data structure
suitable for parsing.
.PP
CGI::State is somewhat similar to CGI::Struct, but is extremely
tightly coupled to CGI and doesn't have as much flexibility in the
structures it can build.
.PP
CGI::Expand also does similar things, but is more closely tied to
CGI or a near-equivalent.  It tries to DWIM hashes and arrays using
only a single separator.
.PP
The structure building done here is a perlish equivalent to the structure
building PHP does with passed-in parameters.
.SH AUTHOR
.IX Header "AUTHOR"
Matthew Fuller, \f(CW\*(C`<fullermd@over\-yonder.net>\*(C'\fR
.SH BUGS
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-cgi\-struct at
rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=CGI\-Struct>.  I will be
notified, and then you'll automatically be notified of progress on your
bug as I make changes.
.SH "SUPPORTED VERSIONS"
.IX Header "SUPPORTED VERSIONS"
CGI::Struct should work on perl 5.6 and later.  It includes a
comprehensive test suite, so passing that should be an indicator that it
works.  If that's not the case, I want to hear about it so the testing
can be improved!
.SH SUPPORT
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc CGI::Struct
.Ve
.PP
You can also look for information at:
.IP \(bu 4
RT: CPAN's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=CGI\-Struct>
.IP \(bu 4
AnnoCPAN: Annotated CPAN documentation
.Sp
<http://annocpan.org/dist/CGI\-Struct>
.IP \(bu 4
CPAN Ratings
.Sp
<http://cpanratings.perl.org/d/CGI\-Struct>
.IP \(bu 4
Search CPAN
.Sp
<http://search.cpan.org/dist/CGI\-Struct/>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2010\-2012 Matthew Fuller.
.PP
This software is licensed under the 2\-clause BSD license.  See the
LICENSE file in the distribution for details.
