.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::Loader::Base 3pm"
.TH DBIx::Class::Schema::Loader::Base 3pm 2024-01-06 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Schema::Loader::Base \- Base DBIx::Class::Schema::Loader Implementation.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
See DBIx::Class::Schema::Loader.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is the base class for the storage-specific \f(CW\*(C`DBIx::Class::Schema::*\*(C'\fR
classes, and implements the common functionality between them.
.SH "CONSTRUCTOR OPTIONS"
.IX Header "CONSTRUCTOR OPTIONS"
These constructor options are the base options for
"loader_options" in DBIx::Class::Schema::Loader.  Available constructor options are:
.SS skip_relationships
.IX Subsection "skip_relationships"
Skip setting up relationships.  The default is to attempt the loading
of relationships.
.SS skip_load_external
.IX Subsection "skip_load_external"
Skip loading of other classes in \f(CW@INC\fR. The default is to merge all other classes
with the same name found in \f(CW@INC\fR into the schema file we are creating.
.SS naming
.IX Subsection "naming"
Static schemas (ones dumped to disk) will, by default, use the new-style
relationship names and singularized Results, unless you're overwriting an
existing dump made by an older version of DBIx::Class::Schema::Loader, in
which case the backward compatible RelBuilder will be activated, and the
appropriate monikerization used.
.PP
Specifying
.PP
.Vb 1
\&    naming => \*(Aqcurrent\*(Aq
.Ve
.PP
will disable the backward-compatible RelBuilder and use
the new-style relationship names along with singularized Results, even when
overwriting a dump made with an earlier version.
.PP
The option also takes a hashref:
.PP
.Vb 6
\&    naming => {
\&        relationships    => \*(Aqv8\*(Aq,
\&        monikers         => \*(Aqv8\*(Aq,
\&        column_accessors => \*(Aqv8\*(Aq,
\&        force_ascii      => 1,
\&    }
.Ve
.PP
or
.PP
.Vb 1
\&    naming => { ALL => \*(Aqv8\*(Aq, force_ascii => 1 }
.Ve
.PP
The keys are:
.IP ALL 4
.IX Item "ALL"
Set "relationships", "monikers" and "column_accessors" to the specified
value.
.IP relationships 4
.IX Item "relationships"
How to name relationship accessors.
.IP monikers 4
.IX Item "monikers"
How to name Result classes.
.IP column_accessors 4
.IX Item "column_accessors"
How to name column accessors in Result classes.
.IP force_ascii 4
.IX Item "force_ascii"
For "v8" mode and later, uses String::ToIdentifier::EN instead of
String::ToIdentifier::EN::Unicode to force monikers and other identifiers to
ASCII.
.PP
The values can be:
.IP current 4
.IX Item "current"
Latest style, whatever that happens to be.
.IP v4 4
.IX Item "v4"
Unsingularlized monikers, \f(CW\*(C`has_many\*(C'\fR only relationships with no _id stripping.
.IP v5 4
.IX Item "v5"
Monikers singularized as whole words, \f(CW\*(C`might_have\*(C'\fR relationships for FKs on
\&\f(CW\*(C`UNIQUE\*(C'\fR constraints, \f(CW\*(C`_id\*(C'\fR stripping for belongs_to relationships.
.Sp
Some of the \f(CW\*(C`_id\*(C'\fR stripping edge cases in \f(CW0.05003\fR have been reverted for
the v5 RelBuilder.
.IP v6 4
.IX Item "v6"
All monikers and relationships are inflected using
Lingua::EN::Inflect::Phrase, and there is more aggressive \f(CW\*(C`_id\*(C'\fR stripping
from relationship names.
.Sp
In general, there is very little difference between v5 and v6 schemas.
.IP v7 4
.IX Item "v7"
This mode is identical to \f(CW\*(C`v6\*(C'\fR mode, except that monikerization of CamelCase
table names is also done better (but best in v8.)
.Sp
CamelCase column names in case-preserving mode will also be handled better
for relationship name inflection (but best in v8.) See "preserve_case".
.Sp
In this mode, CamelCase "column_accessors" are normalized based on case
transition instead of just being lowercased, so \f(CW\*(C`FooId\*(C'\fR becomes \f(CW\*(C`foo_id\*(C'\fR.
.IP v8 4
.IX Item "v8"
(EXPERIMENTAL)
.Sp
The default mode is "v7", to get "v8" mode, you have to specify it in
"naming" explicitly until \f(CW0.08\fR comes out.
.Sp
"monikers" and "column_accessors" are created using
String::ToIdentifier::EN::Unicode or String::ToIdentifier::EN if
"force_ascii" is set; this is only significant for names with non\-\f(CW\*(C`\ew\*(C'\fR
characters such as \f(CW\*(C`.\*(C'\fR.
.Sp
CamelCase identifiers with words in all caps, e.g. \f(CW\*(C`VLANValidID\*(C'\fR are supported
correctly in this mode.
.Sp
For relationships, belongs_to accessors are made from column names by stripping
postfixes other than \f(CW\*(C`_id\*(C'\fR as well, for example just \f(CW\*(C`Id\*(C'\fR, \f(CW\*(C`_?ref\*(C'\fR, \f(CW\*(C`_?cd\*(C'\fR,
\&\f(CW\*(C`_?code\*(C'\fR and \f(CW\*(C`_?num\*(C'\fR, case insensitively.
.IP preserve 4
.IX Item "preserve"
For "monikers", this option does not inflect the table names but makes
monikers based on the actual name. For "column_accessors" this option does
not normalize CamelCase column names to lowercase column accessors, but makes
accessors that are the same names as the columns (with any non\-\ew chars
replaced with underscores.)
.IP singular 4
.IX Item "singular"
For "monikers", singularizes the names using the most current inflector. This
is the same as setting the option to "current".
.IP plural 4
.IX Item "plural"
For "monikers", pluralizes the names, using the most current inflector.
.PP
Dynamic schemas will always default to the 0.04XXX relationship names and won't
singularize Results for backward compatibility, to activate the new RelBuilder
and singularization put this in your \f(CW\*(C`Schema.pm\*(C'\fR file:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqcurrent\*(Aq);
.Ve
.PP
Or if you prefer to use 0.07XXX features but insure that nothing breaks in the
next major version upgrade:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqv7\*(Aq);
.Ve
.SS quiet
.IX Subsection "quiet"
If true, will not print the usual \f(CW\*(C`Dumping manual schema ... Schema dump
completed.\*(C'\fR messages. Does not affect warnings (except for warnings related to
"really_erase_my_files".)
.SS dry_run
.IX Subsection "dry_run"
If true, don't actually write out the generated files.  This can only be
used with static schema generation.
.SS generate_pod
.IX Subsection "generate_pod"
By default POD will be generated for columns and relationships, using database
metadata for the text if available and supported.
.PP
Comment metadata can be stored in two ways.
.PP
The first is that you can create two tables named \f(CW\*(C`table_comments\*(C'\fR and
\&\f(CW\*(C`column_comments\*(C'\fR respectively. These tables must exist in the same database
and schema as the tables they describe. They both need to have columns named
\&\f(CW\*(C`table_name\*(C'\fR and \f(CW\*(C`comment_text\*(C'\fR. The second one needs to have a column named
\&\f(CW\*(C`column_name\*(C'\fR. Then data stored in these tables will be used as a source of
metadata about tables and comments.
.PP
(If you wish you can change the name of these tables with the parameters
"table_comments_table" and "column_comments_table".)
.PP
As a fallback you can use built-in commenting mechanisms.  Currently this is
only supported for PostgreSQL, Oracle and MySQL.  To create comments in
PostgreSQL you add statements of the form \f(CWCOMMENT ON TABLE some_table IS
\&\*(Aq...\*(Aq\fR, the same syntax is used in Oracle. To create comments in MySQL you add
\&\f(CW\*(C`COMMENT \*(Aq...\*(Aq\*(C'\fR to the end of the column or table definition.  Note that MySQL
restricts the length of comments, and also does not handle complex Unicode
characters properly.
.PP
Set this to \f(CW0\fR to turn off all POD generation.
.SS pod_comment_mode
.IX Subsection "pod_comment_mode"
Controls where table comments appear in the generated POD. Smaller table
comments are appended to the \f(CW\*(C`NAME\*(C'\fR section of the documentation, and larger
ones are inserted into \f(CW\*(C`DESCRIPTION\*(C'\fR instead. You can force a \f(CW\*(C`DESCRIPTION\*(C'\fR
section to be generated with the comment always, only use \f(CW\*(C`NAME\*(C'\fR, or choose
the length threshold at which the comment is forced into the description.
.IP name 4
.IX Item "name"
Use \f(CW\*(C`NAME\*(C'\fR section only.
.IP description 4
.IX Item "description"
Force \f(CW\*(C`DESCRIPTION\*(C'\fR always.
.IP auto 4
.IX Item "auto"
Use \f(CW\*(C`DESCRIPTION\*(C'\fR if length > "pod_comment_spillover_length", this is the
default.
.SS pod_comment_spillover_length
.IX Subsection "pod_comment_spillover_length"
When pod_comment_mode is set to \f(CW\*(C`auto\*(C'\fR, this is the length of the comment at
which it will be forced into a separate description section.
.PP
The default is \f(CW60\fR
.SS table_comments_table
.IX Subsection "table_comments_table"
The table to look for comments about tables in.  By default \f(CW\*(C`table_comments\*(C'\fR.
See "generate_pod" for details.
.PP
This must not be a fully qualified name, the table will be looked for in the
same database and schema as the table whose comment is being retrieved.
.SS column_comments_table
.IX Subsection "column_comments_table"
The table to look for comments about columns in.  By default \f(CW\*(C`column_comments\*(C'\fR.
See "generate_pod" for details.
.PP
This must not be a fully qualified name, the table will be looked for in the
same database and schema as the table/column whose comment is being retrieved.
.SS relationship_attrs
.IX Subsection "relationship_attrs"
Hashref of attributes to pass to each generated relationship, listed by type.
Also supports relationship type 'all', containing options to pass to all
generated relationships.  Attributes set for more specific relationship types
override those set in 'all', and any attributes specified by this option
override the introspected attributes of the foreign key if any.
.PP
For example:
.PP
.Vb 4
\&    relationship_attrs => {
\&        has_many   => { cascade_delete => 1, cascade_copy => 1 },
\&        might_have => { cascade_delete => 1, cascade_copy => 1 },
\&    },
.Ve
.PP
use this to turn DBIx::Class cascades to on on your
has_many and
might_have relationships, they default
to off.
.PP
Can also be a coderef, for more precise control, in which case the coderef gets
this hash of parameters (as a list):
.PP
.Vb 9
\&    rel_name        # the name of the relationship
\&    rel_type        # the type of the relationship: \*(Aqbelongs_to\*(Aq, \*(Aqhas_many\*(Aq or \*(Aqmight_have\*(Aq
\&    local_source    # the DBIx::Class::ResultSource object for the source the rel is *from*
\&    remote_source   # the DBIx::Class::ResultSource object for the source the rel is *to*
\&    local_table     # the DBIx::Class::Schema::Loader::Table object for the table of the source the rel is from
\&    local_cols      # an arrayref of column names of columns used in the rel in the source it is from
\&    remote_table    # the DBIx::Class::Schema::Loader::Table object for the table of the source the rel is to
\&    remote_cols     # an arrayref of column names of columns used in the rel in the source it is to
\&    attrs           # the attributes that would be set
.Ve
.PP
it should return the new hashref of attributes, or nothing for no changes.
.PP
For example:
.PP
.Vb 2
\&    relationship_attrs => sub {
\&        my %p = @_;
\&
\&        say "the relationship name is: $p{rel_name}";
\&        say "the relationship is a: $p{rel_type}";
\&        say "the local class is: ",  $p{local_source}\->result_class;
\&        say "the remote class is: ", $p{remote_source}\->result_class;
\&        say "the local table is: ", $p{local_table}\->sql_name;
\&        say "the rel columns in the local table are: ", (join ", ", @{$p{local_cols}});
\&        say "the remote table is: ", $p{remote_table}\->sql_name;
\&        say "the rel columns in the remote table are: ", (join ", ", @{$p{remote_cols}});
\&
\&        if ($p{local_table} eq \*(Aqdogs\*(Aq && @{$p{local_cols}} == 1 && $p{local_cols}[0] eq \*(Aqname\*(Aq) {
\&            $p{attrs}{could_be_snoopy} = 1;
\&
\&            reutrn $p{attrs};
\&        }
\&    },
.Ve
.PP
These are the default attributes:
.PP
.Vb 10
\&    has_many => {
\&        cascade_delete => 0,
\&        cascade_copy   => 0,
\&    },
\&    might_have => {
\&        cascade_delete => 0,
\&        cascade_copy   => 0,
\&    },
\&    belongs_to => {
\&        on_delete => \*(AqCASCADE\*(Aq,
\&        on_update => \*(AqCASCADE\*(Aq,
\&        is_deferrable => 1,
\&    },
.Ve
.PP
For belongs_to relationships, these
defaults are overridden by the attributes introspected from the foreign key in
the database, if this information is available (and the driver is capable of
retrieving it.)
.PP
This information overrides the defaults mentioned above, and is then itself
overridden by the user's "relationship_attrs" for \f(CW\*(C`belongs_to\*(C'\fR if any are
specified.
.PP
In general, for most databases, for a plain foreign key with no rules, the
values for a belongs_to relationship
will be:
.PP
.Vb 3
\&    on_delete     => \*(AqNO ACTION\*(Aq,
\&    on_update     => \*(AqNO ACTION\*(Aq,
\&    is_deferrable => 0,
.Ve
.PP
In the cases where an attribute is not supported by the DB, a value matching
the actual behavior is used, for example Oracle does not support \f(CW\*(C`ON UPDATE\*(C'\fR
rules, so \f(CW\*(C`on_update\*(C'\fR is set to \f(CW\*(C`NO ACTION\*(C'\fR. This is done so that the
behavior of the schema is preserved when cross deploying to a different RDBMS
such as SQLite for testing.
.PP
In the cases where the DB does not support \f(CW\*(C`DEFERRABLE\*(C'\fR foreign keys, the
value is set to \f(CW1\fR if DBIx::Class has a working \f(CW\*(C`$storage\->with_deferred_fk_checks\*(C'\fR. This is done so that the same
DBIx::Class code can be used, and cross deployed from and to such databases.
.SS debug
.IX Subsection "debug"
If set to true, each constructive DBIx::Class statement the loader
decides to execute will be \f(CW\*(C`warn\*(C'\fR\-ed before execution.
.SS db_schema
.IX Subsection "db_schema"
Set the name of the schema to load (schema in the sense that your database
vendor means it).
.PP
Can be set to an arrayref of schema names for multiple schemas, or the special
value \f(CW\*(C`%\*(C'\fR for all schemas.
.PP
For MSSQL, Sybase ASE, and Informix can be set to a hashref of databases as
keys and arrays of owners as values, set to the value:
.PP
.Vb 1
\&    { \*(Aq%\*(Aq => \*(Aq%\*(Aq }
.Ve
.PP
for all owners in all databases.
.PP
Name clashes resulting from the same table name in different databases/schemas
will be resolved automatically by prefixing the moniker with the database
and/or schema.
.PP
To prefix/suffix all monikers with the database and/or schema, see
"moniker_parts".
.SS moniker_parts
.IX Subsection "moniker_parts"
The database table names are represented by the
DBIx::Class::Schema::Loader::Table class in the loader, the
DBIx::Class::Schema::Loader::Table::Sybase class for Sybase ASE and
DBIx::Class::Schema::Loader::Table::Informix for Informix.
.PP
Monikers are created normally based on just the
name property, corresponding to
the table name, but can consist of other parts of the fully qualified name of
the table.
.PP
The "moniker_parts" option is an arrayref of methods on the table class
corresponding to parts of the fully qualified table name, defaulting to
\&\f(CW\*(C`[\*(Aqname\*(Aq]\*(C'\fR, in the order those parts are used to create the moniker name.
The parts are joined together using "moniker_part_separator".
.PP
The \f(CW\*(Aqname\*(Aq\fR entry \fBmust\fR be present.
.PP
Below is a table of supported databases and possible "moniker_parts".
.IP \(bu 4
DB2, Firebird, mysql, Oracle, Pg, SQLAnywhere, SQLite, MS Access
.Sp
\&\f(CW\*(C`schema\*(C'\fR, \f(CW\*(C`name\*(C'\fR
.IP \(bu 4
Informix, MSSQL, Sybase ASE
.Sp
\&\f(CW\*(C`database\*(C'\fR, \f(CW\*(C`schema\*(C'\fR, \f(CW\*(C`name\*(C'\fR
.SS moniker_part_separator
.IX Subsection "moniker_part_separator"
String used to join "moniker_parts" when creating the moniker.
Defaults to the empty string. Use \f(CW\*(C`::\*(C'\fR to get a separate namespace per
database and/or schema.
.SS constraint
.IX Subsection "constraint"
Only load matching tables.
.PP
These can be specified either as a regex (preferably on the \f(CW\*(C`qr//\*(C'\fR
form), or as an arrayref of arrayrefs.  Regexes are matched against
the (unqualified) table name, while arrayrefs are matched according to
"moniker_parts".
.PP
For example:
.PP
.Vb 6
\&    db_schema => [qw(some_schema other_schema)],
\&    moniker_parts => [qw(schema name)],
\&    constraint => [
\&        [ qr/\eAsome_schema\ez/ => qr/\eA(?:foo|bar)\ez/ ],
\&        [ qr/\eAother_schema\ez/ => qr/\eAbaz\ez/ ],
\&    ],
.Ve
.PP
In this case only the tables \f(CW\*(C`foo\*(C'\fR and \f(CW\*(C`bar\*(C'\fR in \f(CW\*(C`some_schema\*(C'\fR and
\&\f(CW\*(C`baz\*(C'\fR in \f(CW\*(C`other_schema\*(C'\fR will be dumped.
.SS exclude
.IX Subsection "exclude"
Exclude matching tables.
.PP
The tables to exclude are specified in the same way as for the
"constraint" option.
.SS moniker_map
.IX Subsection "moniker_map"
Overrides the default table name to moniker translation. Either
.IP \(bu 4
a nested hashref, which will be traversed according to "moniker_parts"
.Sp
For example:
.Sp
.Vb 6
\&    moniker_parts => [qw(schema name)],
\&    moniker_map => {
\&        foo => {
\&            bar  => "FooishBar",
\&        },
\&    },
.Ve
.Sp
In which case the table \f(CW\*(C`bar\*(C'\fR in the \f(CW\*(C`foo\*(C'\fR schema would get the moniker
\&\f(CW\*(C`FooishBar\*(C'\fR.
.IP \(bu 4
a hashref of unqualified table name keys and moniker values
.IP \(bu 4
a coderef that returns the moniker, which is called with the following
arguments:
.RS 4
.IP \(bu 4
the DBIx::Class::Schema::Loader::Table object for the table
.IP \(bu 4
the default moniker that DBIC would ordinarily give this table
.IP \(bu 4
a coderef that can be called with either of the hashref forms to get
the moniker mapped accordingly.  This is useful if you need to handle
some monikers specially, but want to use the hashref form for the
rest.
.RE
.RS 4
.RE
.PP
If the hash entry does not exist, or the function returns a false
value, the code falls back to default behavior for that table name.
.PP
The default behavior is to split on case transition and non-alphanumeric
boundaries, singularize the resulting phrase, then join the titlecased words
together. Examples:
.PP
.Vb 7
\&    Table Name       | Moniker Name
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    luser            | Luser
\&    luser_group      | LuserGroup
\&    luser\-opts       | LuserOpt
\&    stations_visited | StationVisited
\&    routeChange      | RouteChange
.Ve
.SS moniker_part_map
.IX Subsection "moniker_part_map"
Map for overriding the monikerization of individual "moniker_parts".
The keys are the moniker part to override, the value is either a
hashref or coderef for mapping the corresponding part of the
moniker. If a coderef is used, it gets called with the moniker part
and the hash key the code ref was found under.
.PP
For example:
.PP
.Vb 3
\&    moniker_part_map => {
\&        schema => sub { ... },
\&    },
.Ve
.PP
Given the table \f(CW\*(C`foo.bar\*(C'\fR, the code ref would be called with the
arguments \f(CW\*(C`foo\*(C'\fR and \f(CW\*(C`schema\*(C'\fR, plus a coderef similar to the one
described in "moniker_map".
.PP
"moniker_map" takes precedence over this.
.SS col_accessor_map
.IX Subsection "col_accessor_map"
Same as moniker_map, but for column accessor names.  The nested
hashref form is traversed according to "moniker_parts", with an
extra level at the bottom for the column name.  If a coderef is
passed, the code is called with the following arguments:
.IP \(bu 4
the DBIx::Class::Schema::Loader::Column object for the column
.IP \(bu 4
the default accessor name that DBICSL would ordinarily give this column
.IP \(bu 4
a hashref of this form:
.Sp
.Vb 8
\&    {
\&        table_class     => name of the DBIC class we are building,
\&        table_moniker   => calculated moniker for this table (after moniker_map if present),
\&        table           => the DBIx::Class::Schema::Loader::Table object for the table,
\&        full_table_name => schema\-qualified name of the database table (RDBMS specific),
\&        schema_class    => name of the schema class we are building,
\&        column_info     => hashref of column info (data_type, is_nullable, etc),
\&    }
.Ve
.IP \(bu 4
a coderef that can be called with a hashref map
.SS rel_name_map
.IX Subsection "rel_name_map"
Similar in idea to moniker_map, but different in the details.  It can be
a hashref or a code ref.
.PP
If it is a hashref, keys can be either the default relationship name, or the
moniker. The keys that are the default relationship name should map to the
name you want to change the relationship to. Keys that are monikers should map
to hashes mapping relationship names to their translation.  You can do both at
once, and the more specific moniker version will be picked up first.  So, for
instance, you could have
.PP
.Vb 6
\&    {
\&        bar => "baz",
\&        Foo => {
\&            bar => "blat",
\&        },
\&    }
.Ve
.PP
and relationships that would have been named \f(CW\*(C`bar\*(C'\fR will now be named \f(CW\*(C`baz\*(C'\fR
except that in the table whose moniker is \f(CW\*(C`Foo\*(C'\fR it will be named \f(CW\*(C`blat\*(C'\fR.
.PP
If it is a coderef, it will be passed a hashref of this form:
.PP
.Vb 10
\&    {
\&        name           => default relationship name,
\&        type           => the relationship type eg: C<has_many>,
\&        local_class    => name of the DBIC class we are building,
\&        local_moniker  => moniker of the DBIC class we are building,
\&        local_columns  => columns in this table in the relationship,
\&        remote_class   => name of the DBIC class we are related to,
\&        remote_moniker => moniker of the DBIC class we are related to,
\&        remote_columns => columns in the other table in the relationship,
\&        # for type => "many_to_many" only:
\&        link_class     => name of the DBIC class for the link table,
\&        link_moniker   => moniker of the DBIC class for the link table,
\&        link_rel_name  => name of the relationship to the link table,
\&    }
.Ve
.PP
In addition it is passed a coderef that can be called with a hashref map.
.PP
DBICSL will try to use the value returned as the relationship name.
.SS inflect_plural
.IX Subsection "inflect_plural"
Just like "moniker_map" above (can be hash/code\-ref, falls back to default
if hash key does not exist or coderef returns false), but acts as a map
for pluralizing relationship names.  The default behavior is to utilize
"to_PL" in Lingua::EN::Inflect::Phrase.
.SS inflect_singular
.IX Subsection "inflect_singular"
As "inflect_plural" above, but for singularizing relationship names.
Default behavior is to utilize "to_S" in Lingua::EN::Inflect::Phrase.
.SS schema_base_class
.IX Subsection "schema_base_class"
Base class for your schema classes. Defaults to 'DBIx::Class::Schema'.
.SS schema_components
.IX Subsection "schema_components"
List of components to load into the Schema class.
.SS result_base_class
.IX Subsection "result_base_class"
Base class for your table classes (aka result classes). Defaults to
\&'DBIx::Class::Core'.
.SS additional_base_classes
.IX Subsection "additional_base_classes"
List of additional base classes all of your table classes will use.
.SS left_base_classes
.IX Subsection "left_base_classes"
List of additional base classes all of your table classes will use
that need to be leftmost.
.SS additional_classes
.IX Subsection "additional_classes"
List of additional classes which all of your table classes will use.
.SS components
.IX Subsection "components"
List of additional components to be loaded into all of your Result
classes.  A good example would be
InflateColumn::DateTime
.SS result_components_map
.IX Subsection "result_components_map"
A hashref of moniker keys and component values.  Unlike "components", which
loads the given components into every Result class, this option allows you to
load certain components for specified Result classes. For example:
.PP
.Vb 7
\&    result_components_map => {
\&        StationVisited => \*(Aq+YourApp::Schema::Component::StationVisited\*(Aq,
\&        RouteChange    => [
\&                              \*(Aq+YourApp::Schema::Component::RouteChange\*(Aq,
\&                              \*(AqInflateColumn::DateTime\*(Aq,
\&                          ],
\&    }
.Ve
.PP
You may use this in conjunction with "components".
.SS result_roles
.IX Subsection "result_roles"
List of Moose roles to be applied to all of your Result classes.
.SS result_roles_map
.IX Subsection "result_roles_map"
A hashref of moniker keys and role values.  Unlike "result_roles", which
applies the given roles to every Result class, this option allows you to apply
certain roles for specified Result classes. For example:
.PP
.Vb 7
\&    result_roles_map => {
\&        StationVisited => [
\&                              \*(AqYourApp::Role::Building\*(Aq,
\&                              \*(AqYourApp::Role::Destination\*(Aq,
\&                          ],
\&        RouteChange    => \*(AqYourApp::Role::TripEvent\*(Aq,
\&    }
.Ve
.PP
You may use this in conjunction with "result_roles".
.SS use_namespaces
.IX Subsection "use_namespaces"
This is now the default, to go back to "load_classes" in DBIx::Class::Schema pass
a \f(CW0\fR.
.PP
Generate result class names suitable for
"load_namespaces" in DBIx::Class::Schema and call that instead of
"load_classes" in DBIx::Class::Schema. When using this option you can also
specify any of the options for \f(CW\*(C`load_namespaces\*(C'\fR (i.e. \f(CW\*(C`result_namespace\*(C'\fR,
\&\f(CW\*(C`resultset_namespace\*(C'\fR, \f(CW\*(C`default_resultset_class\*(C'\fR), and they will be added
to the call (and the generated result class names adjusted appropriately).
.SS dump_directory
.IX Subsection "dump_directory"
The value of this option is a perl libdir pathname.  Within
that directory this module will create a baseline manual
DBIx::Class::Schema module set, based on what it creates at runtime.
.PP
The created schema class will have the same classname as the one on
which you are setting this option (and the ResultSource classes will be
based on this name as well).
.PP
Normally you wouldn't hard-code this setting in your schema class, as it
is meant for one-time manual usage.
.PP
See "dump_to_dir" in DBIx::Class::Schema::Loader for examples of the
recommended way to access this functionality.
.SS dump_overwrite
.IX Subsection "dump_overwrite"
Deprecated.  See "really_erase_my_files" below, which does *not* mean
the same thing as the old \f(CW\*(C`dump_overwrite\*(C'\fR setting from previous releases.
.SS really_erase_my_files
.IX Subsection "really_erase_my_files"
Default false.  If true, Loader will unconditionally delete any existing
files before creating the new ones from scratch when dumping a schema to disk.
.PP
The default behavior is instead to only replace the top portion of the
file, up to and including the final stanza which contains
\&\f(CW\*(C`# DO NOT MODIFY THE FIRST PART OF THIS FILE\*(C'\fR
leaving any customizations you placed after that as they were.
.PP
When \f(CW\*(C`really_erase_my_files\*(C'\fR is not set, if the output file already exists,
but the aforementioned final stanza is not found, or the checksum
contained there does not match the generated contents, Loader will
croak and not touch the file.
.PP
You should really be using version control on your schema classes (and all
of the rest of your code for that matter).  Don't blame me if a bug in this
code wipes something out when it shouldn't have, you've been warned.
.SS overwrite_modifications
.IX Subsection "overwrite_modifications"
Default false.  If false, when updating existing files, Loader will
refuse to modify any Loader-generated code that has been modified
since its last run (as determined by the checksum Loader put in its
comment lines).
.PP
If true, Loader will discard any manual modifications that have been
made to Loader-generated code.
.PP
Again, you should be using version control on your schema classes.  Be
careful with this option.
.SS omit_version
.IX Subsection "omit_version"
Omit the package version from the signature comment.
.SS omit_timestamp
.IX Subsection "omit_timestamp"
Omit the creation timestamp from the signature comment.
.SS custom_column_info
.IX Subsection "custom_column_info"
Hook for adding extra attributes to the
column_info for a column.
.PP
Must be a coderef that returns a hashref with the extra attributes.
.PP
Receives the DBIx::Class::Schema::Loader::Table object, column name
and column_info.
.PP
For example:
.PP
.Vb 2
\&    custom_column_info => sub {
\&        my ($table, $column_name, $column_info) = @_;
\&
\&        if ($column_name eq \*(Aqdog\*(Aq && $column_info\->{default_value} eq \*(Aqsnoopy\*(Aq) {
\&            return { is_snoopy => 1 };
\&        }
\&    },
.Ve
.PP
This attribute can also be used to set \f(CW\*(C`inflate_datetime\*(C'\fR on a non-datetime
column so it also receives the "datetime_timezone" and/or "datetime_locale".
.SS datetime_timezone
.IX Subsection "datetime_timezone"
Sets the timezone attribute for DBIx::Class::InflateColumn::DateTime for all
columns with the DATE/DATETIME/TIMESTAMP data_types.
.SS datetime_locale
.IX Subsection "datetime_locale"
Sets the locale attribute for DBIx::Class::InflateColumn::DateTime for all
columns with the DATE/DATETIME/TIMESTAMP data_types.
.SS datetime_undef_if_invalid
.IX Subsection "datetime_undef_if_invalid"
Pass a \f(CW0\fR for this option when using MySQL if you \fBDON'T\fR want \f(CW\*(C`datetime_undef_if_invalid => 1\*(C'\fR in your column info for DATE, DATETIME and
TIMESTAMP columns.
.PP
The default is recommended to deal with data such as \f(CW\*(C`00/00/00\*(C'\fR which
sometimes ends up in such columns in MySQL.
.SS config_file
.IX Subsection "config_file"
File in Perl format, which should return a HASH reference, from which to read
loader options.
.SS preserve_case
.IX Subsection "preserve_case"
Normally database names are lowercased and split by underscore, use this option
if you have CamelCase database names.
.PP
Drivers for case sensitive databases like Sybase ASE or MSSQL with a
case-sensitive collation will turn this option on unconditionally.
.PP
\&\fBNOTE:\fR "naming" = \f(CW\*(C`v8\*(C'\fR is highly recommended with this option as the
semantics of this mode are much improved for CamelCase database names.
.PP
"naming" = \f(CW\*(C`v7\*(C'\fR or greater is required with this option.
.SS qualify_objects
.IX Subsection "qualify_objects"
Set to true to prepend the "db_schema" to table names for \f(CW\*(C`_\|_PACKAGE_\|_\->table\*(C'\fR calls, and to some other things like Oracle sequences.
.PP
This attribute is automatically set to true for multi db_schema configurations,
unless explicitly set to false by the user.
.SS use_moose
.IX Subsection "use_moose"
Creates Schema and Result classes that use Moose, MooseX::NonMoose and
MooseX::MarkAsMethods (or namespace::autoclean, see below). The default
content after the md5 sum also makes the classes immutable.
.PP
It is safe to upgrade your existing Schema to this option.
.SS only_autoclean
.IX Subsection "only_autoclean"
By default, we use MooseX::MarkAsMethods to remove imported functions from
your generated classes.  It uses namespace::autoclean to do this, after
telling your object's metaclass that any operator overloads in your class
are methods, which will cause namespace::autoclean to spare them from removal.
.PP
This prevents the "Hey, where'd my overloads go?!" effect.
.PP
If you don't care about operator overloads (or if you know your Moose is at at
least version 2.1400, where MooseX::MarkAsMethods is no longer necessary),
enabling this option falls back to just using namespace::autoclean itself.
.PP
If none of the above made any sense, or you don't have some pressing need to
only use namespace::autoclean, leaving this set to the default is
just fine.
.SS col_collision_map
.IX Subsection "col_collision_map"
This option controls how accessors for column names which collide with perl
methods are named. See "COLUMN ACCESSOR COLLISIONS" for more information.
.PP
This option takes either a single sprintf format or a hashref of
strings which are compiled to regular expressions that map to
sprintf formats.
.PP
Examples:
.PP
.Vb 1
\&    col_collision_map => \*(Aqcolumn_%s\*(Aq
\&
\&    col_collision_map => { \*(Aq(.*)\*(Aq => \*(Aqcolumn_%s\*(Aq }
\&
\&    col_collision_map => { \*(Aq(foo).*(bar)\*(Aq => \*(Aqcolumn_%s_%s\*(Aq }
.Ve
.SS rel_collision_map
.IX Subsection "rel_collision_map"
Works just like "col_collision_map", but for relationship names/accessors
rather than column names/accessors.
.PP
The default is to just append \f(CW\*(C`_rel\*(C'\fR to the relationship name, see
"RELATIONSHIP NAME COLLISIONS".
.SS uniq_to_primary
.IX Subsection "uniq_to_primary"
Automatically promotes the largest unique constraints with non-nullable columns
on tables to primary keys, assuming there is only one largest unique
constraint.
.SS allow_extra_m2m_cols
.IX Subsection "allow_extra_m2m_cols"
Generate \f(CW\*(C`many_to_many\*(C'\fR relationship bridges even if the link table has
extra columns other than the foreign keys.  The primary key must still
equal the union of the foreign keys.
.SS filter_generated_code
.IX Subsection "filter_generated_code"
An optional hook that lets you filter the generated text for various classes
through a function that change it in any way that you want.  The function will
receive the type of file, \f(CW\*(C`schema\*(C'\fR or \f(CW\*(C`result\*(C'\fR, class and code; and returns
the new code to use instead.  For instance you could add custom comments, or do
anything else that you want.
.PP
The option can also be set to a string, which is then used as a filter program,
e.g. \f(CW\*(C`perltidy\*(C'\fR.
.PP
If this exists but fails to return text matching \f(CW\*(C`/\ebpackage\eb/\*(C'\fR, no file will
be generated.
.PP
.Vb 5
\&    filter_generated_code => sub {
\&        my ($type, $class, $text) = @_;
\&        ...
\&        return $new_code;
\&    }
.Ve
.PP
You can also use this option to set perltidy markers in your generated classes.  This will leave
the generated code in the default format, but will allow you to tidy
your classes at any point in future, without worrying about changing the
portions of the file which are checksummed, since \f(CW\*(C`perltidy\*(C'\fR will just
ignore all text between the markers.
.PP
.Vb 3
\&    filter_generated_code => sub {
\&        return "#<<<\en$_[2]\en#>>>";
\&    }
.Ve
.SH METHODS
.IX Header "METHODS"
None of these methods are intended for direct invocation by regular
users of DBIx::Class::Schema::Loader. Some are proxied via
DBIx::Class::Schema::Loader.
.SS new
.IX Subsection "new"
Constructor for DBIx::Class::Schema::Loader::Base, used internally
by DBIx::Class::Schema::Loader.
.SS load
.IX Subsection "load"
Does the actual schema-construction work.
.SS rescan
.IX Subsection "rescan"
Arguments: schema
.PP
Rescan the database for changes. Returns a list of the newly added table
monikers.
.PP
The schema argument should be the schema class or object to be affected.  It
should probably be derived from the original schema_class used during "load".
.SS get_dump_filename
.IX Subsection "get_dump_filename"
Arguments: class
.PP
Returns the full path to the file for a class that the class has been or will
be dumped to. This is a file in a temp dir for a dynamic schema.
.SS tables
.IX Subsection "tables"
Returns a sorted list of loaded tables, using the original database table
names.
.SS monikers
.IX Subsection "monikers"
Returns a hashref of loaded table to moniker mappings.  There will
be two entries for each table, the original name and the "normalized"
name, in the case that the two are different (such as databases
that like uppercase table names, or preserve your original mixed-case
definitions, or what-have-you).
.SS classes
.IX Subsection "classes"
Returns a hashref of table to class mappings.  In some cases it will
contain multiple entries per table for the original and normalized table
names, as above in "monikers".
.SS generated_classes
.IX Subsection "generated_classes"
Returns an arrayref of classes that were actually generated (i.e. not
skipped because there were no changes).
.SH "NON-ENGLISH DATABASES"
.IX Header "NON-ENGLISH DATABASES"
If you use the loader on a database with table and column names in a language
other than English, you will want to turn off the English language specific
heuristics.
.PP
To do so, use something like this in your loader options:
.PP
.Vb 3
\&    naming           => { monikers => \*(Aqv4\*(Aq },
\&    inflect_singular => sub { "$_[0]_rel" },
\&    inflect_plural   => sub { "$_[0]_rel" },
.Ve
.SH "COLUMN ACCESSOR COLLISIONS"
.IX Header "COLUMN ACCESSOR COLLISIONS"
Occasionally you may have a column name that collides with a perl method, such
as \f(CW\*(C`can\*(C'\fR. In such cases, the default action is to set the \f(CW\*(C`accessor\*(C'\fR of the
column spec to \f(CW\*(C`undef\*(C'\fR.
.PP
You can then name the accessor yourself by placing code such as the following
below the md5:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->add_column(\*(Aq+can\*(Aq => { accessor => \*(Aqmy_can\*(Aq });
.Ve
.PP
Another option is to use the "col_collision_map" option.
.SH "RELATIONSHIP NAME COLLISIONS"
.IX Header "RELATIONSHIP NAME COLLISIONS"
In very rare cases, you may get a collision between a generated relationship
name and a method in your Result class, for example if you have a foreign key
called \f(CW\*(C`belongs_to\*(C'\fR.
.PP
This is a problem because relationship names are also relationship accessor
methods in DBIx::Class.
.PP
The default behavior is to append \f(CW\*(C`_rel\*(C'\fR to the relationship name and print
out a warning that refers to this text.
.PP
You can also control the renaming with the "rel_collision_map" option.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Class::Schema::Loader, dbicdump
.SH AUTHORS
.IX Header "AUTHORS"
See "AUTHORS" in DBIx::Class::Schema::Loader.
.SH LICENSE
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
