.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Any 3pm"
.TH Log::Any 3pm 2023-08-17 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Log::Any \- Bringing loggers and listeners together
.SH VERSION
.IX Header "VERSION"
version 1.717
.SH SYNOPSIS
.IX Header "SYNOPSIS"
In a CPAN or other module:
.PP
.Vb 2
\&    package Foo;
\&    use Log::Any qw($log);
\&
\&    # log a string
\&    $log\->error("an error occurred");
\&
\&    # log a string and some data
\&    $log\->info("program started",
\&        {progname => $0, pid => $$, perl_version => $]});
\&
\&    # log a string and data using a format string
\&    $log\->debugf("arguments are: %s", \e@_);
\&
\&    # log an error and throw an exception
\&    die $log\->fatal("a fatal error occurred");
.Ve
.PP
In a Moo/Moose\-based module:
.PP
.Vb 3
\&    package Foo;
\&    use Log::Any ();
\&    use Moo;
\&
\&    has log => (
\&        is => \*(Aqro\*(Aq,
\&        default => sub { Log::Any\->get_logger },
\&    );
.Ve
.PP
In your application:
.PP
.Vb 2
\&    use Foo;
\&    use Log::Any::Adapter;
\&
\&    # Send all logs to Log::Log4perl
\&    Log::Any::Adapter\->set(\*(AqLog4perl\*(Aq);
\&
\&    # Send all logs to Log::Dispatch
\&    my $log = Log::Dispatch\->new(outputs => [[ ... ]]);
\&    Log::Any::Adapter\->set( \*(AqDispatch\*(Aq, dispatcher => $log );
\&
\&    # See Log::Any::Adapter documentation for more options
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Log::Any\*(C'\fR provides a standard log production API for modules.
Log::Any::Adapter allows applications to choose the mechanism for log
consumption, whether screen, file or another logging mechanism like
Log::Dispatch or Log::Log4perl.
.PP
Many modules have something interesting to say. Unfortunately there is no
standard way for them to say it \- some output to STDERR, others to \f(CW\*(C`warn\*(C'\fR,
others to custom file logs. And there is no standard way to get a module to
start talking \- sometimes you must call a uniquely named method, other times
set a package variable.
.PP
This being Perl, there are many logging mechanisms available on CPAN.  Each has
their pros and cons. Unfortunately, the existence of so many mechanisms makes
it difficult for a CPAN author to commit his/her users to one of them. This may
be why many CPAN modules invent their own logging or choose not to log at all.
.PP
To untangle this situation, we must separate the two parts of a logging API.
The first, \fIlog production\fR, includes methods to output logs (like
\&\f(CW\*(C`$log\->debug\*(C'\fR) and methods to inspect whether a log level is activated
(like \f(CW\*(C`$log\->is_debug\*(C'\fR). This is generally all that CPAN modules care
about. The second, \fIlog consumption\fR, includes a way to configure where
logging goes (a file, the screen, etc.) and the code to send it there. This
choice generally belongs to the application.
.PP
A CPAN module uses \f(CW\*(C`Log::Any\*(C'\fR to get a log producer object.  An application,
in turn, may choose one or more logging mechanisms via Log::Any::Adapter, or
none at all.
.PP
\&\f(CW\*(C`Log::Any\*(C'\fR has a very tiny footprint and no dependencies beyond Perl 5.8.1,
which makes it appropriate for even small CPAN modules to use. It defaults to
\&'null' logging activity, so a module can safely log without worrying about
whether the application has chosen (or will ever choose) a logging mechanism.
.PP
See <http://www.openswartz.com/2007/09/06/standard\-logging\-api/> for the
original post proposing this module.
.SH "LOG LEVELS"
.IX Header "LOG LEVELS"
\&\f(CW\*(C`Log::Any\*(C'\fR supports the following log levels and aliases, which is meant to be
inclusive of the major logging packages:
.PP
.Vb 9
\&     trace
\&     debug
\&     info (inform)
\&     notice
\&     warning (warn)
\&     error (err)
\&     critical (crit, fatal)
\&     alert
\&     emergency
.Ve
.PP
Levels are translated as appropriate to the underlying logging mechanism. For
example, log4perl only has six levels, so we translate 'notice' to 'info' and
the top three levels to 'fatal'.  See the documentation of an adapter class
for specifics.
.SH CATEGORIES
.IX Header "CATEGORIES"
Every logger has a category, generally the name of the class that asked for the
logger. Some logging mechanisms, like log4perl, can direct logs to different
places depending on category.
.SH "PRODUCING LOGS (FOR MODULES)"
.IX Header "PRODUCING LOGS (FOR MODULES)"
.SS "Getting a logger"
.IX Subsection "Getting a logger"
The most convenient way to get a logger in your module is:
.PP
.Vb 1
\&    use Log::Any qw($log);
.Ve
.PP
This creates a package variable \fR\f(CI$log\fR\fI\fR and assigns it to the logger for the
current package. It is equivalent to
.PP
.Vb 1
\&    our $log = Log::Any\->get_logger;
.Ve
.PP
In general, to get a logger for a specified category:
.PP
.Vb 1
\&    my $log = Log::Any\->get_logger(category => $category)
.Ve
.PP
If no category is specified, the calling package is used.
.PP
A logger object is an instance of Log::Any::Proxy, which passes
on messages to the Log::Any::Adapter handling its category.
.PP
If the \f(CW\*(C`proxy_class\*(C'\fR argument is passed, an alternative to
Log::Any::Proxy (such as a subclass) will be instantiated and returned
instead.  The argument is automatically prepended with "Log::Any::Proxy::".
If instead you want to pass the full name of a proxy class, prefix it with
a "+". E.g.
.PP
.Vb 2
\&    # Log::Any::Proxy::Foo
\&    my $log = Log::Any\->get_logger(proxy_class => \*(AqFoo\*(Aq);
\&
\&    # MyLog::Proxy
\&    my $log = Log::Any\->get_logger(proxy_class => \*(Aq+MyLog::Proxy\*(Aq);
.Ve
.SS Logging
.IX Subsection "Logging"
To log a message, pass a single string to any of the log levels or aliases. e.g.
.PP
.Vb 3
\&    $log\->error("this is an error");
\&    $log\->warn("this is a warning");
\&    $log\->warning("this is also a warning");
.Ve
.PP
The log string will be returned so that it can be used further (e.g. for a \f(CW\*(C`die\*(C'\fR or
\&\f(CW\*(C`warn\*(C'\fR call).
.PP
You should \fBnot\fR include a newline in your message; that is the responsibility
of the logging mechanism, which may or may not want the newline.
.PP
If you want to log additional structured data alongside with your string, you
can add a single hashref after your log string. e.g.
.PP
.Vb 2
\&    $log\->info("program started",
\&        {progname => $0, pid => $$, perl_version => $]});
.Ve
.PP
If the configured Log::Any::Adapter does not support logging structured data,
the hash will be converted to a string using Data::Dumper.
.PP
There are also versions of each of the logging methods with an additional "f" suffix
(\f(CW\*(C`infof\*(C'\fR, \f(CW\*(C`errorf\*(C'\fR, \f(CW\*(C`debugf\*(C'\fR, etc.) that format a list of arguments.  The
specific formatting mechanism and meaning of the arguments is controlled by the
Log::Any::Proxy object.
.PP
.Vb 2
\&    $log\->errorf("an error occurred: %s", $@);
\&    $log\->debugf("called with %d params: %s", $param_count, \e@params);
.Ve
.PP
By default it renders like \f(CW\*(C`sprintf\*(C'\fR,
with the following additional features:
.IP \(bu 4
Any complex references (like \f(CW\*(C`\e@params\*(C'\fR above) are automatically converted to
single-line strings with Data::Dumper.
.IP \(bu 4
Any undefined values are automatically converted to the string "<undef>".
.SS "Log level detection"
.IX Subsection "Log level detection"
To detect whether a log level is on, use "is_" followed by any of the log
levels or aliases. e.g.
.PP
.Vb 3
\&    if ($log\->is_info()) { ... }
\&    $log\->debug("arguments are: " . Dumper(\e@_))
\&        if $log\->is_debug();
.Ve
.PP
This is important for efficiency, as you can avoid the work of putting together
the logging message (in the above case, stringifying \f(CW@_\fR) if the log level is
not active.
.PP
The formatting methods (\f(CW\*(C`infof\*(C'\fR, \f(CW\*(C`errorf\*(C'\fR, etc.) check the log level for you.
.PP
Some logging mechanisms don't support detection of log levels. In these cases
the detection methods will always return 1.
.PP
In contrast, the default logging mechanism \- Null \- will return 0 for all
detection methods.
.SS "Log context data"
.IX Subsection "Log context data"
\&\f(CW\*(C`Log::Any\*(C'\fR supports logging context data by exposing the \f(CW\*(C`context\*(C'\fR
hashref. All the key/value pairs added to this hash will be printed
with every log message. You can localize the data so that it will be
removed again automatically at the end of the block:
.PP
.Vb 5
\&    $log\->context\->{directory} = $dir;
\&    for my $file (glob "$dir/*") {
\&        local $log\->context\->{file} = basename($file);
\&        $log\->warn("Can\*(Aqt read file!") unless \-r $file;
\&    }
.Ve
.PP
This will produce the following line:
.PP
.Vb 1
\&    Can\*(Aqt read file! {directory => \*(Aq/foo\*(Aq,file => \*(Aqbar\*(Aq}
.Ve
.PP
If the configured Log::Any::Adapter does not support structured
data, the context hash will be converted to a string using
Data::Dumper, and will be appended to the log message.
.SS "Setting an alternate default logger"
.IX Subsection "Setting an alternate default logger"
When no other adapters are configured for your logger, \f(CW\*(C`Log::Any\*(C'\fR
uses the \f(CW\*(C`default_adapter\*(C'\fR. To choose something other than Null as
the default, either set the \f(CW\*(C`LOG_ANY_DEFAULT_ADAPTER\*(C'\fR environment
variable, or pass it as a parameter when loading \f(CW\*(C`Log::Any\*(C'\fR
.PP
.Vb 1
\&    use Log::Any \*(Aq$log\*(Aq, default_adapter => \*(AqStderr\*(Aq;
.Ve
.PP
The name of the default class follows the same rules as used by Log::Any::Adapter.
.PP
To pass arguments to the default adapter's constructor, use an arrayref:
.PP
.Vb 1
\&    use Log::Any \*(Aq$log\*(Aq, default_adapter => [ \*(AqFile\*(Aq => \*(Aq/var/log/mylog.log\*(Aq ];
.Ve
.PP
When a consumer configures their own adapter, the default adapter will be
overridden. If they later remove their adapter, the default adapter will be
used again.
.SS "Configuring the proxy"
.IX Subsection "Configuring the proxy"
Any parameters passed on the import line or via the \f(CW\*(C`get_logger\*(C'\fR method
are passed on to the Log::Any::Proxy constructor.
.PP
.Vb 1
\&    use Log::Any \*(Aq$log\*(Aq, filter => \e&myfilter;
.Ve
.SS Testing
.IX Subsection "Testing"
Log::Any::Test provides a mechanism to test code that uses \f(CW\*(C`Log::Any\*(C'\fR.
.SH "CONSUMING LOGS (FOR APPLICATIONS)"
.IX Header "CONSUMING LOGS (FOR APPLICATIONS)"
Log::Any provides modules with a Log::Any::Proxy object, which is the log
producer.  To consume its output and direct it where you want (a file, the
screen, syslog, etc.), you use Log::Any::Adapter along with a
destination-specific subclass.
.PP
For example, to send output to a file via Log::Any::Adapter::File, your
application could do this:
.PP
.Vb 1
\&    use Log::Any::Adapter (\*(AqFile\*(Aq, \*(Aq/path/to/file.log\*(Aq);
.Ve
.PP
See the Log::Any::Adapter documentation for more details.
.PP
To detect if a consumer exists, use \f(CW\*(C`Log::Any\->has_consumer\*(C'\fR.
.SH "Q & A"
.IX Header "Q & A"
.IP "Isn't Log::Any just yet another logging mechanism?" 4
.IX Item "Isn't Log::Any just yet another logging mechanism?"
No. \f(CW\*(C`Log::Any\*(C'\fR does not include code that knows how to log to a particular
place (file, screen, etc.) It can only forward logging requests to another
logging mechanism.
.IP "Why don't you just pick the best logging mechanism, and use and promote it?" 4
.IX Item "Why don't you just pick the best logging mechanism, and use and promote it?"
Each of the logging mechanisms have their pros and cons, particularly in terms
of how they are configured. For example, log4perl offers a great deal of power
and flexibility but uses a global and potentially heavy configuration, whereas
Log::Dispatch is extremely configuration-light but doesn't handle
categories. There is also the unnamed future logger that may have advantages
over either of these two, and all the custom in-house loggers people have
created and cannot (for whatever reason) stop using.
.IP "Is it safe for my critical module to depend on Log::Any?" 4
.IX Item "Is it safe for my critical module to depend on Log::Any?"
Our intent is to keep \f(CW\*(C`Log::Any\*(C'\fR minimal, and change it only when absolutely
necessary. Most of the "innovation", if any, is expected to occur in
\&\f(CW\*(C`Log::Any::Adapter\*(C'\fR, which your module should not have to depend on (unless it
wants to direct logs somewhere specific). \f(CW\*(C`Log::Any\*(C'\fR has no non-core dependencies.
.IP "Why doesn't Log::Any use \fIinsert modern Perl technique\fR?" 4
.IX Item "Why doesn't Log::Any use insert modern Perl technique?"
To encourage CPAN module authors to adopt and use \f(CW\*(C`Log::Any\*(C'\fR, we aim to have
as few dependencies and chances of breakage as possible. Thus, no \f(CW\*(C`Moose\*(C'\fR or
other niceties.
.SH AUTHORS
.IX Header "AUTHORS"
.IP \(bu 4
Jonathan Swartz <swartz@pobox.com>
.IP \(bu 4
David Golden <dagolden@cpan.org>
.IP \(bu 4
Doug Bell <preaction@cpan.org>
.IP \(bu 4
Daniel Pittman <daniel@rimspace.net>
.IP \(bu 4
Stephen Thirlwall <sdt@cpan.org>
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
.IP \(bu 4
Andrew Grechkin <andrew.grechkin@gmail.com>
.IP \(bu 4
Andrew Hewus Fresh <andrew+github@afresh1.com>
.IP \(bu 4
bj5004 <bartosz.jakubski@hurra.com>
.IP \(bu 4
cm-perl <cm\-perl@users.noreply.github.com>
.IP \(bu 4
Doug Bell <preaction@users.noreply.github.com>
.IP \(bu 4
Jonathan <jjrs.pam+github@gmail.com>
.IP \(bu 4
Jonathan Rubin <jon.rubin@grantstreet.com>
.IP \(bu 4
Karen Etheridge <ether@cpan.org>
.IP \(bu 4
Konstantin S. Uvarin <khedin@gmail.com>
.IP \(bu 4
Larry Leszczynski <larryl@cpan.org>
.IP \(bu 4
Lucas Kanashiro <kanashiro.duarte@gmail.com>
.IP \(bu 4
Maros Kollar <maros.kollar@geizhals.at>
.IP \(bu 4
Maxim Vuets <maxim.vuets@booking.com>
.IP \(bu 4
mephinet <mephinet@gmx.net>
.IP \(bu 4
Michael Conrad <mconrad@intellitree.com>
.IP \(bu 4
Nick Tonkin <1nickt@users.noreply.github.com>
.IP \(bu 4
Paul Durden <alabamapaul@gmail.com>
.IP \(bu 4
Philipp Gortan <philipp.gortan@apa.at>
.IP \(bu 4
Phill Legault <saladdayllc@gmail.com>
.IP \(bu 4
Samuel Ng <samuel.ng@grantstreet.com>
.IP \(bu 4
Samuel Ng <sng@grantstreet.com>
.IP \(bu 4
Shlomi Fish <shlomif@shlomifish.org>
.IP \(bu 4
Sven Willenbuecher <sven.willenbuecher@kuehne\-nagel.com>
.IP \(bu 4
XSven <XSven@users.noreply.github.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2017 by Jonathan Swartz, David Golden, and Doug Bell.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
