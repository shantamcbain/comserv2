.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Schema::Loader 3pm"
.TH DBIx::Class::Schema::Loader 3pm 2024-01-06 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Schema::Loader \- Create a DBIx::Class::Schema based on a database
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    ### use this module to generate a set of class files
\&
\&    # in a script
\&    use DBIx::Class::Schema::Loader qw/ make_schema_at /;
\&    make_schema_at(
\&        \*(AqMy::Schema\*(Aq,
\&        { debug => 1,
\&          dump_directory => \*(Aq./lib\*(Aq,
\&        },
\&        [ \*(Aqdbi:Pg:dbname="foo"\*(Aq, \*(Aqmyuser\*(Aq, \*(Aqmypassword\*(Aq,
\&           { loader_class => \*(AqMyLoader\*(Aq } # optionally
\&        ],
\&    );
\&
\&    # from the command line or a shell script with dbicdump (distributed
\&    # with this module).  Do \`perldoc dbicdump\` for usage.
\&    dbicdump \-o dump_directory=./lib \e
\&             \-o components=\*(Aq["InflateColumn::DateTime"]\*(Aq \e
\&             \-o debug=1 \e
\&             My::Schema \e
\&             \*(Aqdbi:Pg:dbname=foo\*(Aq \e
\&             myuser \e
\&             mypassword
\&
\&    ### or generate and load classes at runtime
\&    # note: this technique is not recommended
\&    # for use in production code
\&
\&    package My::Schema;
\&    use base qw/DBIx::Class::Schema::Loader/;
\&
\&    _\|_PACKAGE_\|_\->loader_options(
\&        constraint              => \*(Aq^foo.*\*(Aq,
\&        # debug                 => 1,
\&    );
\&
\&    #### in application code elsewhere:
\&
\&    use My::Schema;
\&
\&    my $schema1 = My::Schema\->connect( $dsn, $user, $password, $attrs);
\&    # \-or\-
\&    my $schema1 = "My::Schema"; $schema1\->connection(as above);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
DBIx::Class::Schema::Loader automates the definition of a
DBIx::Class::Schema by scanning database table definitions and setting up
the columns, primary keys, unique constraints and relationships.
.PP
See dbicdump for the \f(CW\*(C`dbicdump\*(C'\fR utility.
.PP
DBIx::Class::Schema::Loader currently supports only the DBI storage type. It
has explicit support for DBD::Pg, DBD::mysql, DBD::DB2,
DBD::Firebird, DBD::InterBase, DBD::Informix, DBD::SQLAnywhere,
DBD::SQLite, DBD::Sybase (for Sybase ASE and MSSSQL), DBD::ODBC (for
MSSQL, MSAccess, Firebird and SQL Anywhere) DBD::ADO (for MSSQL and
MSAccess) and DBD::Oracle.  Other DBI drivers may function to a greater or
lesser degree with this loader, depending on how much of the DBI spec they
implement, and how standard their implementation is.
.PP
Patches to make other DBDs work correctly welcome.
.PP
See DBIx::Class::Schema::Loader::DBI::Writing for notes on writing
your own vendor-specific subclass for an unsupported DBD driver.
.PP
This module requires DBIx::Class 0.08127 or later, and obsoletes the older
DBIx::Class::Loader.
.PP
See DBIx::Class::Schema::Loader::Base for available options.
.SH METHODS
.IX Header "METHODS"
.SS loader
.IX Subsection "loader"
The loader object, as class data on your Schema. For methods available see
DBIx::Class::Schema::Loader::Base and DBIx::Class::Schema::Loader::DBI.
.SS loader_class
.IX Subsection "loader_class"
.ie n .IP "Argument: $loader_class" 4
.el .IP "Argument: \f(CW$loader_class\fR" 4
.IX Item "Argument: $loader_class"
.PP
Set the loader class to be instantiated when "connection" is called.
If the classname starts with "::", "DBIx::Class::Schema::Loader" is
prepended. Defaults to "storage_type" in DBIx::Class::Schema (which must
start with "::" when using DBIx::Class::Schema::Loader).
.PP
This is mostly useful for subclassing existing loaders or in conjunction
with "dump_to_dir".
.SS loader_options
.IX Subsection "loader_options"
.IP "Argument: \e%loader_options" 4
.IX Item "Argument: %loader_options"
.PP
Example in Synopsis above demonstrates a few common arguments.  For
detailed information on all of the arguments, most of which are
only useful in fairly complex scenarios, see the
DBIx::Class::Schema::Loader::Base documentation.
.PP
If you intend to use \f(CW\*(C`loader_options\*(C'\fR, you must call
\&\f(CW\*(C`loader_options\*(C'\fR before any connection is made, or embed the
\&\f(CW\*(C`loader_options\*(C'\fR in the connection information itself as shown
below.  Setting \f(CW\*(C`loader_options\*(C'\fR after the connection has
already been made is useless.
.SS connection
.IX Subsection "connection"
.ie n .IP "Arguments: @args" 4
.el .IP "Arguments: \f(CW@args\fR" 4
.IX Item "Arguments: @args"
.PD 0
.ie n .IP "Return Value: $new_schema" 4
.el .IP "Return Value: \f(CW$new_schema\fR" 4
.IX Item "Return Value: $new_schema"
.PD
.PP
See "connection" in DBIx::Class::Schema for basic usage.
.PP
If the final argument is a hashref, and it contains the keys \f(CW\*(C`loader_options\*(C'\fR
or \f(CW\*(C`loader_class\*(C'\fR, those keys will be deleted, and their values value will be
used for the loader options or class, respectively, just as if set via the
"loader_options" or "loader_class" methods above.
.PP
The actual auto-loading operation (the heart of this module) will be invoked
as soon as the connection information is defined.
.SS clone
.IX Subsection "clone"
See "clone" in DBIx::Class::Schema.
.SS dump_to_dir
.IX Subsection "dump_to_dir"
.ie n .IP "Argument: $directory" 4
.el .IP "Argument: \f(CW$directory\fR" 4
.IX Item "Argument: $directory"
.PP
Calling this as a class method on either DBIx::Class::Schema::Loader
or any derived schema class will cause all schemas to dump
manual versions of themselves to the named directory when they are
loaded.  In order to be effective, this must be set before defining a
connection on this schema class or any derived object (as the loading
happens as soon as both a connection and loader_options are set, and
only once per class).
.PP
See "dump_directory" in DBIx::Class::Schema::Loader::Base for more
details on the dumping mechanism.
.PP
This can also be set at module import time via the import option
\&\f(CW\*(C`dump_to_dir:/foo/bar\*(C'\fR to DBIx::Class::Schema::Loader, where
\&\f(CW\*(C`/foo/bar\*(C'\fR is the target directory.
.PP
Examples:
.PP
.Vb 3
\&    # My::Schema isa DBIx::Class::Schema::Loader, and has connection info
\&    #   hardcoded in the class itself:
\&    perl \-MDBIx::Class::Schema::Loader=dump_to_dir:/foo/bar \-MMy::Schema \-e1
\&
\&    # Same, but no hard\-coded connection, so we must provide one:
\&    perl \-MDBIx::Class::Schema::Loader=dump_to_dir:/foo/bar \-MMy::Schema \-e \*(AqMy::Schema\->connection("dbi:Pg:dbname=foo", ...)\*(Aq
\&
\&    # Or as a class method, as long as you get it done *before* defining a
\&    #  connection on this schema class or any derived object:
\&    use My::Schema;
\&    My::Schema\->dump_to_dir(\*(Aq/foo/bar\*(Aq);
\&    My::Schema\->connection(........);
\&
\&    # Or as a class method on the DBIx::Class::Schema::Loader itself, which affects all
\&    #   derived schemas
\&    use My::Schema;
\&    use My::OtherSchema;
\&    DBIx::Class::Schema::Loader\->dump_to_dir(\*(Aq/foo/bar\*(Aq);
\&    My::Schema\->connection(.......);
\&    My::OtherSchema\->connection(.......);
\&
\&    # Another alternative to the above:
\&    use DBIx::Class::Schema::Loader qw| dump_to_dir:/foo/bar |;
\&    use My::Schema;
\&    use My::OtherSchema;
\&    My::Schema\->connection(.......);
\&    My::OtherSchema\->connection(.......);
.Ve
.SS make_schema_at
.IX Subsection "make_schema_at"
.ie n .IP "Arguments: $schema_class_name, \e%loader_options, \e@connect_info" 4
.el .IP "Arguments: \f(CW$schema_class_name\fR, \e%loader_options, \e@connect_info" 4
.IX Item "Arguments: $schema_class_name, %loader_options, @connect_info"
.PD 0
.ie n .IP "Return Value: $schema_class_name" 4
.el .IP "Return Value: \f(CW$schema_class_name\fR" 4
.IX Item "Return Value: $schema_class_name"
.PD
.PP
This function creates a DBIx::Class schema from an existing RDBMS
schema.  With the \f(CW\*(C`dump_directory\*(C'\fR option, generates a set of
DBIx::Class classes from an existing database schema read from the
given dsn.  Without a \f(CW\*(C`dump_directory\*(C'\fR, creates schema classes in
memory at runtime without generating on-disk class files.
.PP
For a complete list of supported loader_options, see
DBIx::Class::Schema::Loader::Base
.PP
The last hashref in the \f(CW\*(C`\e@connect_info\*(C'\fR can specify the "loader_class".
.PP
This function can be imported in the usual way, as illustrated in
these Examples:
.PP
.Vb 10
\&    # Simple example, creates as a new class \*(AqNew::Schema::Name\*(Aq in
\&    #  memory in the running perl interpreter.
\&    use DBIx::Class::Schema::Loader qw/ make_schema_at /;
\&    make_schema_at(
\&        \*(AqNew::Schema::Name\*(Aq,
\&        { debug => 1 },
\&        [ \*(Aqdbi:Pg:dbname="foo"\*(Aq,\*(Aqpostgres\*(Aq,\*(Aq\*(Aq,
\&          { loader_class => \*(AqMyLoader\*(Aq } # optionally
\&        ],
\&    );
\&
\&    # Inside a script, specifying a dump directory in which to write
\&    # class files
\&    use DBIx::Class::Schema::Loader qw/ make_schema_at /;
\&    make_schema_at(
\&        \*(AqNew::Schema::Name\*(Aq,
\&        { debug => 1, dump_directory => \*(Aq./lib\*(Aq },
\&        [ \*(Aqdbi:Pg:dbname="foo"\*(Aq,\*(Aqpostgres\*(Aq,\*(Aq\*(Aq,
\&          { loader_class => \*(AqMyLoader\*(Aq } # optionally
\&        ],
\&    );
.Ve
.PP
The last hashref in the \f(CW\*(C`\e@connect_info\*(C'\fR is checked for loader arguments such
as \f(CW\*(C`loader_options\*(C'\fR and \f(CW\*(C`loader_class\*(C'\fR, see "connection" for more details.
.SS rescan
.IX Subsection "rescan"
.ie n .IP "Return Value: @new_monikers" 4
.el .IP "Return Value: \f(CW@new_monikers\fR" 4
.IX Item "Return Value: @new_monikers"
.PP
Re-scans the database for newly added tables since the initial
load, and adds them to the schema at runtime, including relationships,
etc.  Does not process drops or changes.
.PP
Returns a list of the new monikers added.
.SS naming
.IX Subsection "naming"
.ie n .IP "Arguments: \e%opts | $ver" 4
.el .IP "Arguments: \e%opts | \f(CW$ver\fR" 4
.IX Item "Arguments: %opts | $ver"
.PP
Controls the naming options for backward compatibility, see
"naming" in DBIx::Class::Schema::Loader::Base for details.
.PP
To upgrade a dynamic schema, use:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->naming(\*(Aqcurrent\*(Aq);
.Ve
.PP
Can be imported into your dump script and called as a function as well:
.PP
.Vb 1
\&    naming(\*(Aqv4\*(Aq);
.Ve
.SS use_namespaces
.IX Subsection "use_namespaces"
.IP "Arguments: 1|0" 4
.IX Item "Arguments: 1|0"
.PP
Controls the use_namespaces options for backward compatibility, see
"use_namespaces" in DBIx::Class::Schema::Loader::Base for details.
.PP
To upgrade a dynamic schema, use:
.PP
.Vb 1
\&    _\|_PACKAGE_\|_\->use_namespaces(1);
.Ve
.PP
Can be imported into your dump script and called as a function as well:
.PP
.Vb 1
\&    use_namespaces(1);
.Ve
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.SS "Multiple Database Schemas"
.IX Subsection "Multiple Database Schemas"
See "db_schema" in DBIx::Class::Schema::Loader::Base.
.SH ACKNOWLEDGEMENTS
.IX Header "ACKNOWLEDGEMENTS"
Matt S Trout, all of the #dbix\-class folks, and everyone who's ever sent
in a bug report or suggestion.
.PP
Based on DBIx::Class::Loader by Sebastian Riedel
.PP
Based upon the work of IKEBE Tomohiro
.SH AUTHORS
.IX Header "AUTHORS"
Caelum: Rafael Kitover <rkitover@cpan.org>
.PP
Dag-Erling Smørgrav <des@des.no>
.PP
Matias E. Fernandez <mfernandez@pisco.ch>
.PP
SineSwiper: Brendan Byrd <byrd.b@insightcom.com>
.PP
TSUNODA Kazuya <drk@drk7.jp>
.PP
acmoore: Andrew Moore <amoore@cpan.org>
.PP
alnewkirk: Al Newkirk <awncorp@cpan.org>
.PP
andrewalker: André Walker <andre@andrewalker.net>
.PP
angelixd: Paul C. Mantz <pcmantz@cpan.org>
.PP
arc: Aaron Crane <arc@cpan.org>
.PP
arcanez: Justin Hunter <justin.d.hunter@gmail.com>
.PP
ash: Ash Berlin <ash@cpan.org>
.PP
blblack: Brandon Black <blblack@gmail.com>
.PP
bphillips: Brian Phillips <bphillips@cpan.org>
.PP
btilly: Ben Tilly <btilly@gmail.com>
.PP
domm: Thomas Klausner <domm@plix.at>
.PP
ether: Karen Etheridge <ether@cpan.org>
.PP
gugu: Andrey Kostenko <a.kostenko@rambler\-co.ru>
.PP
hobbs: Andrew Rodland <arodland@cpan.org>
.PP
ilmari: Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
.PP
jhannah: Jay Hannah <jay@jays.net>
.PP
jnap: John Napiorkowski <jjn1056@yahoo.com>
.PP
kane: Jos Boumans <kane@cpan.org>
.PP
mattp: Matt Phillips <mattp@cpan.org>
.PP
mephinet: Philipp Gortan <philipp.gortan@apa.at>
.PP
moritz: Moritz Lenz <moritz@faui2k3.org>
.PP
mst: Matt S. Trout <mst@shadowcatsystems.co.uk>
.PP
mstratman: Mark A. Stratman <stratman@gmail.com>
.PP
oalders: Olaf Alders <olaf@wundersolutions.com>
.PP
rbo: Robert Bohne <rbo@cpan.org>
.PP
rbuels: Robert Buels <rbuels@gmail.com>
.PP
ribasushi: Peter Rabbitson <ribasushi@cpan.org>
.PP
schwern: Michael G. Schwern <mschwern@cpan.org>
.PP
spb: Stephen Bennett <spb@exherbo.org>
.PP
timbunce: Tim Bunce <timb@cpan.org>
.PP
waawaamilk: Nigel McNie <nigel@mcnie.name>
.PP
\&... and lots of other folks. If we forgot you, please write the current
maintainer or RT.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2006 \- 2015 by the aforementioned
"AUTHORS" in DBIx::Class::Schema::Loader.
.PP
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DBIx::Class, DBIx::Class::Manual::Intro, DBIx::Class::Tutorial,
DBIx::Class::Schema::Loader::Base
