.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Digest::SHA3 3pm"
.TH Digest::SHA3 3pm 2022-08-08 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Digest::SHA3 \- Perl extension for SHA\-3
.SH SYNOPSIS
.IX Header "SYNOPSIS"
In programs:
.PP
.Vb 1
\&                # Functional interface
\&
\&        use Digest::SHA3 qw(sha3_224 sha3_256_hex sha3_512_base64 ...);
\&
\&        $digest = sha3_224($data);
\&        $digest = sha3_256_hex($data);
\&        $digest = sha3_384_base64($data);
\&        $digest = sha3_512($data);
\&
\&                # Object\-oriented
\&
\&        use Digest::SHA3;
\&
\&        $sha3 = Digest::SHA3\->new($alg);
\&
\&        $sha3\->add($data);              # feed data into stream
\&
\&        $sha3\->addfile(*F);
\&        $sha3\->addfile($filename);
\&
\&        $sha3\->add_bits($bits);
\&        $sha3\->add_bits($data, $nbits);
\&
\&        $digest = $sha3\->digest;        # compute digest
\&        $digest = $sha3\->hexdigest;
\&        $digest = $sha3\->b64digest;
\&
\&                # Compute extendable\-length digest
\&
\&        $sha3 = Digest::SHA3\->new(128000)\->add($data);  # SHAKE128
\&        $digest  = $sha3\->squeeze;
\&        $digest .= $sha3\->squeeze;
\&        ...
\&
\&        $sha3 = Digest::SHA3\->new(256000)\->add($data);  # SHAKE256
\&        $digest  = $sha3\->squeeze;
\&        $digest .= $sha3\->squeeze;
\&        ...
.Ve
.SH ABSTRACT
.IX Header "ABSTRACT"
Digest::SHA3 is a complete implementation of the NIST SHA\-3
cryptographic hash function, as specified in FIPS 202 (SHA\-3
Standard: Permutation-Based Hash and Extendable-Output Functions).
.PP
The module gives Perl programmers a convenient way to calculate
SHA3\-224, SHA3\-256, SHA3\-384, and SHA3\-512 message digests, as well
as variable-length hashes using SHAKE128 and SHAKE256.  Digest::SHA3
can handle all types of input, including partial-byte data.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Digest::SHA3 is written in C for speed.  If your platform lacks a C
compiler, perhaps you can find the module in a binary form compatible
with your particular processor and operating system.
.PP
The programming interface is easy to use: it's the same one found
in CPAN's Digest module.  So, if your applications currently use
Digest::SHA and you'd prefer the newer flavor of the NIST standard,
it's a simple matter to convert them.
.PP
The interface provides two ways to calculate digests:  all-at-once,
or in stages.  To illustrate, the following short program computes
the SHA3\-256 digest of "hello world" using each approach:
.PP
.Vb 1
\&        use Digest::SHA3 qw(sha3_256_hex);
\&
\&        $data = "hello world";
\&        @frags = split(//, $data);
\&
\&        # all\-at\-once (Functional style)
\&        $digest1 = sha3_256_hex($data);
\&
\&        # in\-stages (OOP style)
\&        $state = Digest::SHA3\->new(256);
\&        for (@frags) { $state\->add($_) }
\&        $digest2 = $state\->hexdigest;
\&
\&        print $digest1 eq $digest2 ?
\&                "that\*(Aqs the ticket!\en" : "oops!\en";
.Ve
.PP
To calculate the digest of an n\-bit message where \fIn\fR is not a
multiple of 8, use the \fR\f(BIadd_bits()\fR\fI\fR method.  For example, consider
the 446\-bit message consisting of the bit-string "110" repeated
148 times, followed by "11".  Here's how to display its SHA3\-512
digest:
.PP
.Vb 4
\&        use Digest::SHA3;
\&        $bits = "110" x 148 . "11";
\&        $sha3 = Digest::SHA3\->new(512)\->add_bits($bits);
\&        print $sha3\->hexdigest, "\en";
.Ve
.PP
Note that for larger bit-strings, it's more efficient to use the
two-argument version \fIadd_bits($data, \fR\f(CI$nbits\fR\fI)\fR, where \fR\f(CI$data\fR\fI\fR is
in the customary packed binary format used for Perl strings.
.SH "UNICODE AND SIDE EFFECTS"
.IX Header "UNICODE AND SIDE EFFECTS"
Perl supports Unicode strings as of version 5.6.  Such strings may
contain wide characters: namely, characters whose ordinal values are
greater than 255.  This can cause problems for digest algorithms such
as SHA\-3 that are specified to operate on sequences of bytes.
.PP
The rule by which Digest::SHA3 handles a Unicode string is easy
to state, but potentially confusing to grasp: the string is interpreted
as a sequence of byte values, where each byte value is equal to the
ordinal value (viz. code point) of its corresponding Unicode character.
That way, the Unicode string 'abc' has exactly the same digest value as
the ordinary string 'abc'.
.PP
Since a wide character does not fit into a byte, the Digest::SHA3
routines croak if they encounter one.  Whereas if a Unicode string
contains no wide characters, the module accepts it quite happily.
The following code illustrates the two cases:
.PP
.Vb 2
\&        $str1 = pack(\*(AqU*\*(Aq, (0..255));
\&        print sha3_224_hex($str1);              # ok
\&
\&        $str2 = pack(\*(AqU*\*(Aq, (0..256));
\&        print sha3_224_hex($str2);              # croaks
.Ve
.PP
Be aware that the digest routines silently convert UTF\-8 input into its
equivalent byte sequence in the native encoding (cf. utf8::downgrade).
This side effect influences only the way Perl stores the data internally,
but otherwise leaves the actual value of the data intact.
.SH "PADDING OF BASE64 DIGESTS"
.IX Header "PADDING OF BASE64 DIGESTS"
By convention, CPAN Digest modules do \fBnot\fR pad their Base64 output.
Problems can occur when feeding such digests to other software that
expects properly padded Base64 encodings.
.PP
For the time being, any necessary padding must be done by the user.
Fortunately, this is a simple operation: if the length of a Base64\-encoded
digest isn't a multiple of 4, simply append "=" characters to the end
of the digest until it is:
.PP
.Vb 3
\&        while (length($b64_digest) % 4) {
\&                $b64_digest .= \*(Aq=\*(Aq;
\&        }
.Ve
.PP
To illustrate, \fIsha3_256_base64("abc")\fR is computed to be
.PP
.Vb 1
\&        Ophdp0/iJbIEXBcta9OQvYVfCG4+nVJbRr/iRRFDFTI
.Ve
.PP
which has a length of 43.  So, the properly padded version is
.PP
.Vb 1
\&        Ophdp0/iJbIEXBcta9OQvYVfCG4+nVJbRr/iRRFDFTI=
.Ve
.SH EXPORT
.IX Header "EXPORT"
None by default.
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
Provided your C compiler supports a 64\-bit type (e.g. the \fIlong
long\fR of C99, or \fI_\|_int64\fR used by Microsoft C/C++), all of these
functions will be available for use.  Otherwise you won't be able
to perform any of them.
.PP
In the interest of simplicity, maintainability, and small code size,
it's unlikely that future versions of this module will support a
32\-bit implementation.  Older platforms using 32\-bit\-only compilers
should continue to favor 32\-bit hash implementations such as SHA\-1,
SHA\-224, or SHA\-256.  The desire to use the SHA\-3 hash standard,
dating from 2015, should reasonably require that one's compiler
adhere to programming language standards dating from at least 1999.
.PP
\&\fIFunctional style\fR
.IP "\fBsha3_224($data, ...)\fR" 4
.IX Item "sha3_224($data, ...)"
.PD 0
.IP "\fBsha3_256($data, ...)\fR" 4
.IX Item "sha3_256($data, ...)"
.IP "\fBsha3_384($data, ...)\fR" 4
.IX Item "sha3_384($data, ...)"
.IP "\fBsha3_512($data, ...)\fR" 4
.IX Item "sha3_512($data, ...)"
.IP "\fBshake128($data, ...)\fR" 4
.IX Item "shake128($data, ...)"
.IP "\fBshake256($data, ...)\fR" 4
.IX Item "shake256($data, ...)"
.PD
Logically joins the arguments into a single string, and returns its
SHA3\-0/224/256/384/512 digest encoded as a binary string.
.Sp
The digest size for shake128 is 1344 bits (168 bytes); for shake256,
it's 1088 bits (136 bytes).  To obtain extendable-output from the
SHAKE algorithms, use the object-oriented interface with repeated
calls to the \fIsqueeze\fR method.
.IP "\fBsha3_224_hex($data, ...)\fR" 4
.IX Item "sha3_224_hex($data, ...)"
.PD 0
.IP "\fBsha3_256_hex($data, ...)\fR" 4
.IX Item "sha3_256_hex($data, ...)"
.IP "\fBsha3_384_hex($data, ...)\fR" 4
.IX Item "sha3_384_hex($data, ...)"
.IP "\fBsha3_512_hex($data, ...)\fR" 4
.IX Item "sha3_512_hex($data, ...)"
.IP "\fBshake128_hex($data, ...)\fR" 4
.IX Item "shake128_hex($data, ...)"
.IP "\fBshake256_hex($data, ...)\fR" 4
.IX Item "shake256_hex($data, ...)"
.PD
Logically joins the arguments into a single string, and returns
its SHA3\-0/224/256/384/512 or SHAKE128/256 digest encoded as a
hexadecimal string.
.IP "\fBsha3_224_base64($data, ...)\fR" 4
.IX Item "sha3_224_base64($data, ...)"
.PD 0
.IP "\fBsha3_256_base64($data, ...)\fR" 4
.IX Item "sha3_256_base64($data, ...)"
.IP "\fBsha3_384_base64($data, ...)\fR" 4
.IX Item "sha3_384_base64($data, ...)"
.IP "\fBsha3_512_base64($data, ...)\fR" 4
.IX Item "sha3_512_base64($data, ...)"
.IP "\fBshake128_base64($data, ...)\fR" 4
.IX Item "shake128_base64($data, ...)"
.IP "\fBshake256_base64($data, ...)\fR" 4
.IX Item "shake256_base64($data, ...)"
.PD
Logically joins the arguments into a single string, and returns
its SHA3\-0/224/256/384/512 or SHAKE128/256 digest encoded as a
Base64 string.
.Sp
It's important to note that the resulting string does \fBnot\fR contain
the padding characters typical of Base64 encodings.  This omission is
deliberate, and is done to maintain compatibility with the family of
CPAN Digest modules.  See "PADDING OF BASE64 DIGESTS" for details.
.PP
\&\fIOOP style\fR
.IP \fBnew($alg)\fR 4
.IX Item "new($alg)"
Returns a new Digest::SHA3 object.  Allowed values for \fR\f(CI$alg\fR\fI\fR
are 224, 256, 384, and 512 for the SHA3 algorithms; or 128000 and
256000 for SHAKE128 and SHAKE256, respectively.  If the argument
is missing, SHA3\-224 will be used by default.
.Sp
Invoking \fInew\fR as an instance method will not create a new object;
instead, it will simply reset the object to the initial state associated
with \fR\f(CI$alg\fR\fI\fR.  If the argument is missing, the object will continue
using the same algorithm that was selected at creation.
.IP \fBreset($alg)\fR 4
.IX Item "reset($alg)"
This method has exactly the same effect as \fInew($alg)\fR.  In fact,
\&\fIreset\fR is just an alias for \fInew\fR.
.IP \fBhashsize\fR 4
.IX Item "hashsize"
Returns the number of digest bits for this object.  The values
are 224, 256, 384, 512, 1344, and 1088 for SHA3\-224, SHA3\-256,
SHA3\-384, SHA3\-512, SHAKE128, and SHAKE256, respectively.
.IP \fBalgorithm\fR 4
.IX Item "algorithm"
Returns the digest algorithm for this object.  The values are 224,
256, 384, 512, 128000, and 256000 for SHA3\-224, SHA3\-256, SHA3\-384,
SHA3\-512, SHAKE128, and SHAKE256, respectively.
.IP \fBclone\fR 4
.IX Item "clone"
Returns a duplicate copy of the object.
.IP "\fBadd($data, ...)\fR" 4
.IX Item "add($data, ...)"
Logically joins the arguments into a single string, and uses it to
update the current digest state.  In other words, the following
statements have the same effect:
.Sp
.Vb 4
\&        $sha3\->add("a"); $sha3\->add("b"); $sha3\->add("c");
\&        $sha3\->add("a")\->add("b")\->add("c");
\&        $sha3\->add("a", "b", "c");
\&        $sha3\->add("abc");
.Ve
.Sp
The return value is the updated object itself.
.ie n .IP "\fBadd_bits($data, \fR\fB$nbits\fR\fB [, \fR\fB$lsb\fR\fB])\fR" 4
.el .IP "\fBadd_bits($data, \fR\f(CB$nbits\fR\fB [, \fR\f(CB$lsb\fR\fB])\fR" 4
.IX Item "add_bits($data, $nbits [, $lsb])"
.PD 0
.IP \fBadd_bits($bits)\fR 4
.IX Item "add_bits($bits)"
.PD
Updates the current digest state by appending bits to it.  The
return value is the updated object itself.
.Sp
The first form causes the most-significant \fR\f(CI$nbits\fR\fI\fR of \fI\fR\f(CI$data\fR\fI\fR to
be appended to the stream.  The \fI\fR\f(CI$data\fR\fI\fR argument is in the customary
binary format used for Perl strings.  Setting the optional \fI\fR\f(CI$lsb\fR\fI\fR
flag to a true value indicates that the final (partial) byte of
\&\fI\fR\f(CI$data\fR\fI\fR is aligned with the least-significant bit; by default it's
aligned with the most-significant bit, as required by the parent
Digest module.
.Sp
The second form takes an ASCII string of "0" and "1" characters as
its argument.  It's equivalent to
.Sp
.Vb 1
\&        $sha3\->add_bits(pack("B*", $bits), length($bits));
.Ve
.Sp
So, the following three statements do the same thing:
.Sp
.Vb 3
\&        $sha3\->add_bits("111100001010");
\&        $sha3\->add_bits("\exF0\exA0", 12);
\&        $sha3\->add_bits("\exF0\ex0A", 12, 1);
.Ve
.Sp
SHA\-3 uses least-significant-bit ordering for its internal operation.
This means that
.Sp
.Vb 1
\&        $sha3\->add_bits("110");
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&        $sha3\->add_bits("0")\->add_bits("1")\->add_bits("1");
.Ve
.Sp
Many public test vectors for SHA\-3, such as the Keccak known-answer
tests, are delivered in least-significant-bit format.  Using the
optional \fR\f(CI$lsb\fR\fI\fR flag in these cases allows your code to be simpler
and more efficient.  See the test directory for examples.
.Sp
The fact that SHA\-2 and SHA\-3 employ opposite bit-ordering schemes
has caused noticeable confusion in the programming community.
Exercise caution if your code examines individual bits in data
streams.
.IP \fBaddfile(*FILE)\fR 4
.IX Item "addfile(*FILE)"
Reads from \fIFILE\fR until EOF, and appends that data to the current
state.  The return value is the updated object itself.
.ie n .IP "\fBaddfile($filename [, \fR\fB$mode\fR\fB])\fR" 4
.el .IP "\fBaddfile($filename [, \fR\f(CB$mode\fR\fB])\fR" 4
.IX Item "addfile($filename [, $mode])"
Reads the contents of \fR\f(CI$filename\fR\fI\fR, and appends that data to the current
state.  The return value is the updated object itself.
.Sp
By default, \fR\f(CI$filename\fR\fI\fR is simply opened and read; no special modes
or I/O disciplines are used.  To change this, set the optional \fI\fR\f(CI$mode\fR\fI\fR
argument to one of the following values:
.Sp
.Vb 1
\&        "b"     read file in binary mode
\&
\&        "U"     use universal newlines
\&
\&        "0"     use BITS mode
.Ve
.Sp
The "U" mode is modeled on Python's "Universal Newlines" concept, whereby
DOS and Mac OS line terminators are converted internally to UNIX newlines
before processing.  This ensures consistent digest values when working
simultaneously across multiple file systems.  \fBThe "U" mode influences
only text files\fR, namely those passing Perl's \fI\-T\fR test; binary files
are processed with no translation whatsoever.
.Sp
The BITS mode ("0") interprets the contents of \fR\f(CI$filename\fR\fI\fR as a logical
stream of bits, where each ASCII '0' or '1' character represents a 0 or
1 bit, respectively.  All other characters are ignored.  This provides
a convenient way to calculate the digest values of partial-byte data by
using files, rather than having to write programs using the \fIadd_bits\fR
method.
.IP \fBdigest\fR 4
.IX Item "digest"
Returns the digest encoded as a binary string.
.Sp
Note that the \fIdigest\fR method is a read-once operation. Once it
has been performed, the Digest::SHA3 object is automatically reset
in preparation for calculating another digest value.  Call
\&\fR\f(CI$sha\fR\fI\->clone\->digest\fR if it's necessary to preserve the
original digest state.
.IP \fBhexdigest\fR 4
.IX Item "hexdigest"
Returns the digest encoded as a hexadecimal string.
.Sp
Like \fIdigest\fR, this method is a read-once operation.  Call
\&\fR\f(CI$sha\fR\fI\->clone\->hexdigest\fR if it's necessary to preserve the
original digest state.
.IP \fBb64digest\fR 4
.IX Item "b64digest"
Returns the digest encoded as a Base64 string.
.Sp
Like \fIdigest\fR, this method is a read-once operation.  Call
\&\fR\f(CI$sha\fR\fI\->clone\->b64digest\fR if it's necessary to preserve the
original digest state.
.Sp
It's important to note that the resulting string does \fBnot\fR contain
the padding characters typical of Base64 encodings.  This omission
is deliberate, and is done to maintain compatibility with the
family of CPAN Digest modules.  See "PADDING OF BASE64 DIGESTS"
for details.
.IP \fBsqueeze\fR 4
.IX Item "squeeze"
Returns the next 168 (136) bytes of the SHAKE128 (SHAKE256) digest
encoded as a binary string.  The \fIsqueeze\fR method may be called
repeatedly to construct digests of any desired length.
.Sp
This method is \fBapplicable only to SHAKE128 and SHAKE256 objects\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest, Digest::SHA, Digest::Keccak
.PP
The FIPS 202 SHA\-3 Standard can be found at:
.PP
<http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf>
.PP
The Keccak/SHA\-3 specifications can be found at:
.PP
<http://keccak.noekeon.org/Keccak\-reference\-3.0.pdf>
<http://keccak.noekeon.org/Keccak\-submission\-3.pdf>
.SH AUTHOR
.IX Header "AUTHOR"
.Vb 1
\&        Mark Shelor     <mshelor@cpan.org>
.Ve
.SH ACKNOWLEDGMENTS
.IX Header "ACKNOWLEDGMENTS"
The author is particularly grateful to
.PP
.Vb 5
\&        Guido Bertoni
\&        Joan Daemen
\&        Michael Peeters
\&        Chris Skiscim
\&        Gilles Van Assche
.Ve
.PP
"Nothing is more fatiguing nor, in the long run, more exasperating than
the daily effort to believe things which daily become more incredible.
To be done with this effort is an indispensible condition of secure
and lasting happiness."
\&\- Bertrand Russell
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012\-2022 Mark Shelor
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
perlartistic
