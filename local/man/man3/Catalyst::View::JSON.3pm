.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::View::JSON 3pm"
.TH Catalyst::View::JSON 3pm 2019-04-28 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::View::JSON \- JSON view for your data
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 4
\&  # lib/MyApp/View/JSON.pm
\&  package MyApp::View::JSON;
\&  use base qw( Catalyst::View::JSON );
\&  1;
\&
\&  # configure in lib/MyApp.pm
\&  MyApp\->config({
\&      ...
\&      \*(AqView::JSON\*(Aq => {
\&          allow_callback  => 1,    # defaults to 0
\&          callback_param  => \*(Aqcb\*(Aq, # defaults to \*(Aqcallback\*(Aq
\&          expose_stash    => [ qw(foo bar) ], # defaults to everything
\&      },
\&  });
\&
\&  sub hello : Local {
\&      my($self, $c) = @_;
\&      $c\->stash\->{message} = \*(AqHello World!\*(Aq;
\&      $c\->forward(\*(AqView::JSON\*(Aq);
\&  }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Catalyst::View::JSON is a Catalyst View handler that returns stash
data in JSON format.
.SH "CONFIG VARIABLES"
.IX Header "CONFIG VARIABLES"
.IP allow_callback 4
.IX Item "allow_callback"
Flag to allow callbacks by adding \f(CW\*(C`callback=function\*(C'\fR. Defaults to 0
(doesn't allow callbacks). See "CALLBACKS" for details.
.IP callback_param 4
.IX Item "callback_param"
Name of URI parameter to specify JSON callback function name. Defaults
to \f(CW\*(C`callback\*(C'\fR. Only effective when \f(CW\*(C`allow_callback\*(C'\fR is turned on.
.IP expose_stash 4
.IX Item "expose_stash"
Scalar, List or regular expression object, to specify which stash keys are
exposed as a JSON response. Defaults to everything. Examples configuration:
.Sp
.Vb 2
\&  # use \*(Aqjson_data\*(Aq value as a data to return
\&  expose_stash => \*(Aqjson_data\*(Aq,
\&
\&  # only exposes keys \*(Aqfoo\*(Aq and \*(Aqbar\*(Aq
\&  expose_stash => [ qw( foo bar ) ],
\&
\&  # only exposes keys that matches with /^json_/
\&  expose_stash => qr/^json_/,
.Ve
.Sp
Suppose you have data structure of the following.
.Sp
.Vb 2
\&  $c\->stash\->{foo} = [ 1, 2 ];
\&  $c\->stash\->{bar} = 2;
.Ve
.Sp
By default, this view will return:
.Sp
.Vb 1
\&  {"foo":[1,2],"bar":2}
.Ve
.Sp
When you set \f(CW\*(C`expose_stash => [ \*(Aqfoo\*(Aq ]\*(C'\fR, it'll return
.Sp
.Vb 1
\&  {"foo":[1,2]}
.Ve
.Sp
and in the case of \f(CW\*(C`expose_stash => \*(Aqfoo\*(Aq\*(C'\fR, it'll just return
.Sp
.Vb 1
\&  [1,2]
.Ve
.Sp
instead of the whole object (hashref in perl). This option will be
useful when you share the method with different views (e.g. TT) and
don't want to expose non-irrelevant stash variables as in JSON.
.IP no_x_json_header 4
.IX Item "no_x_json_header"
.Vb 1
\&  no_x_json_header: 1
.Ve
.Sp
By default this plugin sets X\-JSON header if the requested client is a
Prototype.js with X\-JSON support. By setting 1, you can opt-out this
behavior so that you can do \fBeval()\fR by your own. Defaults to 0.
.IP json_encoder_args 4
.IX Item "json_encoder_args"
An optional hashref that supplies arguments to JSON::MaybeXS used when creating
a new object.
.IP use_force_bom 4
.IX Item "use_force_bom"
If versions of this view older than 0.36, there was some code that added a UTF\-8 BOM
marker to the end of the JSON string when the user agent was Safari.  After looking
at a lot of existing code I don't think this is needed anymore so we removed it by
default.  However if this turns out to be a problem you can re enable it by setting
this attribute to true.  Possible a breaking change so we offer this workaround.
.Sp
You may also override the method 'user_agent_bom_test' which received the current
request user agent string to try and better determine if this is needed.  Patches
for this welcomed.
.SH METHODS
.IX Header "METHODS"
.SS process
.IX Subsection "process"
Standard target of \f(CW$c\fR\->forward used to prepare a response
.SS render
.IX Subsection "render"
The methods accepts either of the following argument signatures in order to promote
compatibility with the semi standard render method as define in numerous Catalyst
views on CPAN:
.PP
.Vb 2
\&    my $json_string = $c\->view(\*(AqJSON\*(Aq)\->render($c, undef, $data);
\&    my $json_string = $c\->view(\*(AqJSON\*(Aq)\->render($c, $data);
.Ve
.PP
Given '$data' returns the JSON serialized version, or throws and error.
.SH "OVERRIDING JSON ENCODER"
.IX Header "OVERRIDING JSON ENCODER"
By default it uses JSON::MaybeXS::encode_json to serialize perl data structure into
JSON data format. If you want to avoid this and encode with your own
encoder (like passing different options to JSON::MaybeXS etc.), you can implement
the \f(CW\*(C`encode_json\*(C'\fR method in your View class.
.PP
.Vb 2
\&  package MyApp::View::JSON;
\&  use base qw( Catalyst::View::JSON );
\&
\&  use JSON::MaybeXS ();
\&
\&  sub encode_json {
\&      my($self, $c, $data) = @_;
\&      my $encoder = JSON::MaybeXS\->new\->(ascii => 1, pretty => 1, allow_nonref => 1);
\&      $encoder\->encode($data);
\&  }
\&
\&  1;
.Ve
.SH ENCODINGS
.IX Header "ENCODINGS"
\&\fBNOTE\fR Starting in release v5.90080 Catalyst encodes all text
like body returns as UTF8.  It however ignores content types like
application/json and assumes that a correct JSON serializer is
doing what it is supposed to do, which is encode UTF8 automatically.
In general this is what this view does so you shoulding need to
mess with the encoding flag here unless you have some odd case.
.PP
Also, the comment about regard 'browser gotcha's' was written a
number of years ago and I can't say one way or another if those
gotchas continue to be common in the wild.
.PP
\&\fBNOTE\fR Setting this configuation has no bearing on how the actual
serialized string is encoded.  This ONLY sets the content type
header in your response.  By default we set the 'utf8' flag on
JSON::MaybeXS so that the string generated and set to your response
body is proper UTF8 octets that can be transmitted over HTTP.  If
you are planning to do some alternative encoding you should turn off
this default via the \f(CW\*(C`json_encoder_args\*(C'\fR:
.PP
.Vb 2
\&    MyApp::View::JSON\->config(
\&      json_encoder_args => +{utf8=>0} );
.Ve
.PP
\&\fBNOTE\fR In 2015 the use of UTF8 as encoding is widely standard so it
is very likely you should need to do nothing to get the correct
encoding.  The following documentation will remain for historical
value and backcompat needs.
.PP
Due to the browser gotchas like those of Safari and Opera, sometimes
you have to specify a valid charset value in the response's
Content-Type header, e.g. \f(CW\*(C`text/javascript; charset=utf\-8\*(C'\fR.
.PP
Catalyst::View::JSON comes with the configuration variable \f(CW\*(C`encoding\*(C'\fR
which defaults to utf\-8. You can change it via \f(CW\*(C`YourApp\->config\*(C'\fR
or even runtime, using \f(CW\*(C`component\*(C'\fR.
.PP
.Vb 1
\&  $c\->component(\*(AqView::JSON\*(Aq)\->encoding(\*(Aqeuc\-jp\*(Aq);
.Ve
.PP
This assumes you set your stash data in raw euc-jp bytes, or Unicode
flagged variable. In case of Unicode flagged variable,
Catalyst::View::JSON automatically encodes the data into your
\&\f(CW\*(C`encoding\*(C'\fR value (euc-jp in this case) before emitting the data to
the browser.
.PP
Another option would be to use \fIJavaScript-UCS\fR as an encoding (and
pass Unicode flagged string to the stash). That way all non-ASCII
characters in the output JSON will be automatically encoded to
JavaScript Unicode encoding like \fI\euXXXX\fR. You have to install
Encode::JavaScript::UCS to use the encoding.
.SH CALLBACKS
.IX Header "CALLBACKS"
By default it returns raw JSON data so your JavaScript app can deal
with using XMLHttpRequest calls. Adding callbacks (JSONP) to the API
gives more flexibility to the end users of the API: overcome the
cross-domain restrictions of XMLHttpRequest. It can be done by
appending \fIscript\fR node with dynamic DOM manipulation, and associate
callback handler to the returned data.
.PP
For example, suppose you have the following code.
.PP
.Vb 8
\&  sub end : Private {
\&      my($self, $c) = @_;
\&      if ($c\->req\->param(\*(Aqoutput\*(Aq) eq \*(Aqjson\*(Aq) {
\&          $c\->forward(\*(AqView::JSON\*(Aq);
\&      } else {
\&          ...
\&      }
\&  }
.Ve
.PP
\&\f(CW\*(C`/foo/bar?output=json\*(C'\fR will just return the data set in
\&\f(CW\*(C`$c\->stash\*(C'\fR as JSON format, like:
.PP
.Vb 1
\&  { result: "foo", message: "Hello" }
.Ve
.PP
but \f(CW\*(C`/foo/bar?output=json&callback=handle_result\*(C'\fR will give you:
.PP
.Vb 1
\&  handle_result({ result: "foo", message: "Hello" });
.Ve
.PP
and you can write a custom \f(CW\*(C`handle_result\*(C'\fR function to handle the
returned data asynchronously.
.PP
The valid characters you can use in the callback function are
.PP
.Vb 1
\&  [a\-zA\-Z0\-9\e.\e_\e[\e]]
.Ve
.PP
but you can customize the behaviour by overriding the
\&\f(CW\*(C`validate_callback_param\*(C'\fR method in your View::JSON class.
.PP
See <http://developer.yahoo.net/common/json.html> and
<http://ajaxian.com/archives/jsonp\-json\-with\-padding> for more about
JSONP.
.PP
\&\fBNOTE\fR For another way to enable JSONP in your application take a look
at Plack::Middleware::JSONP
.SH INTEROPERABILITY
.IX Header "INTEROPERABILITY"
JSON use is still developing and has not been standardized. This
section provides some notes on various libraries.
.PP
Dojo Toolkit: Setting dojo.io.bind's mimetype to 'text/json' in
the JavaScript request will instruct dojo.io.bind to expect JSON
data in the response body and auto-eval it. Dojo ignores the
server response Content-Type. This works transparently with
Catalyst::View::JSON.
.PP
Prototype.js: prototype.js will auto-eval JSON data that is
returned in the custom X\-JSON header. The reason given for this is
to allow a separate HTML fragment in the response body, however
this of limited use because IE 6 has a max header length that will
cause the JSON evaluation to silently fail when reached. The
recommend approach is to use Catalyst::View::JSON which will JSON
format all the response data and return it in the response body.
.PP
In at least prototype 1.5.0 rc0 and above, prototype.js will send the
X\-Prototype-Version header. If this is encountered, a JavaScript eval
will be returned in the X\-JSON response header to automatically eval
the response body, unless you set \fIno_x_json_header\fR to 1. If your
version of prototype does not send this header, you can manually eval
the response body using the following JavaScript:
.PP
.Vb 7
\&  evalJSON: function(request) {
\&    try {
\&      return eval(\*(Aq(\*(Aq + request.responseText + \*(Aq)\*(Aq);
\&    } catch (e) {}
\&  }
\&  // elsewhere
\&  var json = this.evalJSON(request);
.Ve
.PP
\&\fBNOTE\fR The above comments were written a number of years ago and
I would take then with a grain of salt so to speak.  For now I will
leave them in place but not sure they are meaningful in 2015.
.SH "SECURITY CONSIDERATION"
.IX Header "SECURITY CONSIDERATION"
Catalyst::View::JSON makes the data available as a (sort of)
JavaScript to the client, so you might want to be careful about the
security of your data.
.SS "Use callbacks only for public data"
.IX Subsection "Use callbacks only for public data"
When you enable callbacks (JSONP) by setting \f(CW\*(C`allow_callback\*(C'\fR, all
your JSON data will be available cross-site. This means embedding
private data of logged-in user to JSON is considered bad.
.PP
.Vb 3
\&  # MyApp.yaml
\&  View::JSON:
\&    allow_callback: 1
\&
\&  sub foo : Local {
\&      my($self, $c) = @_;
\&      $c\->stash\->{address} = $c\->user\->street_address; # BAD
\&      $c\->forward(\*(AqView::JSON\*(Aq);
\&  }
.Ve
.PP
If you want to enable callbacks in a controller (for public API) and
disable in another, you need to create two different View classes,
like MyApp::View::JSON and MyApp::View::JSONP, because
\&\f(CW\*(C`allow_callback\*(C'\fR is a static configuration of the View::JSON class.
.PP
See <http://ajaxian.com/archives/gmail\-csrf\-security\-flaw> for more.
.SS "Avoid valid cross-site JSON requests"
.IX Subsection "Avoid valid cross-site JSON requests"
Even if you disable the callbacks, the nature of JavaScript still has
a possibility to access private JSON data cross-site, by overriding
Array constructor \f(CW\*(C`[]\*(C'\fR.
.PP
.Vb 3
\&  # MyApp.yaml
\&  View::JSON:
\&    expose_stash: json
\&
\&  sub foo : Local {
\&      my($self, $c) = @_;
\&      $c\->stash\->{json} = [ $c\->user\->street_address ]; # BAD
\&      $c\->forward(\*(AqView::JSON\*(Aq);
\&  }
.Ve
.PP
When you return logged-in user's private data to the response JSON,
you might want to disable GET requests (because \fIscript\fR tag invokes
GET requests), or include a random digest string and validate it.
.PP
See
<http://jeremiahgrossman.blogspot.com/2006/01/advanced\-web\-attack\-techniques\-using.html>
for more.
.SH AUTHOR
.IX Header "AUTHOR"
Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.SH LICENSE
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
Following people has been contributing patches, bug reports and
suggestions for the improvement of Catalyst::View::JSON.
.PP
.Vb 5
\&  John Wang
\&  kazeburo
\&  Daisuke Murase
\&  Jun Kuriyama
\&  Tomas Doran
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst, JSON::MaybeXS, Encode::JavaScript::UCS
.PP
<http://www.prototypejs.org/learn/json>
<http://docs.jquery.com/Ajax/jQuery.getJSON>
<http://manual.dojotoolkit.org/json.html>
<http://developer.yahoo.com/yui/json/>
