.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Catalyst::Plugin::Authorization::ACL 3pm"
.TH Catalyst::Plugin::Authorization::ACL 3pm 2014-05-15 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Catalyst::Plugin::Authorization::ACL \- ACL support for Catalyst applications.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 5
\&        use Catalyst qw/
\&                Authentication
\&                Authorization::Roles
\&                Authorization::ACL
\&        /;
\&
\&        _\|_PACKAGE_\|_\->setup;
\&
\&        _\|_PACKAGE_\|_\->deny_access_unless(
\&                "/foo/bar",
\&                [qw/nice_role/],
\&        );
\&
\&        _\|_PACKAGE_\|_\->allow_access_if(
\&                "/foo/bar/gorch",
\&                sub { return $boolean },
\&        );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module provides Access Control List style path protection, with arbitrary
rules for Catalyst applications. It operates only on the Catalyst
private namespace, at least at the moment.
.PP
The two hierarchies of actions and controllers in Catalyst are:
.IP "Private Namespace" 4
.IX Item "Private Namespace"
Every action has its own private path. This path reflects the Perl namespaces
the actions were born in, and the namespaces of their controllers.
.IP "External Namespace" 4
.IX Item "External Namespace"
Some actions are also directly accessible from the outside, via a URL.
.Sp
The private and external paths will be the same, if you are using Local actions. Alternatively you can use \f(CW\*(C`Path\*(C'\fR, \f(CW\*(C`Regex\*(C'\fR, or \f(CW\*(C`Global\*(C'\fR to specify a different external path for your action.
.PP
The ACL module currently only knows to exploit the private namespace. In the
future extensions may be made to support external namespaces as well.
.PP
Various types of rules are supported, see the list under "RULES".
.PP
When a path is visited, rules are tested one after the other, with the most
exact rule fitting the path first, and continuing up the path. Testing
continues until a rule explcitly allows or denies access.
.SH METHODS
.IX Header "METHODS"
.SS allow_access_if
.IX Subsection "allow_access_if"
Arguments: \f(CW$path\fR, \f(CW$rule\fR
.PP
Check the rule condition and allow access to the actions under \f(CW$path\fR if
the rule returns true.
.PP
This is normally useful to allow acces only to a specific part of a tree whose
parent has a \f(CW\*(C`deny_access_unless\*(C'\fR clause attached to it.
.PP
If the rule test returns false access is not denied or allowed. Instead
the next rule in the chain will be checked \- in this sense the combinatory
behavior of these rules is like logical \fBOR\fR.
.SS allow_access_if_any
.IX Subsection "allow_access_if_any"
Arguments: \f(CW$path\fR, \e@roles
.PP
Same as above for any role in the list.
.SS deny_access_unless
.IX Subsection "deny_access_unless"
Arguments: \f(CW$path\fR, \f(CW$rule\fR
.PP
Check the rule condition and disallow access if the rule returns false.
.PP
This is normally useful to restrict access to any portion of the application
unless a certain condition can be met.
.PP
If the rule test returns true access is not allowed or denied. Instead the
next rule in the chain will be checked \- in this sense the combinatory
behavior of these rules is like logical \fBAND\fR.
.SS deny_access_unless_any
.IX Subsection "deny_access_unless_any"
Arguments: \f(CW$path\fR, \e@roles
.PP
Same as above for any role in the list.
.SS allow_access
.IX Subsection "allow_access"
.SS deny_access
.IX Subsection "deny_access"
Arguments: \f(CW$path\fR
.PP
Unconditionally allow or deny access to a path.
.SS acl_add_rule
.IX Subsection "acl_add_rule"
Arguments: \f(CW$path\fR, \f(CW$rule\fR, [ \f(CW$filter\fR ]
.PP
Manually add a rule to all the actions under \f(CW$path\fR using the more flexible
(but more verbose) method:
.PP
.Vb 9
\&    _\|_PACKAGE_\|_\->acl_add_rule(
\&        "/foo",
\&        sub { ... }, # see FLEXIBLE RULES below
\&        sub {
\&            my $action = shift;
\&            # return a true value if you want to apply the rule to this action
\&            # called for all the actions under "/foo"
\&        }
\&    };
.Ve
.PP
In this case the rule must be a sub reference (or method name) to be invoked on
\&\f(CW$c\fR.
.PP
The default filter will skip all actions starting with an underscore, namely
\&\f(CW\*(C`_DISPATCH\*(C'\fR, \f(CW\*(C`_AUTO\*(C'\fR, etc (but not \f(CW\*(C`auto\*(C'\fR, \f(CW\*(C`begin\*(C'\fR, et al).
.SS acl_access_denied
.IX Subsection "acl_access_denied"
Arguments: \f(CW$c\fR, \f(CW$class\fR, \f(CW$action\fR, \f(CW$err\fR
.SS acl_access_allowed
.IX Subsection "acl_access_allowed"
Arguments: \f(CW$c\fR, \f(CW$class\fR, \f(CW$action\fR
.PP
The default event handlers for access denied or allowed conditions. See below
on handling access violations.
.SS acl_allow_root_internals
.IX Subsection "acl_allow_root_internals"
Adds rules that permit access to the root controller (YourApp.pm) \f(CW\*(C`auto\*(C'\fR,
\&\f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR unconditionally.
.SH "EXTENDED METHODS"
.IX Header "EXTENDED METHODS"
.SS execute
.IX Subsection "execute"
The hook for rule evaluation
.SS setup_actions
.IX Subsection "setup_actions"
.SH "RULE EVALUATION"
.IX Header "RULE EVALUATION"
When a rule is attached to an action the "distance" from the path it was
specified in is recorded. The closer the path is to the rule, the earlier it
will be checked.
.PP
Any rule can either explicitly deny or explicitly allow access to a particular
action. If a rule does not explicitly allow or permit access, the next rule is
checked, until the list of rules is finished. If no rule has determined a
policy, access to the path will be permitted.
.SH PATHS
.IX Header "PATHS"
To apply a rule to an action or group of actions you must supply a path.
.PP
This path is what you should see dumped at the beginning of the Catalyst
server's debug output.
.PP
For example, for the \f(CW\*(C`foo\*(C'\fR action defined at the root level of your
application, specify \f(CW\*(C`/foo\*(C'\fR. Under the \f(CW\*(C`Moose\*(C'\fR controller (e.g.
\&\f(CW\*(C`MyApp::C::Moose\*(C'\fR, the action \f(CW\*(C`bar\*(C'\fR will be \f(CW\*(C`/moose/bar\*(C'\fR).
.PP
The "distance" a path has from an action that is contained in it is the the
difference in the number of slashes between the path of the action, and the
path to which the rule was applied.
.SH RULES
.IX Header "RULES"
.SS "Easy Rules"
.IX Subsection "Easy Rules"
There are several kinds of rules you can create without using the complex
interface described in "FLEXIBLE RULES".
.PP
The easy rules are all predicate list oriented. \f(CW\*(C`allow_access_if\*(C'\fR will
explicitly allow access if the predicate is true, and \f(CW\*(C`deny_access_unless\*(C'\fR
will explicitly disallow if the predicate is false.
.IP "Role Lists" 4
.IX Item "Role Lists"
.Vb 1
\&  _\|_PACAKGE_\|_\->deny_access_unless_any( "/foo/bar", [qw/admin moose_trainer/] );
.Ve
.Sp
When the role is evaluated the Catalyst::Plugin::Authorization::Roles will
be used to check whether the currently logged in user has the specified roles.
.Sp
If "allow_access_if_any" is used, the presence of \fBany\fR of the roles in
the list will immediately permit access, and if "deny_access_unless_any" is
used, the lack of \fBall\fR of the roles will immediately deny access.
.Sp
Similarly, if \f(CW\*(C`allow_access_if\*(C'\fR is used, the presence of \fBall\fR the roles will
immediately permit access, and if \f(CW\*(C`deny_access_unless\*(C'\fR is used, the lack of
\&\fBany\fR of the roles will immediately deny access.
.Sp
When specifying a role list without the
Catalyst::Plugin::Authorization::Roles plugin loaded the ACL engine will
throw an error.
.IP "Predicate Code Reference / Method Name" 4
.IX Item "Predicate Code Reference / Method Name"
The code reference or method is invoked with the context and the action
objects. The boolean return value will determine the behavior of the rule.
.Sp
.Vb 2
\&    _\|_PACKAGE_\|_\->allow_access_if( "/gorch", sub { ... } );
\&    _\|_PACKAGE_\|_\->deny_access_unless( "/moose", "method_name" );
.Ve
.Sp
When specifying a method name the rule engine ensures that it can be invoked
using "can" in UNIVERSAL.
.IP Constant 4
.IX Item "Constant"
You can use \f(CW\*(C`undef\*(C'\fR, \f(CW0\fR and \f(CW\*(Aq\*(Aq\fR to use as a constant false predicate, or
\&\f(CW1\fR to use as a constant true predicate.
.SS "Flexible Rules"
.IX Subsection "Flexible Rules"
These rules are the most annoying to write but provide the most flexibility.
.PP
All access control is performed using exceptions \-
\&\f(CW$Catalyst::Plugin::Authorization::ACL::Engine::DENIED\fR, and
\&\f(CW$Catalyst::Plugin::Authorization::ACL::Engine::ALLOWED\fR (these can be
imported from the engine module).
.PP
If no rule decides to explicitly allow or deny access, access will be
permitted.
.PP
Here is a rule that will always break out of rule processing by either
explicitly allowing or denying access based on how much mojo the current
user has:
.PP
.Vb 4
\&    _\|_PACKAGE_\|_\->acl_add_rule(
\&        "/foo",
\&        sub {
\&            my ( $c, $action ) = @_;
\&
\&            if ( $c\->user\->mojo > 50 ) {
\&                die $ALLOWED;
\&            } else {
\&                die $DENIED;
\&            }
\&        }
\&    );
.Ve
.SH "HANDLING DENIAL"
.IX Header "HANDLING DENIAL"
There are two plugin methods that can be called when a rule makes a decision
about an action:
.IP acl_access_allowed 4
.IX Item "acl_access_allowed"
A no-op
.IP acl_access_denied 4
.IX Item "acl_access_denied"
Looks for a private action named \f(CW\*(C`access_denied\*(C'\fR from the denied action's
controller and outwards (much like \f(CW\*(C`auto\*(C'\fR), and if none is found throws an
access denied exception.
.IP forcibly_allow_access 4
.IX Item "forcibly_allow_access"
Within an \f(CW\*(C`access_denied\*(C'\fR action this will immediately cause the blocked
action to be executed anyway.
.PP
This means that you have several alternatives:
.ie n .SS "Provide an ""access_denied"" action"
.el .SS "Provide an \f(CWaccess_denied\fP action"
.IX Subsection "Provide an access_denied action"
.Vb 1
\&    package MyApp::Controller::Foo;
\&
\&    sub access_denied : Private {
\&        my ( $self, $c, $action ) = @_;
\&
\&        ...
\&        $c\->forcibly_allow_access
\&            if $you\->mean_it eq "really";
\&    }
.Ve
.PP
If you call \f(CW\*(C`forcibly_allow_access\*(C'\fR then the blocked action will be
immediately unblocked. Otherwise the execution of the action will cease, and
return to it's caller or end.
.ie n .SS "Cleanup in ""end"""
.el .SS "Cleanup in \f(CWend\fP"
.IX Subsection "Cleanup in end"
.Vb 2
\&    sub end : Private {
\&        my ( $self, $c ) = @_;
\&
\&        if ( $c\->error and $c\->error\->[\-1] eq "access denied" ) {
\&            $c\->error(0); # clear the error
\&
\&            # access denied
\&        } else {
\&            # normal end
\&        }
\&    }
.Ve
.SS "Override the plugin event handler methods"
.IX Subsection "Override the plugin event handler methods"
.Vb 1
\&    package MyApp;
\&
\&    sub acl_access_allowed {
\&        my ( $c, $class, $action ) = @_;
\&        ...
\&    }
\&
\&    sub acl_access_denied {
\&        my ( $c, $class, $action, $err ) = @_;
\&        ...
\&    }
.Ve
.PP
\&\f(CW$class\fR is the controller class the \f(CW$action\fR object was going to be
executed in, and \f(CW$err\fR is the exception cought during rule evaluation, if
any (access is denied if a rule raises an exception).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst::Plugin::Authentication, Catalyst::Plugin::Authorization::Roles,
<http://catalyst.perl.org/calendar/2005/24>
.SH AUTHOR
.IX Header "AUTHOR"
Yuval Kogman <nothingmuch@woobling.org>
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
castaway: Jess Robinson
.PP
caelum: Rafael Kitover <rkitover@cpan.org>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2005 \- 2009
the Catalyst::Plugin::Authorization::ACL "AUTHOR" and "CONTRIBUTORS"
as listed above.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
