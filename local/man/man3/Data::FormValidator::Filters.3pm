.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::FormValidator::Filters 3pm"
.TH Data::FormValidator::Filters 3pm 2017-08-28 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Data::FormValidator::Filters \- Basic set of filters available in an Data::FormValidator profile.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::FormValidator;
\&
\&    %profile = (
\&        filters => \*(Aqtrim\*(Aq,
\&        ...
\&    );
\&
\&    my $results = Data::FormValidator\->check(  \e%data, \e%profile );
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
These are the builtin filters which may be specified as a name in the
\&\fIfilters\fR, \fIfield_filters\fR, and \fIfield_filter_regexp_map\fR parameters of the
input profile.
.PP
Filters are applied as the first step of validation, possibly modifying a copy
of the validation before any constraints are checked.
.SH "RECOMMENDED USE"
.IX Header "RECOMMENDED USE"
As a long time maintainer and user of Data::FormValidator, I recommend that
filters be used with caution. They are immediately modifying the input
provided, so the original data is lost. The few I recommend include \f(CW\*(C`trim\*(C'\fR,
which removes leading and trailing whitespace. I have this turned on by default
by using CGI::Application::Plugin::ValidateRM. It's also generally safe to use
the \f(CW\*(C`lc\*(C'\fR and \f(CW\*(C`uc\*(C'\fR filters if you need that kind of data transformation.
.PP
Beyond simple filters, I recommend transforming the \f(CW"valid"\fR hash returned
from validation if further changes are needed.
.SH "PROCEDURAL INTERFACE"
.IX Header "PROCEDURAL INTERFACE"
You may also call these functions directly through the
procedural interface by either importing them directly or importing the whole
\&\fI:filters\fR group. For example, if you want to access the \fItrim\fR function
directly, you could either do:
.PP
.Vb 3
\&    use Data::FormValidator::Filters (qw/filter_trim/);
\&    # or
\&    use Data::FormValidator::Filters (qw/:filters/);
\&
\&    $string = filter_trim($string);
.Ve
.PP
Notice that when you call filters directly, you'll need to prefix the filter name with
"filter_".
.SH "THE FILTERS"
.IX Header "THE FILTERS"
.SS FV_split
.IX Subsection "FV_split"
.Vb 1
\&  use Data::FormValidator::Filters qw(FV_split);
\&
\&  # Validate every e\-mail in a comma separated list
\&
\&  field_filters => {
\&     several_emails  => FV_split(qr/\es*,\es*/),
\&
\&     # Any pattern that can be used by the \*(Aqsplit\*(Aq builtin works.
\&     tab_sep_field   => FV_split(\*(Aq\et\*(Aq),
\&  },
\&  constraint_methods => {
\&    several_emails => email(),
\&  },
.Ve
.PP
With this filter, you can split a field into multiple values. The constraint for
the field will then be applied to every value.
.PP
This filter has a different naming convention because it is a higher-order
function.  Rather than returning a value directly, it returns a code reference
to a standard Data::FormValidator filter.
.PP
After successfully being validated the values will appear as an arrayref.
.SS FV_replace
.IX Subsection "FV_replace"
.Vb 1
\&  use Data::FormValidator::Filters qw(FV_replace);
\&
\&  field_filters => {
\&     first_name   => FV_replace(qr/Mark/,\*(AqDon\*(Aq),
\&  },
.Ve
.PP
FV_replace is a shorthand for writing simple find-and-replace filters.
The above filter would be translated to this:
.PP
.Vb 1
\& sub { my $v = shift; $v =~ s/Mark/Don/; $v }
.Ve
.PP
For more complex filters, just write your own.
.SS trim
.IX Subsection "trim"
Remove white space at the front and end of the fields.
.SS strip
.IX Subsection "strip"
Runs of white space are replaced by a single space.
.SS digit
.IX Subsection "digit"
Remove non digits characters from the input.
.SS alphanum
.IX Subsection "alphanum"
Remove non alphanumeric characters from the input.
.SS integer
.IX Subsection "integer"
Extract from its input a valid integer number.
.SS pos_integer
.IX Subsection "pos_integer"
Extract from its input a valid positive integer number.
.PP
Bugs: This filter won't extract "9" from "a9+", it will instead extract "9+"
.SS neg_integer
.IX Subsection "neg_integer"
Extract from its input a valid negative integer number.
.PP
Bugs: This filter will currently filter the case of "a9\-" to become "9\-",
which it should leave it alone.
.SS decimal
.IX Subsection "decimal"
Extract from its input a valid decimal number.
.PP
Bugs: Given "1,000.23", it will currently return "1.000.23"
.SS pos_decimal
.IX Subsection "pos_decimal"
Extract from its input a valid positive decimal number.
.PP
Bugs: Given "1,000.23", it will currently return "1.000.23"
.SS neg_decimal
.IX Subsection "neg_decimal"
Extract from its input a valid negative decimal number.
.PP
Bugs: Given "1,000.23", it will currently return "1.000.23"
.SS dollars
.IX Subsection "dollars"
Extract from its input a valid number to express dollars like currency.
.PP
Bugs: This filter won't currently remove trailing numbers like "1.234".
.SS phone
.IX Subsection "phone"
Filters out characters which aren't valid for an phone number. (Only
accept digits [0\-9], space, comma, minus, parenthesis, period and pound [#].)
.SS sql_wildcard
.IX Subsection "sql_wildcard"
Transforms shell glob wildcard (*) to the SQL like wildcard (%).
.SS quotemeta
.IX Subsection "quotemeta"
Calls the quotemeta (quote non alphanumeric character) builtin on its
input.
.SS lc
.IX Subsection "lc"
Calls the lc (convert to lowercase) builtin on its input.
.SS uc
.IX Subsection "uc"
Calls the uc (convert to uppercase) builtin on its input.
.SS ucfirst
.IX Subsection "ucfirst"
Calls the ucfirst (Uppercase first letter) builtin on its input.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP o 4
.IX Item "o"
.Vb 1
\& L<Data::FormValidator>
.Ve
.IP o 4
.IX Item "o"
.Vb 1
\& L<Data::FormValidator::Constraints>
.Ve
.IP o 4
.IX Item "o"
.Vb 1
\& L<Data::FormValidator::Filters::Image> \- shrink incoming image uploads
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
.Vb 2
\& Author:  Francis J. Lacoste <francis.lacoste@iNsu.COM>
\& Maintainer: Mark Stosberg <mark@summersault.com>
.Ve
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 1999,2000 iNsu Innovations Inc.
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms as perl itself.
