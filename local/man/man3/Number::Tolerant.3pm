.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Number::Tolerant 3pm"
.TH Number::Tolerant 3pm 2022-12-31 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Number::Tolerant \- tolerance ranges for inexact numbers
.SH VERSION
.IX Header "VERSION"
version 1.710
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& use Number::Tolerant;
\&
\& my $range  = tolerance(10 => to => 12);
\& my $random = 10 + rand(2);
\&
\& die "I shouldn\*(Aqt die" unless $random == $range;
\&
\& print "This line will always print.\en";
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Number::Tolerant creates a number-like object whose value refers to a range of
possible values, each equally acceptable.  It overloads comparison operations
to reflect this.
.PP
I use this module to simplify the comparison of measurement results to
specified tolerances.
.PP
.Vb 1
\& reject $product unless $measurement == $specification;
.Ve
.SH "PERL VERSION"
.IX Header "PERL VERSION"
This library should run on perls released even a long time ago.  It should work
on any version of perl released in the last five years.
.PP
Although it may work on older versions of perl, no guarantee is made that the
minimum required version will not be increased.  The version may be increased
for any reason, and there is no promise that patches will be accepted to lower
the minimum required perl.
.SH METHODS
.IX Header "METHODS"
.SS Instantiation
.IX Subsection "Instantiation"
\fInew\fR
.IX Subsection "new"
.PP
\fItolerance\fR
.IX Subsection "tolerance"
.PP
There is a \f(CW\*(C`new\*(C'\fR method on the Number::Tolerant class, but it also exports a
simple function, \f(CW\*(C`tolerance\*(C'\fR, which will return an object of the
Number::Tolerant class.  Both use the same syntax:
.PP
.Vb 1
\& my $range = Number::Tolerant\->new( $x => $method => $y);
\&
\& my $range = tolerance( $x => $method => $y);
.Ve
.PP
The meaning of \f(CW$x\fR and \f(CW$y\fR are dependent on the value of \f(CW$method\fR, which
describes the nature of the tolerance.  Tolerances can be defined in five ways,
at present:
.PP
.Vb 11
\&  method              range
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  plus_or_minus     | x +/\- y
\&  plus_or_minus_pct | x +/\- (y% of x)
\&  or_more           | x to Inf
\&  or_less           | x to \-Inf
\&  more_than         | x to Inf, not x
\&  less_than         | x to \-Inf, not x
\&  to                | x to y
\&  infinite          | \-Inf to Inf
\&  offset            | (x + y1) to (x + y2)
.Ve
.PP
For \f(CW\*(C`or_less\*(C'\fR and \f(CW\*(C`or_more\*(C'\fR, \f(CW$y\fR is ignored if passed.  For \f(CW\*(C`infinite\*(C'\fR,
neither \f(CW$x\fR nor \f(CW$y\fR is used; "infinite" should be the sole argument.  The
first two arguments can be reversed for \f(CW\*(C`more_than\*(C'\fR and \f(CW\*(C`less_than\*(C'\fR, to be
more English-like.
.PP
Offset tolerances are slightly unusual.  Here is an example:
.PP
.Vb 2
\&  my $offset_tolerance = tolerance(10 => offset => (\-3, 5));
\&  # stringifies to: 10 (\-3 +5)
.Ve
.PP
An offset is very much like a \f(CW\*(C`plus_or_minus\*(C'\fR tolerance, but its center value
is not necessarily the midpoint between its extremes.  This is significant for
comparisons and numifications of the tolerance.  Given the following two
tolerances:
.PP
.Vb 2
\&  my $pm_dice = tolerance(10.5 => plus_or_minus => 7.5);
\&  my $os_dice = tolerance(11 => offset => (\-8, 7));
.Ve
.PP
The first will sort as numerically less than the second.
.PP
If the given arguments can't be formed into a tolerance, an exception will be
raised.
.PP
\fIfrom_string\fR
.IX Subsection "from_string"
.PP
A new tolerance can be instantiated from the stringification of an old
tolerance.  For example:
.PP
.Vb 1
\& my $range = Number::Tolerant\->from_string("10 to 12");
\&
\& die "Everything\*(Aqs OK!" if 11 == $range; # program dies of joy
.Ve
.PP
This will \fInot\fR yet parse stringified unions, but that will be implemented in
the future.  (I just don't need it yet.)
.PP
If a string can't be parsed, an exception is raised.
.SS stringify_as
.IX Subsection "stringify_as"
.Vb 1
\&  my $string = $tolerance\->stringify_as($type);
.Ve
.PP
This method does nothing!  Someday, it will stringify the given tolerance as a
different type, if possible.  "10 +/\- 1" will
\&\f(CWstringify_as(\*(Aqplus_or_minus_pct\*(Aq)\fR to "10 +/\- 10%" for example.
.SS numify
.IX Subsection "numify"
.Vb 1
\&  my $n = $tolerance\->numify;
.Ve
.PP
This returns the numeric form of a tolerance.  If a tolerance has both a
minimum and a maximum, and they are the same, then that is the numification.
Otherwise, numify returns undef.
.SS Overloading
.IX Subsection "Overloading"
Tolerances overload a few operations, mostly comparisons.
.IP boolean 4
.IX Item "boolean"
Tolerances are always true.
.IP numify 4
.IX Item "numify"
Most tolerances numify to undef; see \f(CW"numify"\fR.
.IP stringify 4
.IX Item "stringify"
A tolerance stringifies to a short description of itself, generally something
like "m < x < n"
.Sp
.Vb 10
\& infinite  \- "any number"
\& to        \- "m <= x <= n"
\& or_more   \- "m <= x"
\& or_less   \- "x <= n"
\& more_than \- "m < x"
\& less_than \- "x < n"
\& offset    \- "x (\-y1 +y2)"
\& constant  \- "x"
\& plus_or_minus     \- "x +/\- y"
\& plus_or_minus_pct \- "x +/\- y%"
.Ve
.IP equality 4
.IX Item "equality"
A number is equal to a tolerance if it is neither less than nor greater than
it.  (See below).
.IP "smart match" 4
.IX Item "smart match"
Same as equality.
.IP comparison 4
.IX Item "comparison"
A number is greater than a tolerance if it is greater than its maximum value.
.Sp
A number is less than a tolerance if it is less than its minimum value.
.Sp
No number is greater than an "or_more" tolerance or less than an "or_less"
tolerance.
.Sp
"...or equal to" comparisons include the min/max values in the permissible
range, as common sense suggests.
.IP "tolerance intersection" 4
.IX Item "tolerance intersection"
A tolerance \f(CW\*(C`&\*(C'\fR a tolerance or number is the intersection of the two ranges.
Intersections allow you to quickly narrow down a set of tolerances to the most
stringent intersection of values.
.Sp
.Vb 2
\& tolerance(5 => to => 6) & tolerance(5.5 => to => 6.5);
\& # this yields: tolerance(5.5 => to => 6)
.Ve
.Sp
If the given values have no intersection, \f(CW\*(C`()\*(C'\fR is returned.
.Sp
An intersection with a normal number will yield that number, if it is within
the tolerance.
.IP "tolerance union" 4
.IX Item "tolerance union"
A tolerance \f(CW\*(C`|\*(C'\fR a tolerance or number is the union of the two.  Unions allow
multiple tolerances, whether they intersect or not, to be treated as one.  See
Number::Tolerant::Union for more information.
.SH EXTENDING
.IX Header "EXTENDING"
This feature is slighly experimental, but it's here.
.PP
New tolerance types may be written as subclasses of Number::Tolerant::Type,
providing the interface described in its documentation.  They can then be
enabled or disabled with the following methods:
.ie n .SS """ enable_plugin """
.el .SS "\f(CW enable_plugin \fP"
.IX Subsection " enable_plugin "
.Vb 1
\&  Number::Tolerant\->enable_plugin($class_name);
.Ve
.PP
This method enables the named class, so that attempts to create new tolerances
will check against this class.  Classes are checked against
\&\f(CW"validate_plugin"\fR before being enabled.  An exception is thrown if the
class does not appear to provide the Number::Tolerant::Type interface.
.ie n .SS """ disable_plugin """
.el .SS "\f(CW disable_plugin \fP"
.IX Subsection " disable_plugin "
.Vb 1
\&  Number::Tolerant\->disable_plugin($class_name);
.Ve
.PP
This method will disable the named class, so that future attempts to create new
tolerances will not check against this class.
.ie n .SS """ validate_plugin """
.el .SS "\f(CW validate_plugin \fP"
.IX Subsection " validate_plugin "
.Vb 1
\&  Number::Tolerant\->validate_plugin($class_name);
.Ve
.PP
This method checks (naively) that the given class provides the interface
defined in Number::Tolerant::Type.  If it does not, an exception is thrown.
.SH TODO
.IX Header "TODO"
.IP \(bu 4
Extend \f(CW\*(C`from_string\*(C'\fR to cover unions.
.IP \(bu 4
Extend \f(CW\*(C`from_string\*(C'\fR to include Number::Range\-type specifications.
.IP \(bu 4
Allow translation into forms not originally used:
.Sp
.Vb 3
\& my $range    = tolerance(9 => to => 17);
\& my $range_pm = $range\->convert_to(\*(Aqplus_minus\*(Aq);
\& $range\->stringify_as(\*(Aqplus_minus_pct\*(Aq);
.Ve
.IP \(bu 4
Create a factory so that you can simultaneously work with two sets of plugins.
.Sp
This one is very near completion.  There will now be two classes that should be
used:  Number::Tolerant::Factory, which produces tolerances, and
Number::Tolerant::Tolerance, which is a tolerance.  Both will inherit from
N::T, for supporting old code, and N::T will dispatch construction methods to a
default factory.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The module Number::Range provides another way to deal with ranges of
numbers.  The major differences are: N::R is set-like, not range-like; N::R
does not overload any operators.  Number::Tolerant will not (like N::R) attempt
to parse a textual range specification like "1..2,5,7..10" unless specifically
instructed to.  (The valid formats for strings passed to \f(CW\*(C`from_string\*(C'\fR does
not match Number::Range exactly.  See TODO.)
.PP
The \f(CW\*(C`Number::Range\*(C'\fR code:
.PP
.Vb 1
\& $range = Number::Range\->new("10..15","20..25");
.Ve
.PP
Is equivalent to the \f(CW\*(C`Number::Tolerant\*(C'\fR code:
.PP
.Vb 1
\& $range = Number::Tolerant::Union\->new(10..15,20..25);
.Ve
.PP
\&...while the following code expresses an actual range:
.PP
.Vb 1
\& $range = tolerance(10 => to => 15) | tolerance(20 => to => 25);
.Ve
.SH THANKS
.IX Header "THANKS"
Thanks to Yuval Kogman and #perl\-qa for helping find the bizarre bug that drove
the minimum required perl up to 5.8
.PP
Thanks to Tom Freedman, who reminded me that this code was fun to work on, and
also provided the initial implementation for the offset type.
.SH AUTHOR
.IX Header "AUTHOR"
Ricardo Signes <cpan@semiotic.systems>
.SH CONTRIBUTORS
.IX Header "CONTRIBUTORS"
.IP \(bu 4
Alexandre Mestiashvili <alex@biotec.tu\-dresden.de>
.IP \(bu 4
Karen Etheridge <ether@cpan.org>
.IP \(bu 4
Michael Carman <mjcarman@cpan.org>
.IP \(bu 4
Ricardo SIGNES <rjbs@codesimply.com>
.IP \(bu 4
Ricardo Signes <rjbs@semiotic.systems>
.IP \(bu 4
Smylers <Smylers@stripey.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2004 by Ricardo Signes.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
