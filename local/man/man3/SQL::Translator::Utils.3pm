.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Utils 3pm"
.TH SQL::Translator::Utils 3pm 2024-11-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Translator::Utils \- SQL::Translator Utility functions
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&  use SQL::Translator::Utils qw(debug);
\&  debug("PKG: Bad things happened");
.Ve
.SH DESCSIPTION
.IX Header "DESCSIPTION"
\&\f(CW\*(C`SQL::Translator::Utils\*(C'\fR contains utility functions designed to be
used from the other modules within the \f(CW\*(C`SQL::Translator\*(C'\fR modules.
.PP
Nothing is exported by default.
.SH "EXPORTED FUNCTIONS AND CONSTANTS"
.IX Header "EXPORTED FUNCTIONS AND CONSTANTS"
.SS debug
.IX Subsection "debug"
\&\f(CW\*(C`debug\*(C'\fR takes 0 or more messages, which will be sent to STDERR using
\&\f(CW\*(C`warn\*(C'\fR.  Occurances of the strings \fIPKG\fR, \fISUB\fR, and \fILINE\fR
will be replaced by the calling package, subroutine, and line number,
respectively, as reported by \f(CWcaller(1)\fR.
.PP
For example, from within \f(CW\*(C`foo\*(C'\fR in \fISQL/Translator.pm\fR, at line 666:
.PP
.Vb 1
\&  debug("PKG: Error reading file at SUB/LINE");
.Ve
.PP
Will warn
.PP
.Vb 1
\&  [SQL::Translator: Error reading file at foo/666]
.Ve
.PP
The entire message is enclosed within \f(CW\*(C`[\*(C'\fR and \f(CW\*(C`]\*(C'\fR for visual clarity
when STDERR is intermixed with STDOUT.
.SS normalize_name
.IX Subsection "normalize_name"
\&\f(CW\*(C`normalize_name\*(C'\fR takes a string and ensures that it is suitable for
use as an identifier.  This means: ensure that it starts with a letter
or underscore, and that the rest of the string consists of only
letters, numbers, and underscores.  A string that begins with
something other than [a\-zA\-Z] will be prefixer with an underscore, and
all other characters in the string will be replaced with underscores.
Finally, a trailing underscore will be removed, because that's ugly.
.PP
.Vb 1
\&  normalize_name("Hello, world");
.Ve
.PP
Produces:
.PP
.Vb 1
\&  Hello_world
.Ve
.PP
A more useful example, from the \f(CW\*(C`SQL::Translator::Parser::Excel\*(C'\fR test
suite:
.PP
.Vb 1
\&  normalize_name("silly field (with random characters)");
.Ve
.PP
returns:
.PP
.Vb 1
\&  silly_field_with_random_characters
.Ve
.SS header_comment
.IX Subsection "header_comment"
Create the header comment.  Takes 1 mandatory argument (the producer
classname), an optional comment character (defaults to \f(CW$DEFAULT_COMMENT\fR),
and 0 or more additional comments, which will be appended to the header,
prefixed with the comment character.  If additional comments are provided,
then a comment string must be provided ($DEFAULT_COMMENT is exported for
this use).  For example, this:
.PP
.Vb 1
\&  package My::Producer;
\&
\&  use SQL::Translator::Utils qw(header_comment $DEFAULT_COMMENT);
\&
\&  print header_comment(_\|_PACKAGE_\|_,
\&                       $DEFAULT_COMMENT,
\&                       "Hi mom!");
.Ve
.PP
produces:
.PP
.Vb 6
\&  \-\-
\&  \-\- Created by My::Prodcuer
\&  \-\- Created on Fri Apr 25 06:56:02 2003
\&  \-\-
\&  \-\- Hi mom!
\&  \-\-
.Ve
.PP
Note the gratuitous spacing.
.SS parse_list_arg
.IX Subsection "parse_list_arg"
Takes a string, list or arrayref (all of which could contain
comma-separated values) and returns an array reference of the values.
All of the following will return equivalent values:
.PP
.Vb 5
\&  parse_list_arg(\*(Aqid\*(Aq);
\&  parse_list_arg(\*(Aqid\*(Aq, \*(Aqname\*(Aq);
\&  parse_list_arg( \*(Aqid, name\*(Aq );
\&  parse_list_arg( [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ] );
\&  parse_list_arg( qw[ id name ] );
.Ve
.SS truncate_id_uniquely
.IX Subsection "truncate_id_uniquely"
Takes a string ($desired_name) and int ($max_symbol_length). Truncates
\&\f(CW$desired_name\fR to \f(CW$max_symbol_length\fR by including part of the hash of
the full name at the end of the truncated name, giving a high
probability that the symbol will be unique. For example,
.PP
.Vb 3
\&  truncate_id_uniquely( \*(Aqa\*(Aq x 100, 64 )
\&  truncate_id_uniquely( \*(Aqa\*(Aq x 99 . \*(Aqb\*(Aq, 64 );
\&  truncate_id_uniquely( \*(Aqa\*(Aq x 99,  64 )
.Ve
.PP
Will give three different results; specifically:
.PP
.Vb 3
\&  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa_7f900025
\&  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa_6191e39a
\&  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa_8cd96af2
.Ve
.ie n .SS $DEFAULT_COMMENT
.el .SS \f(CW$DEFAULT_COMMENT\fP
.IX Subsection "$DEFAULT_COMMENT"
This is the default comment string, '\-\-' by default.  Useful for
\&\f(CW\*(C`header_comment\*(C'\fR.
.SS parse_mysql_version
.IX Subsection "parse_mysql_version"
Used by both Parser::MySQL and
Producer::MySQL in order to provide a
consistent format for both \f(CW\*(C`parser_args\->{mysql_parser_version}\*(C'\fR and
\&\f(CW\*(C`producer_args\->{mysql_version}\*(C'\fR respectively. Takes any of the following
version specifications:
.PP
.Vb 6
\&  5.0.3
\&  4.1
\&  3.23.2
\&  5
\&  5.001005  (perl style)
\&  30201     (mysql style)
.Ve
.SS parse_dbms_version
.IX Subsection "parse_dbms_version"
Takes a version string (X.Y.Z) or perl style (XX.YYYZZZ) and a target ('perl'
or 'native') transforms the string to the given target style.
to
.SS throw
.IX Subsection "throw"
Throws the provided string as an object that will stringify back to the
original string.  This stops it from being mangled by Moo's \f(CW\*(C`isa\*(C'\fR
code.
.SS ex2err
.IX Subsection "ex2err"
Wraps an attribute accessor to catch any exception raised using
"throw" and store them in \f(CW\*(C`$self\->error()\*(C'\fR, finally returning
undef.  A reference to this function can be passed directly to
"around" in Moo.
.PP
.Vb 1
\&    around foo => \e&ex2err;
\&
\&    around bar => sub {
\&        my ($orig, $self) = (shift, shift);
\&        return ex2err($orig, $self, @_) if @_;
\&        ...
\&    };
.Ve
.SS carp_ro
.IX Subsection "carp_ro"
Takes a field name and returns a reference to a function can be used
around a read-only accessor to make it carp
instead of die when passed an argument.
.SS batch_alter_table_statements
.IX Subsection "batch_alter_table_statements"
Takes diff and argument hashes as passed to
batch_alter_table
and an optional list of producer functions to call on the calling package.
Returns the list of statements returned by the producer functions.
.PP
If no producer functions are specified, the following functions in the
calling package are called:
.IP "1. rename_table" 4
.IX Item "1. rename_table"
.PD 0
.IP "2. alter_drop_constraint" 4
.IX Item "2. alter_drop_constraint"
.IP "3. alter_drop_index" 4
.IX Item "3. alter_drop_index"
.IP "4. drop_field" 4
.IX Item "4. drop_field"
.IP "5. add_field" 4
.IX Item "5. add_field"
.IP "5. alter_field" 4
.IX Item "5. alter_field"
.IP "6. rename_field" 4
.IX Item "6. rename_field"
.IP "7. alter_create_index" 4
.IX Item "7. alter_create_index"
.IP "8. alter_create_constraint" 4
.IX Item "8. alter_create_constraint"
.IP "9. alter_table" 4
.IX Item "9. alter_table"
.PD
.PP
If the corresponding array in the hash has any elements, but the
caller doesn't implement that function, an exception is thrown.
.SH AUTHORS
.IX Header "AUTHORS"
Darren Chamberlain <darren@cpan.org>,
Ken Y. Clark <kclark@cpan.org>.
