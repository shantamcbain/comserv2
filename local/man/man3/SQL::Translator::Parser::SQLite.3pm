.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Parser::SQLite 3pm"
.TH SQL::Translator::Parser::SQLite 3pm 2024-11-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Translator::Parser::SQLite \- parser for SQLite
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&  use SQL::Translator;
\&  use SQL::Translator::Parser::SQLite;
\&
\&  my $translator = SQL::Translator\->new;
\&  $translator\->parser("SQL::Translator::Parser::SQLite");
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This is a grammar for parsing CREATE statements for SQLite as
described here:
.PP
.Vb 1
\&    http://www.sqlite.org/lang.html
.Ve
.PP
CREATE INDEX
.PP
sql-statement ::=
    CREATE [TEMP | TEMPORARY] [UNIQUE] INDEX index-name
     ON [database\-name .] table-name ( column-name [, column\-name]* )
     [ ON CONFLICT conflict-algorithm ]
.PP
column-name ::=
    name [ ASC | DESC ]
.PP
CREATE TABLE
.PP
sql-command ::=
    CREATE [TEMP | TEMPORARY] TABLE table-name (
        column-def [, column\-def]*
        [, constraint]*
     )
.PP
sql-command ::=
    CREATE [TEMP | TEMPORARY] TABLE table-name AS select-statement
.PP
column-def ::=
    name [type] [[CONSTRAINT name] column\-constraint]*
.PP
type ::=
    typename |
     typename ( number ) |
     typename ( number , number )
.PP
column-constraint ::=
    NOT NULL [ conflict-clause ] |
    PRIMARY KEY [sort\-order] [ conflict-clause ] |
    UNIQUE [ conflict-clause ] |
    CHECK ( expr ) [ conflict-clause ] |
    DEFAULT value
.PP
constraint ::=
    PRIMARY KEY ( name [, name]* ) [ conflict-clause ]|
    UNIQUE ( name [, name]* ) [ conflict-clause ] |
    CHECK ( expr ) [ conflict-clause ]
.PP
conflict-clause ::=
    ON CONFLICT conflict-algorithm
.PP
CREATE TRIGGER
.PP
sql-statement ::=
    CREATE [TEMP | TEMPORARY] TRIGGER trigger-name [ BEFORE | AFTER ]
    database-event ON [database\-name .] table-name
    trigger-action
.PP
sql-statement ::=
    CREATE [TEMP | TEMPORARY] TRIGGER trigger-name INSTEAD OF
    database-event ON [database\-name .] view-name
    trigger-action
.PP
database-event ::=
    DELETE |
    INSERT |
    UPDATE |
    UPDATE OF column-list
.PP
trigger-action ::=
    [ FOR EACH ROW | FOR EACH STATEMENT ] [ WHEN expression ]
        BEGIN
            trigger-step ; [ trigger-step ; ]*
        END
.PP
trigger-step ::=
    update-statement | insert-statement |
    delete-statement | select-statement
.PP
CREATE VIEW
.PP
sql-command ::=
    CREATE [TEMP | TEMPORARY] VIEW view-name AS select-statement
.PP
ON CONFLICT clause
.PP
.Vb 2
\&    conflict\-clause ::=
\&    ON CONFLICT conflict\-algorithm
\&
\&    conflict\-algorithm ::=
\&    ROLLBACK | ABORT | FAIL | IGNORE | REPLACE
.Ve
.PP
expression
.PP
expr ::=
    expr binary-op expr |
    expr like-op expr |
    unary-op expr |
    ( expr ) |
    column-name |
    table-name . column-name |
    database-name . table-name . column-name |
    literal-value |
    function-name ( expr-list | * ) |
    expr (+) |
    expr ISNULL |
    expr NOTNULL |
    expr [NOT] BETWEEN expr AND expr |
    expr [NOT] IN ( value-list ) |
    expr [NOT] IN ( select-statement ) |
    ( select-statement ) |
    CASE [expr] ( WHEN expr THEN expr )+ [ELSE expr] END
.PP
like\-op::=
    LIKE | GLOB | NOT LIKE | NOT GLOB
.SH AUTHOR
.IX Header "AUTHOR"
Ken Youens-Clark <kclark@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1), Parse::RecDescent, SQL::Translator::Schema.
