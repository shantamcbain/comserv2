.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Producer::TT::Table 3pm"
.TH SQL::Translator::Producer::TT::Table 3pm 2024-11-18 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
SQL::Translator::Producer::TT::Table \-
    Produces output using the Template Toolkit from a SQL schema, per table.
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 11
\&  # Normal STDOUT version
\&  #
\&  my $translator     = SQL::Translator\->new(
\&      from           => \*(AqMySQL\*(Aq,
\&      filename       => \*(Aqfoo_schema.sql\*(Aq,
\&      to             => \*(AqTT::Table\*(Aq,
\&      producer_args  => {
\&          tt_table     => \*(Aqfoo_table.tt\*(Aq,
\&      },
\&  );
\&  print $translator\->translate;
\&
\&  # To generate a file per table
\&  #
\&  my $translator     = SQL::Translator\->new(
\&      from           => \*(AqMySQL\*(Aq,
\&      filename       => \*(Aqfoo_schema.sql\*(Aq,
\&      to             => \*(AqTT::Table\*(Aq,
\&      producer_args  => {
\&          tt_table       => \*(Aqfoo_table.tt.html\*(Aq,
\&          mk_files      => 1,
\&          mk_files_base => "./doc/tables",
\&          mk_file_ext   => ".html",
\&          on_exists     => "replace",
\&      },
\&  );
\&  #
\&  # ./doc/tables/ now contains the templated tables as $tablename.html
\&  #
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Produces schema output using a given Template Tookit template,
processing that template for each table in the schema. Optionally
allows you to write the result for each table to a separate file.
.PP
It needs one additional producer_arg of \f(CW\*(C`tt_table\*(C'\fR which is the file
name of the template to use.  This template will be passed a template
var of \f(CW\*(C`table\*(C'\fR, which is the current
SQL::Translator::Schema::Table table we are producing,
which you can then use to walk the schema via the methods documented
in that module. You also get \f(CW\*(C`schema\*(C'\fR as a shortcut to the
SQL::Translator::Schema for the table and \f(CW\*(C`translator\*(C'\fR,
the SQL::Translator object for this parse in case you want to get
access to any of the options etc set here.
.PP
Here's a brief example of what the template could look like:
.PP
.Vb 5
\&  [% table.name %]
\&  ================
\&  [% FOREACH field = table.get_fields %]
\&      [% field.name %]   [% field.data_type %]([% field.size %])
\&  [% END \-%]
.Ve
.PP
See \fIt/data/template/table.tt\fR for a more complete example.
.PP
You can also set any of the options used to initialize the Template
object by adding them to your producer_args. See Template Toolkit docs
for details of the options.
.PP
.Vb 8
\&  $translator          = SQL::Translator\->new(
\&      to               => \*(AqTT\*(Aq,
\&      producer_args    => {
\&          ttfile       => \*(Aqfoo_template.tt\*(Aq,
\&          INCLUDE_PATH => \*(Aq/foo/templates/tt\*(Aq,
\&          INTERPOLATE  => 1,
\&      },
\&  );
.Ve
.PP
If you set \f(CW\*(C`mk_files\*(C'\fR and its additional options the producer will
write a separate file for each table in the schema. This is useful for
producing things like HTML documentation where every table gets its
own page (you could also use TTSchema producer to add an index page).
It's also particularly good for code generation where you want to
produce a class file per table.
.SH OPTIONS
.IX Header "OPTIONS"
.IP tt_table 4
.IX Item "tt_table"
File name of the template to run for each table.
.IP mk_files 4
.IX Item "mk_files"
Set to true to output a file for each table in the schema (as well as
returning the whole lot back to the Translalor and hence STDOUT). The
file will be named after the table, with the optional \f(CW\*(C`mk_files_ext\*(C'\fR
added and placed in the directory \f(CW\*(C`mk_files_base\*(C'\fR.
.IP mk_files_ext 4
.IX Item "mk_files_ext"
Extension (without the dot) to add to the filename when using mk_files.
.IP "mk_files_base = DIR" 4
.IX Item "mk_files_base = DIR"
Dir to build the table files into when using mk_files. Defaults to the
current directory.
.IP mk_file_dir 4
.IX Item "mk_file_dir"
Set true and if the file needs to written to a directory that doesn't
exist, it will be created first.
.IP "on_exists [Default:replace]" 4
.IX Item "on_exists [Default:replace]"
What to do if we are running with mk_files and a file already exists
where we want to write our output. One of "skip", "die", "replace",
"insert".  The default is die.
.Sp
\&\fBreplace\fR \- Over-write the existing file with the new one, clobbering
anything already there.
.Sp
\&\fBskip\fR \- Leave the original file as it was and don't write the new
version anywhere.
.Sp
\&\fBdie\fR \- Die with an existing file error.
.Sp
\&\fBinsert\fR \- Insert the generated output into the file between a set of
special comments (defined by the following options.) Any code between
the comments will be overwritten (ie the results from a previous
produce) but the rest of the file is left alone (your custom code).
This is particularly useful for code generation as it allows you to
generate schema derived code and then add your own custom code
to the file.  Then when the schema changes you just re-produce to
insert the new code.
.IP insert_comment_start 4
.IX Item "insert_comment_start"
The comment to look for in the file when on_exists is \f(CW\*(C`insert\*(C'\fR. Default
is \f(CW\*(C`SQLF INSERT START\*(C'\fR. Must appear on it own line, with only
whitespace either side, to be recognised.
.IP insert_comment_end 4
.IX Item "insert_comment_end"
The end comment to look for in the file when on_exists is \f(CW\*(C`insert\*(C'\fR.
Default is \f(CW\*(C`SQLF INSERT END\*(C'\fR. Must appear on it own line, with only
whitespace either side, to be recognised.
.SH AUTHOR
.IX Header "AUTHOR"
Mark Addison <grommit@users.sourceforge.net>.
.SH TODO
.IX Header "TODO"
\&\- Some tests for the various on exists options (they have been tested
implicitly through use in a project but need some proper tests).
.PP
\&\- More docs on code generation strategies.
.PP
\&\- Better hooks for filename generation.
.PP
\&\- Integrate with TT::Base and
  TTSchema.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Translator.
