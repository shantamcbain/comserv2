.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Migration::Tutorial::Testing 3pm"
.TH DBIx::Class::Migration::Tutorial::Testing 3pm 2020-06-02 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
DBIx::Class::Migration::Tutorial::Testing \- Test Your Database
.SH GOAL
.IX Header "GOAL"
Let's take an interlude from creating migrations and turn to writing test
cases for your database.
.PP
It would help if you are familiar with Test::Most and Test::DBIx::Class
and with general Perl testing procedures.  You could also benefit from reviewing
our fixtures hook class Test::DBIx::Class::FixtureCommand::Population.
.SH "Test your 1\-2 Upgrade"
.IX Header "Test your 1-2 Upgrade"
When doing upgrades it would be great to have some automated tests in place so
that whoever does the upgrade can immediately verify that all is well.  Let's
add a test case now!
.PP
.Vb 1
\&    touch t/upgrade\-1to2.t
.Ve
.PP
Then open the new files in the editor of choice and enter the following code:
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use Test::Most;
\&    use Test::DBIx::Class
\&      \-schema_class=>\*(AqMusicBase::Schema\*(Aq,
\&      \-fixture_class => \*(Aq::Population\*(Aq,
\&      qw(Artist Country);
\&
\&    plan skip_all => \*(Aqnot correct schema version\*(Aq
\&      if Schema\->schema_version != 2;
\&
\&    fixtures_ok [\*(Aqall_tables\*(Aq];
\&
\&    is Country\->count, 3, \*(AqCorrect Number of Countries\*(Aq;
\&    ok Artist\->first\->has_country, \*(AqArtist has a country\*(Aq;
\&
\&    done_testing;
.Ve
.PP
This creates a basic test case that only runs for version 2 of the schema (this
is just testing that the version 2 update was correct after all).  It uses
Test::DBIx::Class to automatically deploy a temporary test database (by
default it creates a \f(CW\*(C`SQLite\*(C'\fR in-memory database) which reflects the current 
schema and then we populate the \f(CW\*(C`all_tables\*(C'\fR fixtures using the utility class
DBIx::Class::Migration::Population which is part of the DBIx::Class::Migration
distribution.  (In this case, since we are using Test::DBIx::Class, we are
using the fixture hook Test::DBIx::Class::FixtureCommand::Population).
.PP
Before we can run the test case, we need to update our \f(CW\*(C`dist.ini\*(C'\fR
file.  Open this is a text editor and change it to look like this:
.PP
.Vb 6
\&    name    = DBIx\-Class\-Migration
\&    author  = John Napiorkowski <jjnapiork@cpan.org>
\&    license = Perl_5
\&    copyright_holder = John Napiorkowski
\&    copyright_year   = 2012
\&    abstract = Tutorial Application for DBIx\-Class\-Migration
\&
\&    version = 0.001
\&
\&    [@Basic]
\&    [Prereqs]
\&    DBIx::Class = 0
\&    DBIx::Class::Migration = 0
\&
\&    [Prereqs / TestRequires]
\&    Test::Most = 0
\&    Test::DBIx::Class = 0
.Ve
.PP
We just added a new section "[Prereqs / TestRequires]" and listed the two
testing modules.  Great, now install the new dependencies:
.PP
.Vb 1
\&    dzil listdeps | cpanm
.Ve
.PP
Perfect, we are now fully up to date and anyone that checks out our code can
also be sure to have all the right dependencies.  Let's run the test case:
.PP
.Vb 10
\&    $ prove \-lv t/upgrade\-1to2.t 
\&    t/upgrade\-1to2.t .. 
\&    Restored set all_tables to database
\&    ok 1 \- Correct Number of Tests
\&    ok 2 \- Artist has a country
\&    1..2
\&    ok
\&    All tests successful.
\&    Files=1, Tests=2,  1 wallclock secs ( ... )
\&    Result: PASS
.Ve
.PP
So hopefully that was easier database testing than you might be used too. :)
.SH "Additional Domain Logic Testing"
.IX Header "Additional Domain Logic Testing"
Let's create another test for the Artist ResultSet class.  You might have
wondered about this code, which you added way back at the start of the
tutorial:
.PP
\&\f(CW\*(C`lib/MusicBase/Schema/ResultSet/Artist.pm\*(C'\fR
.PP
.Vb 1
\&    package MusicBase::Schema::ResultSet::Artist;
\&
\&    use strict;
\&    use warnings;
\&    use base \*(AqDBIx::Class::ResultSet\*(Aq;
\&
\&    sub has_more_than_one_cds {
\&      my $me = (my $self = shift)\->current_source_alias;
\&      $self\->search(
\&        {},
\&        {
\&          join=>[\*(Aqcd_rs\*(Aq],
\&          \*(Aq+select\*(Aq=> [ { count => \*(Aqcd_rs.cd_id\*(Aq, \-as => \*(Aqcd_count\*(Aq} ],
\&          \*(Aq+as\*(Aq=> [\*(Aqcd_count\*(Aq],
\&          group_by=>["$me.artist_id"],
\&          having => { cd_count => { \*(Aq>\*(Aq, 1 } }
\&        }
\&      );
\&    }
\&
\&    1;
.Ve
.PP
This is a bit of logic that just returns the set of Artist with more than one
cd.  This is the kind of custom resultset logic your application may require
and therefore you should have a test case.  Let's build one:
.PP
.Vb 1
\&    touch t/more\-than\-1.t
.Ve
.PP
Then open \f(CW\*(C`t/more\-than\-1.t\*(C'\fR in your text editor and add this code:
.PP
.Vb 1
\&    #!/usr/bin/env perl
\&
\&    use Test::Most;
\&    use Test::DBIx::Class
\&      \-schema_class=>\*(AqMusicBase::Schema\*(Aq,
\&      \-fixture_class => \*(Aq::Population\*(Aq,
\&      qw(Artist);
\&
\&    fixtures_ok [\*(Aqall_tables\*(Aq];
\&
\&    ok my $more_than_one_rs =  Artist\->has_more_than_one_cds,
\&     \*(AqGot some artists\*(Aq;
\&
\&    is $more_than_one_rs\->count, 1,
\&      \*(AqGot expected number of artists with more than one CD\*(Aq;
\&
\&    done_testing;
.Ve
.PP
If you go back to the original fixture data, you'll see we only have one Artist
in the \f(CW\*(C`all_tables\*(C'\fR fixture set that has more than one CD (Michael Jackson).
.PP
Obviously this is a pretty minimal test case, but it at least gets you started.
let's run it:
.PP
.Vb 10
\&    $ prove \-lv t/more\-than\-1.t 
\&    t/more\-than\-1.t .. 
\&    Restored set all_tables to database
\&    ok 1 \- Got some artists
\&    ok 2 \- Got expected number of artists with more than one CD
\&    1..2
\&    ok
\&    All tests successful.
\&    Files=1, Tests=2,  1 wallclock secs ( ... )
\&    Result: PASS
.Ve
.PP
That's it for Testing!
.SH SUMMARY
.IX Header "SUMMARY"
This was a short section, but important.  We explored how straightforward it is
to create meaningful test cases using our generated fixtures, if you use the
right tools to help you.  We also explored the idea of limiting test cases to
certain database versions, which will be an important thing for you to remember
as you continue moving forward with your database changes.
.SH "NEXT STEPS"
.IX Header "NEXT STEPS"
Proceed to DBIx::Class::Migration::Tutorial::ThirdMigration
.SH AUTHOR
.IX Header "AUTHOR"
See DBIx::Class::Migration for author information
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
See DBIx::Class::Migration for copyright and license information
