.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "SQL-SPLIT 1p"
.TH SQL-SPLIT 1p 2021-06-05 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
sql\-split \- SQL splitting command line utility
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&    sql\-split [ OPTIONS ] [ FILE(S) ]
\&    sql\-split \-\-man
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This program tries to split any SQL code (even containing non-standard and/or
procedural extensions, at least the ones from the most popular DBMSs) into the
atomic statements it is composed of.
.PP
The given FILES are read and split one by one, and the resulting statements are
printed to the standard output, separated by a customizable string (see below).
Each given file must contain only full SQL statements, that is, no single atomic
statement can span multiple files.
.PP
If no file is given, or if one of the file names is a \f(CW\*(C`\-\*(C'\fR (dash), the SQL code
is read from STDIN, so that this program can be used as a \fIfilter\fR or even
interactively.
.PP
Consider however that this is by no means a validating parser, so that errors in
SQL code will not be detected (and can even lead to incorrect splitting).
.SH OPTIONS
.IX Header "OPTIONS"
.SS "\-t, \-\-terminators"
.IX Subsection "-t, --terminators"
It causes the trailing terminator tokens to be kept in the returned atomic
statements (by default they are discarded instead).
.PP
The strings currently recognized as terminators (depending on the context) are:
.IP \(bu 4
\&\f(CW\*(C`;\*(C'\fR (the \fIsemicolon\fR character);
.IP \(bu 4
any string defined by the MySQL \f(CW\*(C`DELIMITER\*(C'\fR command;
.IP \(bu 4
an \f(CW\*(C`;\*(C'\fR followed by an \f(CW\*(C`/\*(C'\fR (\fIforward-slash\fR character) on its own
line;
.IP \(bu 4
an \f(CW\*(C`;\*(C'\fR followed by an \f(CW\*(C`.\*(C'\fR (\fIdot\fR character) on its own line,
followed by an \f(CW\*(C`/\*(C'\fR on its own line;
.IP \(bu 4
an \f(CW\*(C`/\*(C'\fR on its own line regardless of the preceding characters
(only if the \f(CW\*(C`slash_terminates\*(C'\fR option, explained below, is set).
.PP
The multi-line terminators above are always treated as a single token, that is
they are discarded (or returned) as a whole (regardless of the
\&\f(CW\*(C`\-\-no\-slash\-terminates\*(C'\fR option value).
.SS "\-x, \-\-spaces, \-\-extra\-spaces"
.IX Subsection "-x, --spaces, --extra-spaces"
It causes the space characters around the statements, if any, to be kept in the
returned atomic statements (by default they are trimmed instead). A mnemonic for the 
short version is "X\-tra spaces".
.SS "\-c, \-\-comments"
.IX Subsection "-c, --comments"
It causes the comments, if any, to be kept in the returned atomic statements
(by default any comment is discarded instead).
.PP
Both SQL and multi-line C\-style comments are recognized.
.SS "\-m, \-\-empty, \-\-empty\-statements"
.IX Subsection "-m, --empty, --empty-statements"
It causes the empty statements to be returned (by default, they are discarded
instead).
.PP
A statement is considered empty when it contains no characters other than the
terminator and space characters. A statement composed solely of comments is not
recognized as empty and it is therefore returned, if the \f(CW\*(C`\-\-comments\*(C'\fR option is
used. Note instead that an empty statement is recognized as such regardless of
the use of the \f(CW\*(C`\-\-terminators\*(C'\fR and \f(CW\*(C`\-\-extra\-spaces\*(C'\fR options.
.PP
A mnemonic for this option is keep "M\-ty" statements.
.SS "\-\-no\-slash, \-\-no\-slash\-terminates"
.IX Subsection "--no-slash, --no-slash-terminates"
By default a \f(CW\*(C`/\*(C'\fR (\fIforward-slash\fR) on its own line, even without a preceding
semicolon, is admitted as a candidate terminator.
.PP
When this option is used instead, a forward-slash on its own line is treated as
a statement terminator only if preceded by a semicolon or by a dot and a
semicolon.
.PP
If you are dealing with Oracle's SQL, you should not use this option, since a
slash (alone, without a preceding semicolon) is often used as a terminator, as
it is permitted by SQL*Plus (on non\-\fIblock\fR statements).
.PP
With SQL dialects other than Oracle, there is the (theoretical) possibility that
a slash on its own line could pass the additional checks and be considered a
terminator (while it shouldn't). This chance should be really tiny (it has never
been observed in real world code indeed). Though negligible, this option will
anyway rule out that risk.
.SS "\-s, \-\-oss, \-\-output\-statement\-separator \fIstring\fP"
.IX Subsection "-s, --oss, --output-statement-separator string"
The string which will be printed between every pair of returned atomic
statements. By default, it is a \f(CW\*(C`\-\-\*(C'\fR (\fIdouble dash\fR) on its own line.
.PP
To use special characters (such as newlines) when passing such string, please
consult your shell docs (for example, in Bash the above mentioned default
separator could be defined as \f(CW\*(C`$\*(Aq\en\-\-\en\*(Aq\*(C'\fR).
.PP
Note that the last returned statement (for each processed file) will not be
followed by such separator.
.SS "\-f, \-\-ofs, \-\-output\-file\-separator \fIstring\fP"
.IX Subsection "-f, --ofs, --output-file-separator string"
The string which will be printed between the groups of statements coming from
different files. By default it is the \f(CW\*(C`\-\- >>>*<<< \-\-\*(C'\fR string on its own
line.
.PP
Similarly to the statement separator, the file separator will not be printed
after the last file.
.SS "\-e, \-\-error, \-\-on\-error \fIvalue\fP"
.IX Subsection "-e, --error, --on-error value"
It controls the program behavior in case one of the given files is not
accessible.
.PP
It can take the following values:
.IP \(bu 4
\&\f(CW\*(C`stop\*(C'\fR or \f(CW0\fR, which causes the program to die at the first file which
can not be opened, but it prints all the statements split that far (this is the
default);
.IP \(bu 4
\&\f(CW\*(C`continue\*(C'\fR or \f(CW1\fR, which causes the program, when it encounters a file
error, to just emit a warning (on STDERR) and continue with the next file;
.IP \(bu 4
\&\f(CW\*(C`no\-output\*(C'\fR or \f(CW2\fR, which, just like \f(CW\*(C`stop\*(C'\fR, causes the program to
die at the first file error, but in this case it does not print any statement,
not even those coming from the previous (already read) files; in other words,
the statements are printed out only if (and after) all of the given files have
been successfully read.
.PP
The above listed string values are case-insensitive.
.SS "\-h, \-?, \-\-help"
.IX Subsection "-h, -?, --help"
It prints a brief help message and exits.
.SS \-\-man
.IX Subsection "--man"
It shows the full man page.
.SS \-\-version
.IX Subsection "--version"
It prints the program version and exits.
.SH "SUPPORTED DBMSs"
.IX Header "SUPPORTED DBMSs"
sql-split aims to cover the widest possible range of DBMSs, SQL dialects and
extensions (even proprietary), in a (nearly) fully transparent way for the user.
.PP
Currently it has been tested mainly on SQLite, PostgreSQL, MySQL and Oracle.
.SS "Procedural Extensions"
.IX Subsection "Procedural Extensions"
Procedural code is by far the most complex to handle.
.PP
Currently any block of code which start with \f(CW\*(C`FUNCTION\*(C'\fR, \f(CW\*(C`PROCEDURE\*(C'\fR,
\&\f(CW\*(C`DECLARE\*(C'\fR, \f(CW\*(C`CREATE\*(C'\fR or \f(CW\*(C`CALL\*(C'\fR is correctly recognized, as well as
\&\fIanonymous\fR \f(CW\*(C`BEGIN ... END\*(C'\fR blocks, \fIdollar quoted\fR blocks and blocks
delimited by a \f(CW\*(C`DELIMITER\*(C'\fR\-defined \fIcustom terminator\fR, therefore a wide range
of procedural extensions should be handled correctly. However, only PL/SQL,
PL/PgSQL and MySQL code has been tested so far.
.SH LIMITATIONS
.IX Header "LIMITATIONS"
None currently known (other than the lack of tests on SQL dialects different
from the ones described above).
.SS Non-limitations
.IX Subsection "Non-limitations"
To be split correctly, the given input must, in general, be syntactically valid
SQL. For example, an unbalanced \f(CW\*(C`BEGIN\*(C'\fR or a misspelled keyword could, under
certain circumstances, confuse the parser and make it trip over the next
statement terminator, thus returning non-split statements. This should not
be a problem though, as the original (invalid) SQL code would have been unusable
anyway (remember that this is NOT a validating parser!)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP \(bu 4
SQL::SplitStatement (perldoc SQL::SplitStatement)
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright 2011 \fIEmanuele Zeppieri\fR <emazep@cpan.org>.
.SH LICENSE
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
.SH "NO WARRANTY"
.IX Header "NO WARRANTY"
This program comes with NO WARRANTIES of any kind. It not only may cause loss of
data and hardware damaging, but it may also cause several bad diseases to nearby
people, including, but not limited to, diarrhoea, gonorrhea and dysmenorrhea.
Don't say you haven't been warned.
